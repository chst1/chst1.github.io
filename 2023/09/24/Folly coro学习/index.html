<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="123456789title: folly协程Task学习date: 2023-09-24 17:59:18tags:    follycategories:    coromathjax:    truedescription: 听说Facebook目前已经将内部的future替换成协程coro了，恰巧工作中有相关协程使用的讨论，于是看一下folly中基于C++20协程封装的框架。 C++协程之">
<meta property="og:type" content="article">
<meta property="og:title" content="chst&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/2023/09/24/Folly coro学习/index.html">
<meta property="og:site_name" content="chst&#39;s Blog">
<meta property="og:description" content="123456789title: folly协程Task学习date: 2023-09-24 17:59:18tags:    follycategories:    coromathjax:    truedescription: 听说Facebook目前已经将内部的future替换成协程coro了，恰巧工作中有相关协程使用的讨论，于是看一下folly中基于C++20协程封装的框架。 C++协程之">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2023-09-24T10:00:39.518Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chst&#39;s Blog">
<meta name="twitter:description" content="123456789title: folly协程Task学习date: 2023-09-24 17:59:18tags:    follycategories:    coromathjax:    truedescription: 听说Facebook目前已经将内部的future替换成协程coro了，恰巧工作中有相关协程使用的讨论，于是看一下folly中基于C++20协程封装的框架。 C++协程之">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2023/09/24/Folly coro学习/">





  <title> | chst's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chst's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人网站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/09/24/Folly coro学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-09-24T17:56:07+08:00">
                2023-09-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2023/09/24/Folly coro学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2023/09/24/Folly coro学习/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: folly协程Task学习</span><br><span class="line">date: 2023-09-24 17:59:18</span><br><span class="line">tags:</span><br><span class="line">    folly</span><br><span class="line">categories:</span><br><span class="line">    coro</span><br><span class="line">mathjax:</span><br><span class="line">    true</span><br><span class="line">description: 听说Facebook目前已经将内部的future替换成协程coro了，恰巧工作中有相关协程使用的讨论，于是看一下folly中基于C++20协程封装的框架。</span><br></pre></td></tr></table></figure>
<center><font size="8">C++协程之folly coro</font></center>

<p>之前，介绍了<a href="https://www.yinkuiwang.cn/2023/01/08/folly%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%B8%8EDAG/" target="_blank" rel="noopener">folly的异步框架</a>，其调度中实际执行任务时由线程池完成。听说Facebook目前已经将内部的<code>future</code>替换成协程<code>coro</code>了，恰巧工作中有相关协程使用的讨论，于是看一下folly中基于C++20协程封装的框架。这里不介绍C++20协程的基本使用方式，想要了解可以看下面两个文档。</p>
<p><a href="https://en.cppreference.com/w/cpp/language/coroutines" target="_blank" rel="noopener">C++20协程官方文档</a></p>
<p><a href="https://lewissbaker.github.io/" target="_blank" rel="noopener">协程原理及C++20使用</a></p>
<h1 id="基础背景"><a href="#基础背景" class="headerlink" title="基础背景"></a>基础背景</h1><p>协程相较于线程，其性能更优，由开发人员自己实现任务切换，而不用操作系统进行切换，避免了操作系统线程切换的开销。同时，协程提供了新的开发范式，协程可以看做一个天然的动态DAG调度框架，当某段处理逻辑计算依赖某个数据时，我们可以通过协程切换，先去获取到对应数据，等拿到对应数据后在切换回原逻辑继续执行。对于在执行过程中才能判断是否要执行的数据，对于静态图来说，其支持较为困难，可能需要在图中增加动态的disable逻辑，而使用协程，其天然支持动态决策，灵活性更高。</p>
<p>例如如下一个简单逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def Function():</span><br><span class="line">	a = FunctionA();</span><br><span class="line">	template result;</span><br><span class="line">	if(a) &#123;</span><br><span class="line">		result = FunctionB();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		result = FunctionC()</span><br><span class="line">	&#125;</span><br><span class="line">	// 对result进一步处理</span><br><span class="line">	return result;</span><br></pre></td></tr></table></figure>
<p>对于如上逻辑，其含义是，Function的执行依赖了三个函数<code>FunctionA</code>，<code>FunctionB</code>,<code>FunctionC</code>。其中对于B,C函数来说，其执行依赖于A的结果，对于静态构图，可能的形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      FunctionA</span><br><span class="line">          /\</span><br><span class="line">         /  \</span><br><span class="line">        /    \</span><br><span class="line">FunctionB   FunctionC</span><br><span class="line">				\    /</span><br><span class="line">				 \  /</span><br><span class="line">			 Function</span><br></pre></td></tr></table></figure>
<p>在<code>FunctionB</code>和<code>FunctionC</code>中根据<code>FunctionA</code>的值进行判断，来决定是否执行。</p>
<p>其实现方式较为繁琐，需要将一个节点拆分成为多个节点。</p>
<p>使用协程泽不需要如此繁琐，其实现如上面的伪代码基本一致，可能变成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def Function():</span><br><span class="line">	co_await a = FunctionA();</span><br><span class="line">	template result;</span><br><span class="line">	if(a) &#123;</span><br><span class="line">		co_await result = FunctionB();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		co_await result = FunctionC()</span><br><span class="line">	&#125;</span><br><span class="line">	// 对result进一步处理</span><br><span class="line">	return result;</span><br></pre></td></tr></table></figure>
<p>当我们需要某个数据时，使用协程切换，将执行逻辑切换到对应的数据获取方法上即可，当取回数据后，再回到原函数中继续进行处理。处理协程函数也是放到一个大的线程池中处理。这样，我们将要获取的数据全都直接丢到线程池中，由协程调度来自动寻找其依赖的函数，自动丢到线程池中，这样就只需要一个线程池，一个协程调度，就完美的实现了一个动态dag。</p>
<p>这里还存在一些问题，会在后续讲解中逐步回答：</p>
<ol>
<li>如果一个节点被多个算子依赖，如何避免被重复计算。</li>
<li>一个节点依赖多个数据，如果每一次执行到要使用的位置在切换协程获取，那会导致每个字段获取串行执行，如何让依赖尽可能并发执行（这个其实和动态图有一定的冲突，但往往是一个强需求）。</li>
</ol>
<h1 id="Task使用"><a href="#Task使用" class="headerlink" title="Task使用"></a>Task使用</h1><p><code>folly</code>实现的coro核心是Task类，folly官方文档上有十分详细的介绍，这里只贴出来一个使用样例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"folly/experimental/coro/BlockingWait.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/executors/GlobalExecutor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/init/Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;folly/experimental/coro/Task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/experimental/coro/Collect.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/experimental/coro/SharedMutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"folly/executors/CPUThreadPoolExecutor.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> folly;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> folly::coro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> get_us_time() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span>;</span></span><br><span class="line">    gettimeofday(&amp;t, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int64_t</span>)(t.tv_sec * <span class="number">1000000</span> + t.tv_usec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> folly::<span class="function">CPUThreadPoolExecutor&amp; <span class="title">get_executor1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> folly::<span class="function">CPUThreadPoolExecutor <span class="title">executor</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> folly::<span class="function">CPUThreadPoolExecutor&amp; <span class="title">get_executor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> folly::<span class="function">CPUThreadPoolExecutor <span class="title">executor</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SharedMutexFair coro_lock;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; global_value = &#123;</span><br><span class="line">    &#123;<span class="string">"a"</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"b"</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"c"</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"d"</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> global = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; a() &#123;</span><br><span class="line">    global_value[<span class="string">"a"</span>] = ++global;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"a process time is "</span>&lt;&lt;get_us_time()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; b() &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    global_value[<span class="string">"b"</span>] = ++global;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"b process time is "</span>&lt;&lt;get_us_time()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; c() &#123;</span><br><span class="line">    global_value[<span class="string">"c"</span>] = ++global;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"c process time is "</span>&lt;&lt;get_us_time()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; d() &#123;</span><br><span class="line">    global_value[<span class="string">"d"</span>] = ++global;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"d process time is "</span>&lt;&lt;get_us_time()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; getA() &#123;</span><br><span class="line">    <span class="comment">// Lock lock(mutex);</span></span><br><span class="line">    <span class="keyword">auto</span> lock = co_await coro_lock.co_scoped_lock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"process get A"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; getB() &#123;</span><br><span class="line">    <span class="comment">// Lock lock(mutex);</span></span><br><span class="line">    <span class="keyword">auto</span> lock = co_await coro_lock.co_scoped_lock();</span><br><span class="line">    co_await getA().scheduleOn(getGlobalCPUExecutor());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"process get B"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; getB_unlock() &#123;</span><br><span class="line">    co_await getA().scheduleOn(getGlobalCPUExecutor());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"process get B unlock"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">bool</span>&gt; sycn() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Task&lt;<span class="keyword">void</span>&gt;&gt; sum;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Coroutine started on thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    sum.push_back(a());</span><br><span class="line">    sum.push_back(b());</span><br><span class="line">    sum.push_back(c());</span><br><span class="line">    sum.push_back(d());</span><br><span class="line">    <span class="comment">// co_await folly::coro::collectAll(sum);</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        co_await folly::coro::collectAllRange(<span class="built_in">std</span>::move(sum));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"catch error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Coroutine ended on thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    co_return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">bool</span>&gt; sycn_v2() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Task&lt;<span class="keyword">void</span>&gt;&gt; sum;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Coroutine started on thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    sum.push_back(a());</span><br><span class="line">    sum.push_back(b());</span><br><span class="line">    sum.push_back(c());</span><br><span class="line">    sum.push_back(d());</span><br><span class="line">    <span class="comment">// co_await folly::coro::collectAll(sum);</span></span><br><span class="line">    co_await folly::coro::collectAllRange(<span class="built_in">std</span>::move(sum)).scheduleOn(&amp;get_executor1());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Coroutine ended on thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    co_return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">bool</span>&gt; asycn() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TaskWithExecutor&lt;<span class="keyword">void</span>&gt;&gt; sum;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Coroutine started on thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    sum.push_back(a().scheduleOn(getGlobalCPUExecutor()));</span><br><span class="line">    sum.push_back(b().scheduleOn(getGlobalCPUExecutor()));</span><br><span class="line">    sum.push_back(c().scheduleOn(getGlobalCPUExecutor()));</span><br><span class="line">    sum.push_back(d().scheduleOn(getGlobalCPUExecutor()));</span><br><span class="line">    co_await folly::coro::collectAllRange(<span class="built_in">std</span>::move(sum));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Coroutine ended on thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    co_return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folly::init(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="comment">// std::cout&lt;&lt;"process1"&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="comment">// auto exe = getCPUExecutor();</span></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"info test"</span>;</span><br><span class="line">    <span class="keyword">auto</span> task1 = sycn();</span><br><span class="line">    folly::coro::blockingWait(<span class="built_in">std</span>::move(task1).scheduleOn(&amp;get_executor2()));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"a is "</span>&lt;&lt;global_value[<span class="string">"a"</span>]&lt;&lt;<span class="string">" b is "</span>&lt;&lt;global_value[<span class="string">"b"</span>]&lt;&lt;<span class="string">" c is "</span>&lt;&lt;global_value[<span class="string">"c"</span>]&lt;&lt;<span class="string">" d is "</span>&lt;&lt;global_value[<span class="string">"d"</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"global is "</span>&lt;&lt;global&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task3 = sycn_v2();</span><br><span class="line">    folly::coro::blockingWait(<span class="built_in">std</span>::move(task3).scheduleOn(&amp;get_executor2()));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"a is "</span>&lt;&lt;global_value[<span class="string">"a"</span>]&lt;&lt;<span class="string">" b is "</span>&lt;&lt;global_value[<span class="string">"b"</span>]&lt;&lt;<span class="string">" c is "</span>&lt;&lt;global_value[<span class="string">"c"</span>]&lt;&lt;<span class="string">" d is "</span>&lt;&lt;global_value[<span class="string">"d"</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"global is "</span>&lt;&lt;global&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task2 = asycn();</span><br><span class="line">    folly::coro::blockingWait(<span class="built_in">std</span>::move(task2).scheduleOn(&amp;get_executor2()));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"a is "</span>&lt;&lt;global_value[<span class="string">"a"</span>]&lt;&lt;<span class="string">" b is "</span>&lt;&lt;global_value[<span class="string">"b"</span>]&lt;&lt;<span class="string">" c is "</span>&lt;&lt;global_value[<span class="string">"c"</span>]&lt;&lt;<span class="string">" d is "</span>&lt;&lt;global_value[<span class="string">"d"</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"global is "</span>&lt;&lt;global&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    folly::coro::blockingWait(getB_unlock().scheduleOn(&amp;get_executor2()));</span><br><span class="line"></span><br><span class="line">    folly::coro::blockingWait(getB().scheduleOn(&amp;get_executor2()));</span><br><span class="line">    google::ShutdownGoogleLogging();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g++ -L/opt/lib -I/opt/include test_folly_coro.cpp -std=c++20 -lfolly -lglog -lgflags -lpthread -ldl -ldouble-conversion -lfmt -levent -lboost_context</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">Coroutine started on thread: 139646669821504</span><br><span class="line">a process time is 1695172727482615</span><br><span class="line">b process time is 1695172729482921</span><br><span class="line">c process time is 1695172729482970</span><br><span class="line">d process time is 1695172729482983</span><br><span class="line">Coroutine ended on thread: 139646669821504</span><br><span class="line">a is 1 b is 2 c is 3 d is 4</span><br><span class="line">global is 4</span><br><span class="line">Coroutine started on thread: 139646669821504</span><br><span class="line">a process time is 1695172729484680</span><br><span class="line">b process time is 1695172731484800</span><br><span class="line">c process time is 1695172731484854</span><br><span class="line">d process time is 1695172731484864</span><br><span class="line">Coroutine ended on thread: 139646669821504</span><br><span class="line">a is 5 b is 6 c is 7 d is 8</span><br><span class="line">global is 8</span><br><span class="line">Coroutine started on thread: 139646669821504</span><br><span class="line">a process time is 1695172731486864</span><br><span class="line">c process time is 1695172731487174</span><br><span class="line">d process time is 1695172731487422</span><br><span class="line">b process time is 1695172733486971</span><br><span class="line">Coroutine ended on thread: 139646669821504</span><br><span class="line">a is 9 b is 12 c is 10 d is 11</span><br><span class="line">global is 12</span><br><span class="line">process get A</span><br><span class="line">process get B unlock</span><br><span class="line">^C</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>可以看到调用<code>sycn</code>时，其输出严格有序，调用<code>asycn</code>时，其输出就是无序的了。这里说明了一个问题是，调用<code>collectAllRange</code>时，如果task本身是同步方法，则其会被串行调用，如果其本身是异步方法，则调用就会异步执行。</p>
<p>同时可以看到调用异步方法<code>asycn</code>时，在<code>co_await</code>前后执行执行在相同的线程池，虽然我们设置了<code>co_await</code>等待的<code>task</code>在另外的线程池执行。这是因为<code>Task</code>的<code>promise_type</code>的<code>await_transform</code>方法调用了<code>co_viaIfAsync</code>，保证协程始终在指定线程池中执行。当<code>await_suspend</code>返回<code>void</code>或者<code>false</code>时，会立即返回给协程函数的调用者。同时协程处于<code>suspend</code>状态。按照如此逻辑，上面实例代码，在执行<code>async</code>函数内部逻辑时（即<code>async</code>协程第一次被<code>resume</code>，即被<code>co_await</code>时），在调用<code>co_await</code>方法前，逻辑都执行在主线程中，当调用<code>co_await</code>时，直接返回到主流程中开始执行下面的语句了，而<code>async</code>协程被挂起，被<code>co_awiat</code>的协程被分配到线程池中执行，在这些协程执行结束后，重新唤醒<code>async</code>协程，由于<code>co_viaIfAsync</code>方法封装了一层协程，保证被唤醒的<code>async</code>协程依然在原线程池中执行。</p>
<p>这里想要说明的一点是，线程池执行协程函数时，如果被<code>suspend</code>而未拉起其他协程的协程（当<code>await_suspend</code>返回<code>coroutine handle</code>时，会立即执行<code>coroutine handle</code>对应的协程，原协程被挂起，至于执行完成新的协程后的处理逻辑，则由新的协程处理函数决定，可以选择恢复原协程，也可以选择再拉起一个协程，或者什么都不干。相当于使用新的协程上下文替换原协程的上下文，新协程执行逻辑和原协程无关，执行完成也不存在要返回到某个原协程的什么位置的概念），并不会占用线程池，因为<font color="red">被suspend的协程函数，会立即返回到调用处（不是返回到调用<code>co_await</code>的地方，而是协程函数的入口位置）</font>，在task中，一般是回到<code>resumeCoroutineWithNewAsyncStackRoot</code>函数中的<code>h.resume();</code>，这样线程就会认为执行完成了该task，会继续从线程池的task任务池中取其他的task。而未完成的协程调用什么时候继续呢，会在线程池调用的某个方法中调用被暂停协程的<code>resume</code>方法时被继续执行。这里也说明一个问题，应该尽可能的避免协程被suspend而不拉起新的协程，因为当出现这种情况时，线程池会需要从task队列中查找新的任务，这势必会造成额外的开销，相当于协程的链式调度切换失效了。不论怎么样，当线程池中执行的都是协程函数时，可以大大减少线程池数量，理论上来说，线程池数量和cpu核数绑定即可。</p>
<p>这里还有一个对协程锁的验证，可以看到，程序最终会卡住，这时因为执行<code>getB()</code>函数时，我们获取了锁，在没有释放的前提下协程被切换到了执行<code>getA()</code>函数，这里再次尝试获取锁，这就造成了死锁。这里说明了，协程锁不能解决由于协程切换造成的死锁问题，使用协程锁，更需要考虑死锁问题，要保证协程切换时锁要被正常释放。</p>
<p>对于这个例子，可以仅仅简单运行一下，当前不必深究，当完整了解coro实现后可以回过来来再看一下。</p>
<p><code>Task</code>包含了大量的基础类，这里我们进行逐一介绍。</p>
<h1 id="TaskPromiseBase"><a href="#TaskPromiseBase" class="headerlink" title="TaskPromiseBase"></a>TaskPromiseBase</h1><p><code>TaskPromiseBase</code>是Task的<code>promise_type</code>的基类，其决定了返回Task协程函数的实际执行逻辑。因此先介绍其具体实现。</p>
<p><code>TaskPromiseBase</code>类包含如下成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskPromiseBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">	ExtendedCoroutineHandle continuation_;</span><br><span class="line">  folly::AsyncStackFrame asyncFrame_;</span><br><span class="line">  folly::Executor::KeepAlive&lt;&gt; executor_;</span><br><span class="line">  folly::CancellationToken cancelToken_;</span><br><span class="line">  <span class="keyword">bool</span> hasCancelTokenOverride_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> ownsAsyncFrame_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">BypassExceptionThrowing</span> :</span> <span class="keyword">uint8_t</span> &#123;</span><br><span class="line">    INACTIVE,</span><br><span class="line">    ACTIVE,</span><br><span class="line">    REQUESTED,</span><br><span class="line">  &#125; bypassExceptionThrowing_&#123;BypassExceptionThrowing::INACTIVE&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ExtendedCoroutineHandle"><a href="#ExtendedCoroutineHandle" class="headerlink" title="ExtendedCoroutineHandle"></a>ExtendedCoroutineHandle</h2><p>该类是<code>coroutine_handle&lt;void&gt;</code>的拓展版本，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedCoroutineHandle</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="comment">/*implicit*/</span> ExtendedCoroutineHandle(</span><br><span class="line">      coroutine_handle&lt;Promise&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">      : basic_(handle), extended_(fromBasic(handle)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*implicit*/</span> ExtendedCoroutineHandle(coroutine_handle&lt;&gt; handle) <span class="keyword">noexcept</span></span><br><span class="line">      : basic_(handle) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*implicit*/</span> ExtendedCoroutineHandle(ExtendedCoroutinePromise* ptr) <span class="keyword">noexcept</span></span><br><span class="line">      : basic_(ptr-&gt;getHandle()), extended_(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ExtendedCoroutineHandle() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123; basic_.resume(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; basic_.destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  coroutine_handle&lt;&gt; getHandle() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> basic_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ExtendedCoroutinePromise* <span class="title">getPromise</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> extended_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;ExtendedCoroutineHandle, AsyncStackFrame*&gt; getErrorHandle(</span><br><span class="line">      exception_wrapper&amp; ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (extended_) &#123;</span><br><span class="line">      <span class="keyword">return</span> extended_-&gt;getErrorHandle(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;basic_, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> !!basic_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">fromBasic</span><span class="params">(coroutine_handle&lt;Promise&gt; handle)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_convertible_v&lt;Promise*, ExtendedCoroutinePromise*&gt;)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ExtendedCoroutinePromise*&gt;(&amp;handle.promise());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  coroutine_handle&lt;&gt; basic_;</span><br><span class="line">  ExtendedCoroutinePromise* extended_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实际存储的是调用<code>co_await</code>的协程的<code>coroutine_handle</code>。用于执行完成当前协程函数后，唤醒原来被切换出去的协程函数。举例来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;T&gt; func &#123;</span><br><span class="line">	...</span><br><span class="line">	co_await ()-&gt;Task&lt;T&gt;&#123;</span><br><span class="line">		....</span><br><span class="line">	&#125;();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个协程函数中，当执行到co_await时，当前协程函数<code>func</code>会被暂停，执行调度到co_await对应的<code>lambda</code>函数中去，但是当对于的<code>lambda</code>执行完成后，如何回到原来的函数呢，这个工作是由Task自己完成的，不需要用户指定，其实现的核心就是这里的<code>continuation_</code>（ExtendedCoroutineHandle类），lambda函数对应的Task中的<code>promise_type</code>会持有<code>func</code>协程的<code>coroutine_handle</code>。当lambda执行完成后，调用<code>coroutine_handle</code>的resume即唤醒<code>func</code>协程。</p>
<p>其中<code>ExtendedCoroutinePromise</code>是扩展的promise，这里其仅仅充当接口（因此是纯虚类），其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedCoroutinePromise</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> coroutine_handle&lt;&gt; getHandle() = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Types may provide a more efficient resumption path when they know they will</span></span><br><span class="line">  <span class="comment">// be receiving an error result from the awaitee.</span></span><br><span class="line">  <span class="comment">// If they do, they might also update the active stack frame.</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::pair&lt;ExtendedCoroutineHandle, AsyncStackFrame*&gt; getErrorHandle(</span><br><span class="line">      exception_wrapper&amp;) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ~ExtendedCoroutinePromise() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="AsyncStackFrame"><a href="#AsyncStackFrame" class="headerlink" title="AsyncStackFrame"></a>AsyncStackFrame</h2><p>异步栈帧，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An async stack frame contains information about a particular</span></span><br><span class="line"><span class="comment">// invocation of an asynchronous operation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example, asynchronous operations implemented using coroutines</span></span><br><span class="line"><span class="comment">// would have each coroutine-frame contain an instance of AsyncStackFrame</span></span><br><span class="line"><span class="comment">// to record async-stack trace information for that coroutine invocation.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncStackFrame</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  AsyncStackFrame() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The parent frame is the frame of the async operation that is logically</span></span><br><span class="line">  <span class="comment">// the caller of this frame.</span></span><br><span class="line">  <span class="function">AsyncStackFrame* <span class="title">getParentFrame</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> AsyncStackFrame* <span class="title">getParentFrame</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParentFrame</span><span class="params">(AsyncStackFrame&amp; frame)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get access to the current stack-root.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This is only valid for either the root or leaf AsyncStackFrame</span></span><br><span class="line">  <span class="comment">// in a chain of frames.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In the case of an active leaf-frame it is used as a cache to</span></span><br><span class="line">  <span class="comment">// avoid accessing the thread-local when pushing/popping frames.</span></span><br><span class="line">  <span class="comment">// In the case of the root frame (which has a null parent frame)</span></span><br><span class="line">  <span class="comment">// it points to an AsyncStackRoot that contains information about</span></span><br><span class="line">  <span class="comment">// the normal-stack caller.</span></span><br><span class="line">  <span class="function">AsyncStackRoot* <span class="title">getStackRoot</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The return address is generallty the address of the code in the</span></span><br><span class="line">  <span class="comment">// caller that will be executed when the operation owning the current</span></span><br><span class="line">  <span class="comment">// frame completes.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setReturnAddress</span><span class="params">(<span class="keyword">void</span>* p = FOLLY_ASYNC_STACK_RETURN_ADDRESS())</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">getReturnAddress</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> AsyncStackRoot;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> AsyncStackFrame&amp; <span class="title">getDetachedRootAsyncStackFrame</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">activateAsyncStackFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::AsyncStackRoot&amp;, folly::AsyncStackFrame&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">deactivateAsyncStackFrame</span><span class="params">(folly::AsyncStackFrame&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">pushAsyncStackFrameCallerCallee</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::AsyncStackFrame&amp;, folly::AsyncStackFrame&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">checkAsyncStackFrameIsActive</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> folly::AsyncStackFrame&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">popAsyncStackFrameCallee</span><span class="params">(folly::AsyncStackFrame&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pointer to the async caller's stack-frame info.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This forms a linked-list of frames that make up a stack.</span></span><br><span class="line">  <span class="comment">// The list is terminated by a null pointer which indicates</span></span><br><span class="line">  <span class="comment">// the top of the async stack - either because the operation</span></span><br><span class="line">  <span class="comment">// is detached or because the next frame is a thread that is</span></span><br><span class="line">  <span class="comment">// blocked waiting for the async stack to complete.</span></span><br><span class="line">  AsyncStackFrame* parentFrame = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instruction pointer of the caller of this frame.</span></span><br><span class="line">  <span class="comment">// This will typically be either the address of the continuation</span></span><br><span class="line">  <span class="comment">// of this asynchronous operation, or the address of the code</span></span><br><span class="line">  <span class="comment">// that launched this asynchronous operation. May be null</span></span><br><span class="line">  <span class="comment">// if the address is not known.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Typically initialised with the result of a call to</span></span><br><span class="line">  <span class="comment">// FOLLY_ASYNC_STACK_RETURN_ADDRESS().</span></span><br><span class="line">  <span class="keyword">void</span>* instructionPointer = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pointer to the stack-root for the current thread.</span></span><br><span class="line">  <span class="comment">// Cache this in each async-stack frame so we don't have to</span></span><br><span class="line">  <span class="comment">// read from a thread-local to get the pointer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This pointer is only valid for the top-most stack frame.</span></span><br><span class="line">  <span class="comment">// When a frame is pushed or popped it should be copied to</span></span><br><span class="line">  <span class="comment">// the next frame, etc.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The exception is for the bottom-most frame (ie. where</span></span><br><span class="line">  <span class="comment">// parentFrame == null). In this case, if stackRoot is non-null</span></span><br><span class="line">  <span class="comment">// then it points to a root that is currently blocked on some</span></span><br><span class="line">  <span class="comment">// thread waiting for the async work to complete. In this case</span></span><br><span class="line">  <span class="comment">// you can find the information about the stack-frame for that</span></span><br><span class="line">  <span class="comment">// thread in the AsyncStackRoot and can use it to continue</span></span><br><span class="line">  <span class="comment">// walking the stack-frames.</span></span><br><span class="line">  AsyncStackRoot* stackRoot = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> AsyncStackFrame* AsyncStackFrame::getParentFrame() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> parentFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> AsyncStackFrame* AsyncStackFrame::getParentFrame() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> parentFrame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> AsyncStackFrame::setParentFrame(AsyncStackFrame&amp; frame) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  parentFrame = &amp;frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> AsyncStackRoot* AsyncStackFrame::getStackRoot() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> stackRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> AsyncStackFrame::setReturnAddress(<span class="keyword">void</span>* p) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  instructionPointer = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* AsyncStackFrame::getReturnAddress() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instructionPointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> AsyncStackRoot::setTopFrame(AsyncStackFrame&amp; frame) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  assert(<span class="keyword">this</span>-&gt;topFrame.load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(frame.stackRoot == <span class="literal">nullptr</span>);</span><br><span class="line">  frame.stackRoot = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;topFrame.store(&amp;frame, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> AsyncStackFrame* AsyncStackRoot::getTopFrame() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> topFrame.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> AsyncStackRoot::setStackFrameContext(</span><br><span class="line">    <span class="keyword">void</span>* framePtr, <span class="keyword">void</span>* ip) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  stackFramePtr = framePtr;</span><br><span class="line">  returnAddress = ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* AsyncStackRoot::getStackFramePointer() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> stackFramePtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* AsyncStackRoot::getReturnAddress() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> returnAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> AsyncStackRoot* AsyncStackRoot::getNextRoot() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> nextRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> AsyncStackRoot::setNextRoot(AsyncStackRoot* next) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  nextRoot = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>parentFrame</code>代表该异步操作的调用者的栈帧，通过<code>parentFrame</code>将调用栈串连起来，调用链通过一个空指针终止，对于<code>paremtFrame</code>为空指针去情况，要么表示该栈帧是被分离的状态（销毁），要么表示下一帧是阻塞等待异步堆栈完成的线程（栈顶？）。</p>
<p><code>instructionPointer</code>表示这个栈帧调用者的指令指针。这通常是此异步操作的延续地址，或启动此异步操作的代码的地址。 如果地址未知，则可能为空。该变量的赋值通常使用<code>FOLLY_ASYNC_STACK_RETURN_ADDRESS()</code>方法。</p>
<p>其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FOLLY_ASYNC_STACK_RETURN_ADDRESS() __builtin_return_address(0)</span><br></pre></td></tr></table></figure>
<p>其中<code>__builtin_return_address</code>可以看<a href="https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html" target="_blank" rel="noopener">__builtin_return_address</a>。</p>
<p>简单来说<code>__builtin_return_address</code>是编译器内建函数，作用是用于获取当前函数或者调用函数的返回地址，当参数是0时，表示的是当前函数的返回地址，参数为1时表示的是调用该函数的函数返回地址。</p>
<p><code>stackRoot</code>是指向当前线程栈根的指针（stack root）。通过这里cache该变量，我们就不需要通过读取一个线程纬度的数据来获取该指针了。该指针只对最顶层的栈帧有效，当一个栈帧被入栈或者出栈时，该值需要被进行拷贝到对应的栈帧上。一个例外是最底层的栈帧，如果最底层的栈帧中该值不为空，则表示指向当前被阻塞在等待一个异步线程完成的根上（指向阻塞当前线程的异步线程的根上）。在这种情况下，您可以在<code>AsyncStackRoot</code>中找到有关该线程的堆栈帧的信息，并可以使用它来继续遍历堆栈帧。</p>
<h2 id="AsyncStackRoot"><a href="#AsyncStackRoot" class="headerlink" title="AsyncStackRoot"></a>AsyncStackRoot</h2><p><code>AsyncStackRoot</code>包含如下内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncStackRoot</span>&#123;</span></span><br><span class="line"><span class="comment">// Pointer to the currently-active AsyncStackFrame for this event</span></span><br><span class="line">  <span class="comment">// loop or callback invocation. May be null if this event loop is</span></span><br><span class="line">  <span class="comment">// not currently executing any async operations.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This is atomic primarily to enforce visibility of writes to the</span></span><br><span class="line">  <span class="comment">// AsyncStackFrame that occur before the topFrame in other processes,</span></span><br><span class="line">  <span class="comment">// such as profilers/debuggers that may be running concurrently</span></span><br><span class="line">  <span class="comment">// with the current thread.</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;AsyncStackFrame*&gt; topFrame&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pointer to the next event loop context lower on the current</span></span><br><span class="line">  <span class="comment">// thread's stack.</span></span><br><span class="line">  <span class="comment">// This is nullptr if this is not a nested call to an event loop.</span></span><br><span class="line">  AsyncStackRoot* nextRoot = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pointer to the stack-frame and return-address of the function</span></span><br><span class="line">  <span class="comment">// call that registered this AsyncStackRoot on the current thread.</span></span><br><span class="line">  <span class="comment">// This is generally the stack-frame responsible for executing async</span></span><br><span class="line">  <span class="comment">// callbacks (typically an event-loop).</span></span><br><span class="line">  <span class="comment">// Anything prior to this frame on the stack in the current thread</span></span><br><span class="line">  <span class="comment">// is potentially unrelated to the call-chain of the current async-stack.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Typically initialised with FOLLY_ASYNC_STACK_FRAME_POINTER() or</span></span><br><span class="line">  <span class="comment">// setStackFrameContext().</span></span><br><span class="line">  <span class="keyword">void</span>* stackFramePtr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Typically initialise with FOLLY_ASYNC_STACK_RETURN_ADDRESS() or</span></span><br><span class="line">  <span class="comment">// setStackFrameContext().</span></span><br><span class="line">  <span class="keyword">void</span>* returnAddress = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topFrame</code>指向事件循环或者回调调用中当前正在执行的栈帧。</p>
<p><code>nextRoot</code>指向当前线程堆栈上下一个事件循环上下文的指针。</p>
<p><code>stackFramePtr</code>指向在当前线程上注册此 <code>AsyncStackRoot</code> 的函数调用的堆栈帧和返回地址的指针。这通常是负责执行异步回调（通常是事件循环）的堆栈框架。初始化该值的典型方法为<code>FOLLY_ASYNC_STACK_FRAME_POINTER()</code>或者<code>setStackFrameContext()</code>。</p>
<p><code>returnAddress</code>，通过<code>FOLLY_ASYNC_STACK_RETURN_ADDRESS()</code>或者<code>setStackFrameContext()</code>初始化。其中<code>FOLLY_ASYNC_STACK_RETURN_ADDRESS</code>方法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLLY_ASYNC_STACK_RETURN_ADDRESS() __builtin_return_address(0)</span></span><br></pre></td></tr></table></figure>
<p>这同样是编译器内建方法，作用是获取调研函数的返回地址。</p>
<h2 id="线程栈与异步栈"><a href="#线程栈与异步栈" class="headerlink" title="线程栈与异步栈"></a>线程栈与异步栈</h2><p><code>AsyncStackRoot</code>和<code>AsyncStackRoot</code>将普通线程栈和异步栈串连起来，其结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//      Current Thread Stack</span><br><span class="line">//      ====================</span><br><span class="line">// +------------------------------------+ &lt;--- current top of stack</span><br><span class="line">// | Normal Stack Frame                 |</span><br><span class="line">// | - stack-base-pointer  ---.         |</span><br><span class="line">// | - return-address         |         |          Thread Local Storage</span><br><span class="line">// |                          |         |          ====================</span><br><span class="line">// +--------------------------V---------+</span><br><span class="line">// |         ...                        |     +-------------------------+</span><br><span class="line">// |                          :         |     | - currentStackRoot  -.  |</span><br><span class="line">// |                          :         |     |                      |  |</span><br><span class="line">// +--------------------------V---------+     +----------------------|--+</span><br><span class="line">// | Normal Stack Frame                 |                            |</span><br><span class="line">// | - stack-base-pointer  ---.         |                            |</span><br><span class="line">// | - return-address         |      .-------------------------------`</span><br><span class="line">// |                          |      |  |</span><br><span class="line">// +--------------------------V------|--+</span><br><span class="line">// | Active Async Operation          |  |</span><br><span class="line">// | (Callback or Coroutine)         |  |            Heap Allocated</span><br><span class="line">// | - stack-base-pointer  ---.      |  |            ==============</span><br><span class="line">// | - return-address         |      |  |</span><br><span class="line">// | - pointer to async state | --------------&gt; +-------------------------+</span><br><span class="line">// |   (e.g. coro frame or    |      |  |       | Coroutine Frame         |</span><br><span class="line">// |    future core)          |      |  |       | +---------------------+ |</span><br><span class="line">// |                          |      |  |       | | Promise             | |</span><br><span class="line">// +--------------------------V------|--+       | | +-----------------+ | |</span><br><span class="line">// |   Event  / Callback             |  |   .------&gt;| AsyncStackFrame | | |</span><br><span class="line">// |   Loop     Callsite             |  |   |   | | | - parentFrame  --------.</span><br><span class="line">// | - stack-base-pointer  ---.      |  |   |   | | | - instructionPtr| | |  |</span><br><span class="line">// | - return-address         |      |  |   |   | | | - stackRoot -.  | | |  |</span><br><span class="line">// |                          |      |  |   |   | | +--------------|--+ | |  |</span><br><span class="line">// |  +--------------------+  |      |  |   |   | | ...            |    | |  |</span><br><span class="line">// |  | AsyncStackRoot     |&lt;--------`  |   |   | +----------------|----+ |  |</span><br><span class="line">// |  | - topFrame   -----------------------`   | ...              |      |  |</span><br><span class="line">// |  | - stackFramePtr -. |&lt;---------------,   +------------------|------+  |</span><br><span class="line">// |  | - nextRoot --.   | |  |         |   |                      |         |</span><br><span class="line">// |  +--------------|---|-+  |         |   &apos;----------------------`         |</span><br><span class="line">// +-----------------|---V----V---------+       +-------------------------+  |</span><br><span class="line">// |         ...     |                  |       | Coroutine Frame         |  |</span><br><span class="line">// |                 |        :         |       |                         |  |</span><br><span class="line">// |                 |        :         |       |  +-------------------+  |  |</span><br><span class="line">// +-----------------|--------V---------+       |  | AsyncStackFrame   |&lt;----`</span><br><span class="line">// | Async Operation |                  |       |  | - parentFrame   --------.</span><br><span class="line">// | (Callback/Coro) |                  |       |  | - instructionPtr  |  |  |</span><br><span class="line">// |                 |        :         |       |  | - stackRoot       |  |  |</span><br><span class="line">// |                 |        :         |       |  +-------------------+  |  |</span><br><span class="line">// +-----------------|--------V---------+       +-------------------------+  |</span><br><span class="line">// |  Event Loop /   |                  |                                    :</span><br><span class="line">// |  Callback Call  |                  |                                    :</span><br><span class="line">// | - frame-pointer | -------.         |                                    V</span><br><span class="line">// | - return-address|        |         |</span><br><span class="line">// |                 |        |         |      Another chain of potentially</span><br><span class="line">// |  +--------------V-----+  |         |      unrelated AsyncStackFrame</span><br><span class="line">// |  | AsyncStackRoot     |  |         |       +---------------------+</span><br><span class="line">// |  | - topFrame  ---------------- - - - - &gt;  | AsyncStackFrame     |</span><br><span class="line">// |  | - stackFramePtr -. |  |         |       | - parentFrame -.    |</span><br><span class="line">// |  | - nextRoot -.    | |  |         |       +----------------|----+</span><br><span class="line">// |  +-------------|----|-+  |         |                        :</span><br><span class="line">// |                |    |    |         |                        V</span><br><span class="line">// +----------------|----V----V---------+</span><br><span class="line">// |         ...    :                   |</span><br><span class="line">// |                V                   |</span><br><span class="line">// |                                    |</span><br><span class="line">// +------------------------------------+</span><br><span class="line">//</span><br></pre></td></tr></table></figure>
<p><code>AsyncStackFrame</code>和<code>AsyncStackRoot</code>用来串连协程调用的堆栈，使得其与线程调用栈类似。每个协程存在一个<code>AsyncStackFrame</code>，协程之间通过<code>AsyncStackFrame.parentFrame</code>串连起来。每个线程存在一个<code>currentThreadAsyncStackRoot</code>，其存储一个<code>AsyncStackRoot</code>。<code>AsyncStackRoot</code>的<code>topFrame</code>执行当前正在执行的协程栈帧。维护这些调用关系是方便进行debug。</p>
<p>对这些字段的维护设计如下函数：</p>
<h3 id="pushAsyncStackFrameCallerCallee"><a href="#pushAsyncStackFrameCallerCallee" class="headerlink" title="pushAsyncStackFrameCallerCallee"></a><code>pushAsyncStackFrameCallerCallee</code></h3><p>该函数在一个协程调用另一个协程时执行，构建调用者和被调者的关系，并且维护<code>stackRoot</code>指针（指向线程的<code>AsyncStackRoot</code>）。</p>
<p>其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">callerFrame: 调用者栈帧</span></span><br><span class="line"><span class="comment">calleeFrame: 被调者栈帧</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushAsyncStackFrameCallerCallee</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::AsyncStackFrame&amp; callerFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::AsyncStackFrame&amp; calleeFrame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  checkAsyncStackFrameIsActive(callerFrame);</span><br><span class="line">  <span class="comment">// 栈顶栈帧持有指向AsyncStackRoot的指针</span></span><br><span class="line">  calleeFrame.stackRoot = callerFrame.stackRoot;</span><br><span class="line">  <span class="comment">// 被调者parentFrame指向调用者，构建调用链</span></span><br><span class="line">  calleeFrame.parentFrame = &amp;callerFrame;</span><br><span class="line">  <span class="comment">// 设置当前线程执行的协程栈</span></span><br><span class="line">  calleeFrame.stackRoot-&gt;topFrame.store(</span><br><span class="line">      &amp;calleeFrame, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clearing out non-top-frame's stackRoot is not strictly necessary</span></span><br><span class="line">  <span class="comment">// but it may help with debugging.</span></span><br><span class="line">  callerFrame.stackRoot = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="popAsyncStackFrameCallee"><a href="#popAsyncStackFrameCallee" class="headerlink" title="popAsyncStackFrameCallee"></a><code>popAsyncStackFrameCallee</code></h3><p>该函数用于调用完成了某个协程后，将协程栈从链表中删除，其逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calleeFrame表示被调的协程栈</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">popAsyncStackFrameCallee</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::AsyncStackFrame&amp; calleeFrame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  checkAsyncStackFrameIsActive(calleeFrame);</span><br><span class="line">  <span class="comment">// 获取调用者的协程栈</span></span><br><span class="line">  <span class="keyword">auto</span>* callerFrame = calleeFrame.parentFrame;</span><br><span class="line">  <span class="comment">// 获取当前线程的AsyncStackRoot</span></span><br><span class="line">  <span class="keyword">auto</span>* stackRoot = calleeFrame.stackRoot;</span><br><span class="line">  <span class="comment">// 如果存在调用者，则线程的AsyncStackRoot交由其持有。</span></span><br><span class="line">  <span class="keyword">if</span> (callerFrame != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    callerFrame-&gt;stackRoot = stackRoot;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置当前线程的栈顶为调用者栈帧</span></span><br><span class="line">  stackRoot-&gt;topFrame.store(callerFrame, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clearing out non-top-frame's stackRoot is not strictly necessary</span></span><br><span class="line">  <span class="comment">// but it may help with debugging.</span></span><br><span class="line">  calleeFrame.stackRoot = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ScopedAsyncStackRoot"><a href="#ScopedAsyncStackRoot" class="headerlink" title="ScopedAsyncStackRoot"></a><code>ScopedAsyncStackRoot</code></h3><p><code>ScopedAsyncStackRoot</code>不是一个函数，而是一个类，其用来维护线程的<code>AsyncStackRoot</code>。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedAsyncStackRoot</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ScopedAsyncStackRoot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">void</span>* framePointer = FOLLY_ASYNC_STACK_FRAME_POINTER(),</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">void</span>* returnAddress = FOLLY_ASYNC_STACK_RETURN_ADDRESS())</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  ~ScopedAsyncStackRoot();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">activateFrame</span><span class="params">(AsyncStackFrame&amp; frame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    folly::activateAsyncStackFrame(root_, frame);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  AsyncStackRoot root_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的<code>framePointer</code>与<code>returnAddress</code>都是之前提到的编译器函数对其赋值。其构造函数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> AsyncStackRootHolder currentThreadAsyncStackRoot;</span><br><span class="line"></span><br><span class="line">ScopedAsyncStackRoot::ScopedAsyncStackRoot(</span><br><span class="line">    <span class="keyword">void</span>* framePointer, <span class="keyword">void</span>* returnAddress) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  root_.setStackFrameContext(framePointer, returnAddress);</span><br><span class="line">  root_.nextRoot = currentThreadAsyncStackRoot.get();</span><br><span class="line">  currentThreadAsyncStackRoot.<span class="built_in">set</span>(&amp;root_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先初始化一个<code>AsyncStackRoot</code>，之后挺好当前线程的<code>AsyncStackRoot</code>为新建的<code>root</code>。析构函数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScopedAsyncStackRoot::~ScopedAsyncStackRoot() &#123;</span><br><span class="line">  assert(currentThreadAsyncStackRoot.get() == &amp;root_);</span><br><span class="line">  assert(root_.topFrame.load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="literal">nullptr</span>);</span><br><span class="line">  currentThreadAsyncStackRoot.set_relaxed(root_.nextRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在析构函数中还原会原来线程的<code>AsyncStackRoot</code>。</p>
<p>成员函数<code>activateFrame</code>方法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">activateAsyncStackFrame</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::AsyncStackRoot&amp; root, folly::AsyncStackFrame&amp; frame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  assert(tryGetCurrentAsyncStackRoot() == &amp;root);</span><br><span class="line">  root.setTopFrame(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置当前<code>root</code>的栈顶帧。</p>
<p>该类是在一个线程上新起一个协程方法时被调用，folly中目前主要是<code>resumeCoroutineWithNewAsyncStackRoot</code>方法使用，其实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FOLLY_NOINLINE <span class="keyword">void</span> <span class="title">resumeCoroutineWithNewAsyncStackRoot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    coro::coroutine_handle&lt;&gt; h, folly::AsyncStackFrame&amp; frame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  detail::ScopedAsyncStackRoot root;</span><br><span class="line">  root.activateFrame(frame);</span><br><span class="line">  h.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的意思是使用一个新的<code>AsyncStackRoot</code>来恢复执行一个协程。并且该协程与当前线程中的协程栈没有关系，因此需要维护一个新的<code>AsyncStackRoot</code>，在该协程调用完成之后，再恢复原来的<code>AsyncStackRoot</code>。</p>
<h2 id="CancellationToken"><a href="#CancellationToken" class="headerlink" title="CancellationToken"></a>CancellationToken</h2><p><code>CancellationToken</code>用于向函数或者操作进行信息传递，用于取消操作。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A CancellationToken is an object that can be passed into an function or</span></span><br><span class="line"><span class="comment">// operation that allows the caller to later request that the operation be</span></span><br><span class="line"><span class="comment">// cancelled.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A CancellationToken object can be obtained by calling the .getToken()</span></span><br><span class="line"><span class="comment">// method on a CancellationSource or by copying another CancellationToken</span></span><br><span class="line"><span class="comment">// object. All CancellationToken objects obtained from the same original</span></span><br><span class="line"><span class="comment">// CancellationSource object all reference the same underlying cancellation</span></span><br><span class="line"><span class="comment">// state and will all be cancelled together.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If your function needs to be cancellable but does not need to request</span></span><br><span class="line"><span class="comment">// cancellation then you should take a CancellationToken as a parameter.</span></span><br><span class="line"><span class="comment">// If your function needs to be able to request cancellation then you</span></span><br><span class="line"><span class="comment">// should instead take a CancellationSource as a parameter.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancellationToken</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructs to a token that can never be cancelled.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Pass a default-constructed CancellationToken into an operation that</span></span><br><span class="line">  <span class="comment">// you never intend to cancel. These objects are very cheap to create.</span></span><br><span class="line">  CancellationToken() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct a copy of the token that shares the same underlying state.</span></span><br><span class="line">  CancellationToken(<span class="keyword">const</span> CancellationToken&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line">  CancellationToken(CancellationToken&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">  CancellationToken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CancellationToken&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line">  CancellationToken&amp; <span class="keyword">operator</span>=(CancellationToken&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Query whether someone has called .requestCancellation() on an instance</span></span><br><span class="line">  <span class="comment">// of CancellationSource object associated with this CancellationToken.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isCancellationRequested</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Query whether this CancellationToken can ever have cancellation requested</span></span><br><span class="line">  <span class="comment">// on it.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This will return false if the CancellationToken is not associated with a</span></span><br><span class="line">  <span class="comment">// CancellationSource object. eg. because the CancellationToken was</span></span><br><span class="line">  <span class="comment">// default-constructed, has been moved-from or because the last</span></span><br><span class="line">  <span class="comment">// CancellationSource object associated with the underlying cancellation state</span></span><br><span class="line">  <span class="comment">// has been destroyed and the operation has not yet been cancelled and so</span></span><br><span class="line">  <span class="comment">// never will be.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Implementations of operations may be able to take more efficient code-paths</span></span><br><span class="line">  <span class="comment">// if they know they can never be cancelled.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">canBeCancelled</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Obtain a CancellationToken linked to any number of other</span></span><br><span class="line">  <span class="comment">// CancellationTokens.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This token will have cancellation requested when any of the passed-in</span></span><br><span class="line">  <span class="comment">// tokens do.</span></span><br><span class="line">  <span class="comment">// This token is cancellable if any of the passed-in tokens are at the time of</span></span><br><span class="line">  <span class="comment">// construction.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> CancellationToken <span class="title">merge</span><span class="params">(Ts&amp;&amp;... tokens)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(CancellationToken&amp; other)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(</span><br><span class="line">      <span class="keyword">const</span> CancellationToken&amp; a, <span class="keyword">const</span> CancellationToken&amp; b) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellationCallback</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellationSource</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">CancellationToken</span><span class="params">(detail::CancellationStateTokenPtr state)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  detail::CancellationStateTokenPtr state_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其需要配合<code>CancellationSource</code>使用。这里不展开介绍，核心是<code>CancellationSource</code>负责管理<code>cancel</code>逻辑,其存在<code>requestCancellation</code>和<code>getToken</code>两个核心接口。其中<code>requestCancellation</code>用于设置取消逻辑（<code>CancellationToken</code>不能设置取消，只能判断是否被取消），<code>getToken</code>用于生成<code>CancellationToken</code>。所以通过同一个<code>CancellationSource</code>生成的<code>CancellationToken</code>被统一管理，当<code>CancellationSource</code>被设置cancel状态时，所以的<code>CancellationToken</code>都被置为cancel状态。</p>
<p>其中存在<code>merge</code>接口，其输入是多个<code>CancellationToken</code>，并生成一个新的<code>CancellationToken</code>。这里的逻辑是，聚合多个<code>CancellationToken</code>，有应该被置为cancel状态时，新的这个cancel就会被置为cancel状态。其内部实现是新建了一个<code>CancellationSource</code>，将其与参数中的<code>CancellationToken</code>对应的<code>CancellationSource</code>绑定，并设置回调函数。</p>
<p>介绍完了成员变量的类型，我们再来看对应使用该类作为<code>promise_type</code>的协程来说，其执行逻辑。</p>
<h2 id="分配Coroutine-state"><a href="#分配Coroutine-state" class="headerlink" title="分配Coroutine state"></a>分配<code>Coroutine state</code></h2><p><code>TaskPromiseBase</code>自定义了分配<code>Coroutine state</code>的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::folly_coro_async_malloc(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    ::folly_coro_async_free(ptr, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">FOLLY_NOINLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">folly_coro_async_malloc</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> p = folly::operator_new(size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add this after the call to prevent the compiler from</span></span><br><span class="line">  <span class="comment">// turning the call to operator new() into a tailcall.</span></span><br><span class="line">  folly::compiler_must_not_elide(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FOLLY_NOINLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">folly_coro_async_free</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  folly::operator_delete(ptr, size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add this after the call to prevent the compiler from</span></span><br><span class="line">  <span class="comment">// turning the call to operator delete() into a tailcall.</span></span><br><span class="line">  folly::compiler_must_not_elide(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compiler_must_not_elide_fn</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">FOLLY_ALWAYS_INLINE <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="keyword">const</span>&amp; t)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">FOLLY_INLINE_VARIABLE <span class="keyword">constexpr</span> compiler_must_not_elide_fn</span><br><span class="line">    compiler_must_not_elide&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">FOLLY_ALWAYS_INLINE <span class="keyword">void</span> compiler_must_not_elide_fn::<span class="keyword">operator</span>()(</span><br><span class="line">    T <span class="keyword">const</span>&amp; t) <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> i = detail::compiler_must_force_indirect&lt;T&gt;;</span><br><span class="line">  detail::compiler_must_not_elide(t, i&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">FOLLY_ALWAYS_INLINE <span class="keyword">void</span> <span class="title">compiler_must_not_elide</span><span class="params">(T <span class="keyword">const</span>&amp; t, <span class="built_in">std</span>::false_type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// the "r" constraint forces the compiler to make the value available in a</span></span><br><span class="line">  <span class="comment">// register to the asm block, which means that it must first have been</span></span><br><span class="line">  <span class="comment">// computed or loaded</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// used for small trivial values which the compiler will put into registers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// avoided for pointers to avoid fallout in calling code which mistakenly</span></span><br><span class="line">  <span class="comment">// applies the hint to the address of a value but not to the value itself</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">""</span> : : <span class="string">"r"</span>(t))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">FOLLY_ALWAYS_INLINE <span class="keyword">void</span> <span class="title">compiler_must_not_elide</span><span class="params">(T <span class="keyword">const</span>&amp; t, <span class="built_in">std</span>::true_type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tells the compiler that the asm block will read the value from memory,</span></span><br><span class="line">  <span class="comment">// and that in addition it might read or write from any memory location</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// if the memory clobber could be split into input and output, that would be</span></span><br><span class="line">  <span class="comment">// preferrable</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">""</span> : : <span class="string">"m"</span>(t) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其<code>new</code>使用的是<code>__builtin_operator_new</code>。<code>delete</code>使用的是<code>__builtin_operator_delete</code>。这里后面的函数主要作用是进行尾调用优化。具体可以参数<a href="https://zh.wikipedia.org/zh-hans/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">尾调用</a>。</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p><code>TaskPromiseBase</code>被默认构造。之后会获取函数返回值，这里不是在<code>TaskPromiseBase</code>中实现，而是在其派生类中实现，这里不做介绍。</p>
<p>当创建完成返回值后，会执行<code>initial_suspend</code>判断，来决定是否可以立即执行协程。其实现为懒加载，即始终不会立即执行。：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="co-await时获取awaitable和awaiter"><a href="#co-await时获取awaitable和awaiter" class="headerlink" title="co_await时获取awaitable和awaiter"></a><code>co_await</code>时获取<code>awaitable</code>和<code>awaiter</code></h2><p>当协程内执行<code>co_await</code>时，会调用<code>await_transform</code>方法，这里实现了一系列的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(Awaitable&amp;&amp; awaitable)</span> </span>&#123;</span><br><span class="line">    bypassExceptionThrowing_ =</span><br><span class="line">        bypassExceptionThrowing_ == BypassExceptionThrowing::REQUESTED</span><br><span class="line">        ? BypassExceptionThrowing::ACTIVE</span><br><span class="line">        : BypassExceptionThrowing::INACTIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> folly::coro::co_withAsyncStack(folly::coro::co_viaIfAsync(</span><br><span class="line">        executor_.get_alias(),</span><br><span class="line">        folly::coro::co_withCancellation(</span><br><span class="line">            cancelToken_, <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(NothrowAwaitable&lt;Awaitable&gt;&amp;&amp; awaitable)</span> </span>&#123;</span><br><span class="line">    bypassExceptionThrowing_ = BypassExceptionThrowing::REQUESTED;</span><br><span class="line">    <span class="keyword">return</span> await_transform(awaitable.unwrap());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只针对co_current_executor_t，后面会介绍，获取协程的executor_，不会被挂起</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(<span class="keyword">co_current_executor_t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ready_awaitable&lt;folly::Executor*&gt;&#123;executor_.get()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只针对co_current_cancellation_token_t，后面会介绍，获取协程的cancelToken_，不会被挂起</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(<span class="keyword">co_current_cancellation_token_t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ready_awaitable&lt;<span class="keyword">const</span> folly::CancellationToken&amp;&gt;&#123;cancelToken_&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其核心是第一个函数，即实际调用的是<code>folly::coro::co_withAsyncStack</code>和<code>co_viaIfAsync</code>以及<code>co_withCancellation</code>方法。</p>
<p>对于<code>Task</code>来说，这几个方法都重写了，这里看一下这几个函数的默认方法。</p>
<h3 id="co-withCancellation"><a href="#co-withCancellation" class="headerlink" title="co_withCancellation"></a>co_withCancellation</h3><p>其方法核心是将cancel与协程任务绑定，对于Task相关结构来说，其绑定是没有问题的，但是默认情况下不清楚awaitable类型没办法绑定，因此默认的改函数实现是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FOLLY_DEFINE_CPO(detail::adl::WithCancellationFunction, co_withCancellation)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WithCancellationFunction</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> folly::CancellationToken&amp; cancelToken, Awaitable&amp;&amp; awaitable)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">      <span class="title">noexcept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">noexcept</span>(co_withCancellation(cancelToken, (Awaitable &amp;&amp;) awaitable)))</span></span></span><br><span class="line">          -&gt; decltype(co_withCancellation(</span><br><span class="line">              cancelToken, (Awaitable &amp;&amp;) awaitable)) &#123;</span><br><span class="line">    <span class="keyword">return</span> co_withCancellation(cancelToken, (Awaitable &amp;&amp;) awaitable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(folly::CancellationToken&amp;&amp; cancelToken, Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(co_withCancellation(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="built_in">std</span>::move(cancelToken), (Awaitable &amp;&amp;) awaitable)))</span></span></span><br><span class="line">          -&gt; decltype(co_withCancellation(</span><br><span class="line">              <span class="built_in">std</span>::move(cancelToken), (Awaitable &amp;&amp;) awaitable)) &#123;</span><br><span class="line">    <span class="keyword">return</span> co_withCancellation(</span><br><span class="line">        <span class="built_in">std</span>::move(cancelToken), (Awaitable &amp;&amp;) awaitable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line"><span class="function">Awaitable&amp;&amp; <span class="title">co_withCancellation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> folly::CancellationToken&amp;, Awaitable&amp;&amp; awaitable)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Awaitable &amp;&amp;) awaitable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即默认情况下直接返回<code>awaitable</code>。</p>
<p>这里，<code>task</code>，<code>TaskWithExecutor</code>有实现该方法（后面会介绍该类），其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> Task <span class="title">co_withCancellation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::CancellationToken cancelToken, Task&amp;&amp; task)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  DCHECK(task.coro_);</span><br><span class="line">  task.coro_.promise().setCancelToken(<span class="built_in">std</span>::move(cancelToken));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> TaskWithExecutor <span class="title">co_withCancellation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::CancellationToken cancelToken, TaskWithExecutor&amp;&amp; task)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  DCHECK(task.coro_);</span><br><span class="line">  task.coro_.promise().setCancelToken(<span class="built_in">std</span>::move(cancelToken));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里是直接将cancel与协程的promise绑定。</p>
<h3 id="co-viaIfAsync"><a href="#co-viaIfAsync" class="headerlink" title="co_viaIfAsync"></a>co_viaIfAsync</h3><p><code>co_viaIfAsync</code>的作用是保证调用者协程能够始终在指定的<code>executor</code>(线程池)中执行。</p>
<p>其具体实现是对协程再通过框架封装一层框架定义的协程，在框架定义的这一层来实现当前协程被<code>suspend</code>后和在其恢复时依然在原线程池上执行。其实现较为复杂，可以先阅读后面部分，对<code>coro</code>协程有整体了解后再回来看其具体实现。</p>
<p>使用一个简单例子来进行描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="keyword">void</span>&gt; funca() &#123;</span><br><span class="line">	co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;<span class="keyword">void</span>&gt; funcb() &#123;</span><br><span class="line">  xxx;</span><br><span class="line">  co_await funca().scheduleOn(executor1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  folly::coro::blockingWait(b().scheduleOn(exectutor2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的伪代码中，我们希望<code>funcb</code>在线程池<code>exectutor2</code>中执行，但是希望<code>funca</code>在线程池<code>executor1</code>中执行。在执行<code>funcb</code>时，当其被挂起后，执行<code>funca</code>，由于<code>funca</code>被指定在线程池<code>executor1</code>中执行，当<code>funca</code>执行完成后，恢复<code>funcb</code>的执行时，如果没有<code>co_viaIfAsync</code>的协助，<code>funcb</code>剩下的部分也将直接在<code>executor1</code>中被执行，通过<code>co_viaIfAsync</code>，可以保证<code>funcb</code>均在指定线程池中执行。</p>
<p>下面我们来详细了解其实现逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">FOLLY_DEFINE_CPO(detail::adl::ViaIfAsyncFunction, co_viaIfAsync)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLLY_DEFINE_CPO(Type, Name) \</span></span><br><span class="line">  <span class="keyword">namespace</span> folly_cpo__ &#123;            \</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">constexpr</span> Type Name&#123;&#125;;      \</span><br><span class="line">  &#125;                                  \</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> folly_cpo__;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViaIfAsyncFunction</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(folly::Executor::KeepAlive&lt;&gt; executor, Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">const</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(co_viaIfAsync(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="built_in">std</span>::move(executor), <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable))))</span></span></span><br><span class="line">          -&gt; decltype(co_viaIfAsync(</span><br><span class="line">              <span class="built_in">std</span>::move(executor), <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable))) &#123;</span><br><span class="line">    <span class="keyword">return</span> co_viaIfAsync(</span><br><span class="line">        <span class="built_in">std</span>::move(executor), <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">co_viaIfAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::Executor::KeepAlive&lt;&gt; executor,</span></span></span><br><span class="line"><span class="function"><span class="params">    SemiAwaitable&amp;&amp;</span></span></span><br><span class="line"><span class="function"><span class="params">        awaitable)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(<span class="keyword">static_cast</span>&lt;SemiAwaitable&amp;&amp;&gt;(awaitable)</span></span></span><br><span class="line"><span class="function"><span class="params">                                         .viaIfAsync(<span class="built_in">std</span>::move(executor))))</span></span></span><br><span class="line">    -&gt; decltype(static_cast&lt;SemiAwaitable&amp;&amp;&gt;(awaitable).viaIfAsync(</span><br><span class="line">        <span class="built_in">std</span>::move(executor))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;SemiAwaitable&amp;&amp;&gt;(awaitable).viaIfAsync(</span><br><span class="line">      <span class="built_in">std</span>::move(executor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> Awaitable,</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">        is_awaitable_v&lt;Awaitable&gt; &amp;&amp; !HasViaIfAsyncMethod&lt;Awaitable&gt;::value,</span><br><span class="line">        <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> co_viaIfAsync(folly::Executor::KeepAlive&lt;&gt; executor, Awaitable&amp;&amp; awaitable)</span><br><span class="line">    -&gt; ViaIfAsyncAwaitable&lt;Awaitable&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> ViaIfAsyncAwaitable&lt;Awaitable&gt;&#123;</span><br><span class="line">      <span class="built_in">std</span>::move(executor), <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户实现了自己的<code>co_viaIfAsync</code>方法则优先调用用户自己的方法。之后如果用户实现了<code>awaitable</code>的<code>viaIfAsync</code>方法，则会调用该方法，否则，调用<code>ViaIfAsyncAwaitable</code>。下面主要看<code>ViaIfAsyncAwaitable</code>的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViaIfAsyncAwaitable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ViaIfAsyncAwaitable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::Executor::KeepAlive&lt;&gt; executor,</span></span></span><br><span class="line"><span class="function"><span class="params">      Awaitable&amp;&amp;</span></span></span><br><span class="line"><span class="function"><span class="params">          awaitable)</span> <span class="title">noexcept</span><span class="params">(<span class="built_in">std</span>::is_nothrow_move_constructible&lt;Awaitable&gt;::</span></span></span><br><span class="line"><span class="function"><span class="params">                                  value)</span></span></span><br><span class="line">      : executor_(std::move(executor)),</span><br><span class="line">        awaitable_(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ViaIfAsyncAwaiter&lt;<span class="literal">false</span>, Awaitable&gt; <span class="function"><span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> &amp;&amp; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ViaIfAsyncAwaiter&lt;<span class="literal">false</span>, Awaitable&gt;&#123;</span><br><span class="line">        <span class="built_in">std</span>::move(executor_), <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable_)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> StackAwareViaIfAsyncAwaitable&lt;Awaitable&gt; tag_invoke(</span><br><span class="line">      <span class="keyword">cpo_t</span>&lt;co_withAsyncStack&gt;, ViaIfAsyncAwaitable&amp;&amp; self) &#123;</span><br><span class="line">    <span class="keyword">return</span> StackAwareViaIfAsyncAwaitable&lt;Awaitable&gt;&#123;</span><br><span class="line">        <span class="built_in">std</span>::move(self.executor_), <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(self.awaitable_)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  folly::Executor::KeepAlive&lt;&gt; executor_;</span><br><span class="line">  Awaitable awaitable_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当用户直接<code>co_await folly::coro::co_viaIfAsync(executor_.get_alias(),awaitable)</code>时，实际执行的就变成了<code>co_await ViaIfAsyncAwaitable</code>了（这里假设协程的<code>promise_type</code>没有<code>await_transform</code>方法，这个逻辑一般是直接在<code>await_transform</code>中返回<code>ViaIfAsyncAwaitable</code>）。之后通过<code>ViaIfAsyncAwaitable::co_await</code>方法获取<code>awaiter</code>，该方法只创建一个<code>ViaIfAsyncAwaiter</code>。<code>ViaIfAsyncAwaiter</code>即为这里实际的<code>awaiter</code>。</p>
<p>下面看一下<code>ViaIfAsyncAwaiter</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> IsCallerAsyncStackAware, <span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViaIfAsyncAwaiter</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> Awaiter = folly::coro::<span class="keyword">awaiter_type_t</span>&lt;Awaitable&gt;;</span><br><span class="line">  <span class="keyword">using</span> CoroutineType = detail::ViaCoroutine&lt;<span class="literal">false</span>&gt;;</span><br><span class="line">  <span class="keyword">using</span> CoroutinePromise = <span class="keyword">typename</span> CoroutineType::promise_type;</span><br><span class="line">  <span class="keyword">using</span> WrapperHandle = coroutine_handle&lt;CoroutinePromise&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">await_suspend_result_t</span> =</span><br><span class="line">      <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;Awaiter&amp;&gt;().await_suspend(</span><br><span class="line">          <span class="built_in">std</span>::declval&lt;WrapperHandle&gt;()));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ViaIfAsyncAwaiter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::Executor::KeepAlive&lt;&gt; executor, Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line">      : viaCoroutine_(CoroutineType::create(std::move(executor))),</span><br><span class="line">        awaiter_(</span><br><span class="line">            folly::coro::get_awaiter(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable))) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  CoroutineType viaCoroutine_;</span><br><span class="line">  Awaiter awaiter_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在创建<code>ViaIfAsyncAwaiter</code>时会调用<code>CoroutineType::create(std::move(executor))</code>方法和<code>folly::coro::get_awaiter(static_cast&lt;Awaitable&amp;&amp;&gt;(awaitable))</code>方法。其中第一个方法的实现为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ViaCoroutine <span class="title">createImpl</span><span class="params">()</span> </span>&#123; co_return; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ViaCoroutine <span class="title">create</span><span class="params">(folly::Executor::KeepAlive&lt;&gt; executor)</span> </span>&#123;</span><br><span class="line">  ViaCoroutine coroutine = createImpl();</span><br><span class="line">  coroutine.setExecutor(<span class="built_in">std</span>::move(executor));</span><br><span class="line">  <span class="keyword">return</span> coroutine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在执行第一个方法的时候，调用的是一个空的协程，这里就完成了对原来协程的一层封装，相当于在原协程上又封装了一层协程。该协程对应的<code>ViaCoroutine</code>结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViaCoroutinePromiseBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::folly_coro_async_malloc(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    ::folly_coro_async_free(ptr, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  [[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    folly::assume_unreachable();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(folly::Executor::KeepAlive&lt;&gt; executor)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    executor_ = <span class="built_in">std</span>::move(executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setContinuation</span><span class="params">(ExtendedCoroutineHandle continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    continuation_ = continuation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setAsyncFrame</span><span class="params">(folly::AsyncStackFrame&amp; frame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    asyncFrame_ = &amp;frame;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setRequestContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;folly::RequestContext&gt; context)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    context_ = <span class="built_in">std</span>::move(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">scheduleContinuation</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Pass the coroutine's RequestContext to Executor::add(), in case the</span></span><br><span class="line">    <span class="comment">// Executor implementation wants to know what runs on it (e.g. for stats).</span></span><br><span class="line">    RequestContextScopeGuard contextScope&#123;context_&#125;;</span><br><span class="line"></span><br><span class="line">    executor_-&gt;add([<span class="keyword">this</span>]() <span class="keyword">noexcept</span> &#123; <span class="keyword">this</span>-&gt;executeContinuation(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">executeContinuation</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    RequestContextScopeGuard contextScope&#123;<span class="built_in">std</span>::move(context_)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (asyncFrame_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      folly::resumeCoroutineWithNewAsyncStackRoot(</span><br><span class="line">          continuation_.getHandle(), *asyncFrame_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      continuation_.resume();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ViaCoroutinePromiseBase() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  folly::Executor::KeepAlive&lt;&gt; executor_;</span><br><span class="line">  ExtendedCoroutineHandle continuation_;</span><br><span class="line">  folly::AsyncStackFrame* asyncFrame_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;RequestContext&gt; context_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> IsStackAware&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViaCoroutine</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">promise_type</span> <span class="title">final</span> :</span> <span class="keyword">public</span> ViaCoroutinePromiseBase,</span><br><span class="line">                             <span class="keyword">public</span> ExtendedCoroutinePromiseImpl&lt;promise_type&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FinalAwaiter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">FinalAwaiter <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">bool</span> IsStackAware2 = IsStackAware,</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;IsStackAware2, <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">    folly::AsyncStackFrame&amp; getAsyncFrame() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">      DCHECK(<span class="keyword">this</span>-&gt;asyncFrame_ != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;asyncFrame_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;ExtendedCoroutineHandle, AsyncStackFrame*&gt; getErrorHandle(</span><br><span class="line">        exception_wrapper&amp; ex) override &#123;</span><br><span class="line">      <span class="keyword">auto</span> [handle, frame] = continuation_.getErrorHandle(ex);</span><br><span class="line">      setContinuation(handle);</span><br><span class="line">      <span class="keyword">if</span> (frame &amp;&amp; IsStackAware) &#123;</span><br><span class="line">        asyncFrame_ = frame;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;promise_type::getHandle(), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ViaCoroutine(ViaCoroutine&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">      : coro_(<span class="built_in">std</span>::exchange(other.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~ViaCoroutine() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">      coro_.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> ViaCoroutine <span class="title">create</span><span class="params">(folly::Executor::KeepAlive&lt;&gt; executor)</span> </span>&#123;</span><br><span class="line">    ViaCoroutine coroutine = createImpl();</span><br><span class="line">    coroutine.setExecutor(<span class="built_in">std</span>::move(executor));</span><br><span class="line">    <span class="keyword">return</span> coroutine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(folly::Executor::KeepAlive&lt;&gt; executor)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    coro_.promise().setExecutor(<span class="built_in">std</span>::move(executor));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setContinuation</span><span class="params">(ExtendedCoroutineHandle continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    coro_.promise().setContinuation(continuation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setAsyncFrame</span><span class="params">(folly::AsyncStackFrame&amp; frame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    coro_.promise().setAsyncFrame(frame);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">      <span class="built_in">std</span>::exchange(coro_, &#123;&#125;).destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">saveContext</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    coro_.promise().setRequestContext(folly::RequestContext::saveContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  coroutine_handle&lt;promise_type&gt; getHandle() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> coro_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ViaCoroutine</span><span class="params">(coroutine_handle&lt;promise_type&gt; coro)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">      : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> ViaCoroutine <span class="title">createImpl</span><span class="params">()</span> </span>&#123; co_return; &#125;</span><br><span class="line"></span><br><span class="line">  coroutine_handle&lt;promise_type&gt; coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当创建<code>ViaIfAsyncAwaiter</code>时，首先会创建<code>ViaCoroutine::promise_type</code>。之后调用<code>ViaCoroutine::promise_type::get_return_object</code>方法创建<code>ViaCoroutine</code>(这时拿到当前协程的<code>coroutine_handle</code>)。之后挂起。</p>
<p>可以看到创建<code>ViaIfAsyncAwaiter</code>会起一个新的协程，并且<code>suspend</code>在对<code>viaCoroutine_</code>的赋值上。</p>
<p>创建<code>ViaIfAsyncAwaiter</code>的第二个函数执行逻辑为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> Awaitable,</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">        folly::Conjunction&lt;</span><br><span class="line">            is_awaiter&lt;Awaitable&gt;,</span><br><span class="line">            folly::Negation&lt;detail::_has_free_operator_co_await&lt;Awaitable&gt;&gt;,</span><br><span class="line">            folly::Negation&lt;detail::_has_member_operator_co_await&lt;Awaitable&gt;&gt;&gt;::</span><br><span class="line">            value,</span><br><span class="line">        <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">Awaitable&amp; get_awaiter(Awaitable&amp;&amp; awaitable) &#123;</span><br><span class="line">  <span class="keyword">return</span> awaitable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> Awaitable,</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">        detail::_has_member_operator_co_await&lt;Awaitable&gt;::value,</span><br><span class="line">        <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) get_awaiter(Awaitable&amp;&amp; awaitable) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable).<span class="keyword">operator</span> co_await();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> Awaitable,</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">        folly::Conjunction&lt;</span><br><span class="line">            detail::_has_free_operator_co_await&lt;Awaitable&gt;,</span><br><span class="line">            folly::Negation&lt;detail::_has_member_operator_co_await&lt;Awaitable&gt;&gt;&gt;::</span><br><span class="line">            value,</span><br><span class="line">        <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) get_awaiter(Awaitable&amp;&amp; awaitable) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">operator</span> co_await(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是根据<code>Awaitable</code>获取到<code>awaiter</code>，其实现与协程实现一致，根据是否存在<code>co_await</code>函数来决定执行逻辑。</p>
<p>到此，完成了<code>ViaIfAsyncAwaiter</code>的创建于获取。只会执行<code>co_await</code>对<code>awaiter</code>的操作。</p>
<p>首先执行<code>await_ready</code>函数，其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) await_ready() <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>(awaiter_.await_ready())) &#123;</span><br><span class="line">    <span class="keyword">return</span> awaiter_.await_ready();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>直接根据<code>co_awaiter coro</code>的那个协程（被调协程）来决定是否ready，如果已经ready了，直接执行。</p>
<p>正常情况下ready都是false，此时会调用<code>await_suspend</code>来触发实际执行。其逻辑为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;Promise&gt; continuation)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::declval&lt;Awaiter&amp;&gt;().await_suspend(<span class="built_in">std</span>::declval&lt;WrapperHandle&gt;())))</span></span></span><br><span class="line">      -&gt; await_suspend_result_t &#123;</span><br><span class="line">    viaCoroutine_.setContinuation(continuation);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!detail::is_coroutine_handle_v&lt;<span class="keyword">await_suspend_result_t</span>&gt;)</span> </span>&#123;</span><br><span class="line">      viaCoroutine_.saveContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsCallerAsyncStackAware)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; asyncFrame = continuation.promise().getAsyncFrame();</span><br><span class="line">      <span class="keyword">auto</span>&amp; stackRoot = *asyncFrame.getStackRoot();</span><br><span class="line"></span><br><span class="line">      viaCoroutine_.setAsyncFrame(asyncFrame);</span><br><span class="line"></span><br><span class="line">      folly::deactivateAsyncStackFrame(asyncFrame);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Reactivate the stack-frame before we resume.</span></span><br><span class="line">      <span class="keyword">auto</span> rollback =</span><br><span class="line">          makeGuard([&amp;] &#123; activateAsyncStackFrame(stackRoot, asyncFrame); &#125;);</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">await_suspend_result_t</span>, <span class="keyword">bool</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!awaiter_.await_suspend(viaCoroutine_.getHandle())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rollback.dismiss();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">await_suspend_result_t</span>, <span class="keyword">void</span>&gt;) &#123;</span><br><span class="line">        awaiter_.await_suspend(viaCoroutine_.getHandle());</span><br><span class="line">        rollback.dismiss();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = awaiter_.await_suspend(viaCoroutine_.getHandle());</span><br><span class="line">        rollback.dismiss();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> awaiter_.await_suspend(viaCoroutine_.getHandle());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>IsCallerAsyncStackAware</code>是false，可以不考虑该逻辑。参数的<code>continuation</code>为调用者协程的<code>coroutine_handle</code>，即我们需要保证执行位置的协程。将<code>continuation</code>存储到<code>viaCoroutine_</code>，之后执行<code>return awaiter_.await_suspend(viaCoroutine_.getHandle());</code>。将架构封装的这层协程的<code>coroutine_handle</code>作为参数执行被调协程。这时，正常来说会立即执行被调协程，并且在被调协程执行完成之后，会唤醒调用者协程，这里的调用者协程就是架构封装的这一层协程。</p>
<p>这时才会执行完成创建<code>ViaIfAsyncAwaiter</code>时的<code>createImpl</code>函数。在执行完成该函数后析构该协程前，将会执行<code>co_await ViaIfAsyncAwaiter::promise_type::final_suspend</code>，这里将返回<code>ViaIfAsyncAwaiter::promise_type::FinalAwaiter</code>，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FinalAwaiter</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code runs immediately after the inner awaitable resumes its fake</span></span><br><span class="line"><span class="comment">// continuation, and it schedules the real continuation on the awaiter's</span></span><br><span class="line"><span class="comment">// executor</span></span><br><span class="line"><span class="function">FOLLY_CORO_AWAIT_SUSPEND_NONTRIVIAL_ATTRIBUTES <span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    coroutine_handle&lt;promise_type&gt; h)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; promise = h.promise();</span><br><span class="line">  <span class="keyword">if</span> (!promise.context_) &#123;</span><br><span class="line">    promise.setRequestContext(RequestContext::saveContext());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsStackAware)</span> </span>&#123;</span><br><span class="line">    folly::deactivateAsyncStackFrame(promise.getAsyncFrame());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise.scheduleContinuation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; folly::assume_unreachable(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里<code>await_suspend</code>的参数是架构这层协程的<code>coroutine_handle</code>。</p>
<p>其首先获取<code>promise</code>，设置<code>RequestContext</code>，之后执行<code>scheduleContinuation</code>，其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleContinuation</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pass the coroutine's RequestContext to Executor::add(), in case the</span></span><br><span class="line">  <span class="comment">// Executor implementation wants to know what runs on it (e.g. for stats).</span></span><br><span class="line">  RequestContextScopeGuard contextScope&#123;context_&#125;;</span><br><span class="line"></span><br><span class="line">  executor_-&gt;add([<span class="keyword">this</span>]() <span class="keyword">noexcept</span> &#123; <span class="keyword">this</span>-&gt;executeContinuation(); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeContinuation</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  RequestContextScopeGuard contextScope&#123;<span class="built_in">std</span>::move(context_)&#125;;</span><br><span class="line">  <span class="keyword">if</span> (asyncFrame_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    folly::resumeCoroutineWithNewAsyncStackRoot(</span><br><span class="line">        continuation_.getHandle(), *asyncFrame_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    continuation_.resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实现就是把<code>continuation_</code>的<code>resume</code>添加到指定线程池中执行，这里的<code>continuation_</code>即为调用者协程的<code>coroutine_handle</code>，即我们需要保证执行位置的协程。</p>
<p>至此完成了保证协程在指定线程池上执行的全部逻辑，可以看到，整体实现相当精妙，里面使用了C++的很多特性，值得深入研究。</p>
<h3 id="co-withAsyncStack"><a href="#co-withAsyncStack" class="headerlink" title="co_withAsyncStack"></a>co_withAsyncStack</h3><p><code>co_withAsyncStack</code>与<code>co_viaIfAsync</code>的作用类似，其被用于<code>await_transform()</code>内部，用于在当前协程<code>suspend</code>时将当前协程的调用栈信息暂存起来，在<code>resume</code>时恢复，其实现也于<code>co_viaIfAsync</code>类似，架构封装了一层协程实现，这里不过多介绍，详细信息可以看相关代码。</p>
<p>这里特别注意的是，对于希望自己维护调用栈关系的<code>Awaitables</code>，可以定义<code>tag_invoke</code>函数来自己控制，类似如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAwaitable</span> &#123;</span></span><br><span class="line">     <span class="function"><span class="keyword">friend</span> MyAwaitable&amp;&amp; <span class="title">tag_invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">cpo_t</span>&lt;folly::coro::co_withAsyncStack&gt;, MyAwaitable&amp;&amp; awaitable)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">std</span>::move(awaitable);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对awaiter的处理"><a href="#对awaiter的处理" class="headerlink" title="对awaiter的处理"></a>对<code>awaiter</code>的处理</h2><p>获取到<code>awaiter</code>后，会调用其<code>await_ready</code>，<code>await_suspend</code>以及最后的<code>await_resume</code>作为<code>co_await</code>的返回结果。这里都不在<code>TaskPromiseBase</code>的控制范畴，会在后续部分详细介绍。</p>
<h2 id="协程结束"><a href="#协程结束" class="headerlink" title="协程结束"></a>协程结束</h2><p>协程结束时，如果协程执行过程中跑出了异常，则会先执行<code>unhandled_exception</code>，这里其定义不在<code>TaskPromiseBase</code>而在<code>TaskPromise</code>，其定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    result_.emplaceException(exception_wrapper&#123;<span class="built_in">std</span>::current_exception()&#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即设置对应<code>result_</code>为异常。</p>
<p>如果没有异常(有异常也执行)，则直接执行<code>co_await TaskPromiseBase::final_suspend()</code>。这里我们看一下其定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalAwaiter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  FOLLY_CORO_AWAIT_SUSPEND_NONTRIVIAL_ATTRIBUTES coroutine_handle&lt;&gt;</span><br><span class="line">  await_suspend(coroutine_handle&lt;Promise&gt; coro) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; promise = coro.promise();</span><br><span class="line">    <span class="comment">// If the continuation has been exchanged, then we expect that the</span></span><br><span class="line">    <span class="comment">// exchanger will handle the lifetime of the async stack. See</span></span><br><span class="line">    <span class="comment">// ScopeExitTaskPromise's FinalAwaiter for more details.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is a bit untidy, and hopefully something we can replace with</span></span><br><span class="line">    <span class="comment">// a virtual wrapper over coroutine_handle that handles the pop for us.</span></span><br><span class="line">    <span class="keyword">if</span> (promise.ownsAsyncFrame_) &#123;</span><br><span class="line">      folly::popAsyncStackFrameCallee(promise.asyncFrame_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (promise.result_.hasException()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [handle, frame] =</span><br><span class="line">          promise.continuation_.getErrorHandle(promise.result_.exception());</span><br><span class="line">      <span class="keyword">return</span> handle.getHandle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise.continuation_.getHandle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; folly::assume_unreachable(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>await_ready()</code>返回false表示为懒加载。因此<code>co_await</code>会执行<code>await_suspend</code>，这里<code>coro</code>是当前协程的<code>coroutine_handle</code>。</p>
<p>其逻辑是首先获取当前协程的promise，这里就是<code>TaskPromise</code>。调用<code>popAsyncStackFrameCallee</code>将当前协程从协程栈中出栈。如果存在异常，则调用continuation_的异常处理函数，并返回<code>coroutine_handle</code>。</p>
<p>当没有异常时，返回<code>continuation_</code>的<code>coroutine_handle</code>。这里的<code>continuation_</code>是调用者协程的<code>coroutine_handle</code>，其会在后续介绍的<code>awaiter</code>的<code>await_suspend</code>中赋值。通过这个逻辑，实现了被调者完成处理后唤醒调用者。</p>
<p>协程结束时需要析构<code>handler</code>，folly的实现是析构交由<code>awaiter</code>来实现。</p>
<h1 id="TaskPromise"><a href="#TaskPromise" class="headerlink" title="TaskPromise"></a>TaskPromise</h1><p><code>Task</code>的<code>promise_type</code>并不是直接使用<code>TaskPromiseBase</code>而是使用的<code>TaskPromise</code>，其在<code>TaskPromiseBase</code>基础上增加一些协程的相关函数。</p>
<p>其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskPromise</span> <span class="title">final</span> :</span> <span class="keyword">public</span> TaskPromiseBase,</span><br><span class="line">                          <span class="keyword">public</span> ExtendedCoroutinePromiseImpl&lt;TaskPromise&lt;T&gt;&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static_assert</span>(</span><br><span class="line">      !<span class="built_in">std</span>::is_rvalue_reference_v&lt;T&gt;,</span><br><span class="line">      <span class="string">"Task&lt;T&amp;&amp;&gt; is not supported. "</span></span><br><span class="line">      <span class="string">"Consider using Task&lt;T&gt; or Task&lt;std::unique_ptr&lt;T&gt;&gt; instead."</span>);</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskPromiseBase</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> StorageType = detail::<span class="keyword">lift_lvalue_reference_t</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">  TaskPromise() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  Task&lt;T&gt; get_return_object() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    result_.emplaceException(exception_wrapper&#123;<span class="built_in">std</span>::current_exception()&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T&gt;</span><br><span class="line">  <span class="keyword">void</span> return_value(U&amp;&amp; value) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">constexpr</span> (<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">remove_cvref_t</span>&lt;U&gt;, Try&lt;StorageType&gt;&gt;) &#123;</span><br><span class="line">      DCHECK(value.hasValue() || value.hasException());</span><br><span class="line">      result_ = <span class="keyword">static_cast</span>&lt;U&amp;&amp;&gt;(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (</span><br><span class="line">        <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">remove_cvref_t</span>&lt;U&gt;, Try&lt;<span class="keyword">void</span>&gt;&gt; &amp;&amp;</span><br><span class="line">        <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">remove_cvref_t</span>&lt;T&gt;, Unit&gt;) &#123;</span><br><span class="line">      <span class="comment">// special-case to make task -&gt; semifuture -&gt; task preserve void type</span></span><br><span class="line">      DCHECK(value.hasValue() || value.hasException());</span><br><span class="line">      result_ = <span class="keyword">static_cast</span>&lt;Try&lt;Unit&gt;&gt;(<span class="keyword">static_cast</span>&lt;U&amp;&amp;&gt;(value));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">static_assert</span>(</span><br><span class="line">          <span class="built_in">std</span>::is_convertible&lt;U&amp;&amp;, StorageType&gt;::value,</span><br><span class="line">          <span class="string">"cannot convert return value to type T"</span>);</span><br><span class="line">      result_.emplace(<span class="keyword">static_cast</span>&lt;U&amp;&amp;&gt;(value));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Try&lt;StorageType&gt;&amp; result() &#123; <span class="keyword">return</span> result_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> TaskPromiseBase::await_transform;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;ExtendedCoroutineHandle, AsyncStackFrame*&gt; getErrorHandle(</span><br><span class="line">      exception_wrapper&amp; ex) override &#123;</span><br><span class="line">    <span class="keyword">if</span> (bypassExceptionThrowing_ == BypassExceptionThrowing::ACTIVE) &#123;</span><br><span class="line">      <span class="keyword">auto</span> finalAwaiter = yield_value(co_error(<span class="built_in">std</span>::move(ex)));</span><br><span class="line">      DCHECK(!finalAwaiter.await_ready());</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          finalAwaiter.await_suspend(</span><br><span class="line">              coroutine_handle&lt;TaskPromise&gt;::from_promise(*<span class="keyword">this</span>)),</span><br><span class="line">          <span class="comment">// finalAwaiter.await_suspend pops a frame</span></span><br><span class="line">          getAsyncFrame().getParentFrame()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;coroutine_handle&lt;TaskPromise&gt;::from_promise(*<span class="keyword">this</span>), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Try&lt;StorageType&gt; result_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedCoroutinePromiseImpl</span> :</span> <span class="keyword">public</span> ExtendedCoroutinePromise &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  coroutine_handle&lt;&gt; getHandle() final &#123;</span><br><span class="line">    <span class="keyword">return</span> coroutine_handle&lt;Promise&gt;::from_promise(</span><br><span class="line">        *<span class="keyword">static_cast</span>&lt;Promise*&gt;(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::pair&lt;ExtendedCoroutineHandle, AsyncStackFrame*&gt; getErrorHandle(</span><br><span class="line">      exception_wrapper&amp;) override &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;getHandle(), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ~ExtendedCoroutinePromiseImpl() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，其主要增加了一个<code>Try&lt;StorageType&gt; result_</code>用来存储协程返回值。实现了异常处理函数<code>unhandled_exception</code>。获取协程返回值<code>get_return_object</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Task&lt;T&gt; detail::TaskPromise&lt;T&gt;::get_return_object() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Task&lt;T&gt;&#123;coroutine_handle&lt;detail::TaskPromise&lt;T&gt;&gt;::from_promise(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户调用<code>co_return</code>是设置协程返回值<code>return_value</code>。这里设置的返回值会是<code>co_await coro</code>的最终返回值，即<code>awaiter</code>的<code>await_resume</code>最后会返回该值。</p>
<p><code>TaskPromise</code>还有一个<code>TaskPromise&lt;void&gt;</code>的偏例化，其主要实现了void相关的接口，这里不详细介绍。</p>
<h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><p><code>task</code>是folly coro的核心类，一般对于协程函数返回值都应该是Task。通过task，folly将协程调用链串连起来。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FOLLY_NODISCARD</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> promise_type = detail::TaskPromise&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> StorageType = <span class="keyword">typename</span> promise_type::StorageType;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Awaiter</span>;</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">handle_t</span> = coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(folly::Executor::KeepAlive&lt;&gt;&amp;&amp; e)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    DCHECK(coro_);</span><br><span class="line">    DCHECK(e);</span><br><span class="line">    coro_.promise().executor_ = <span class="built_in">std</span>::move(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Task(<span class="keyword">const</span> Task&amp; t) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create a Task, invalidating the original Task in the process.</span></span><br><span class="line">  Task(Task&amp;&amp; t) <span class="keyword">noexcept</span> : coro_(<span class="built_in">std</span>::exchange(t.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @private</span></span><br><span class="line">  <span class="comment">// 析构时负责析构协程的handler</span></span><br><span class="line">  ~Task() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">      coro_.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Task&amp; <span class="keyword">operator</span>=(Task t) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    swap(t);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Task&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">std</span>::swap(coro_, t.coro_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Specify the executor that this task should execute on.</span></span><br><span class="line">  <span class="comment">/// @param executor An Executor::KeepAlive object, which can be implicity</span></span><br><span class="line">  <span class="comment">/// constructed from Executor</span></span><br><span class="line">  <span class="comment">/// @returns a new TaskWithExecutor object, which represents the existing Task</span></span><br><span class="line">  <span class="comment">/// bound to an executor</span></span><br><span class="line">  FOLLY_NODISCARD</span><br><span class="line">  TaskWithExecutor&lt;T&gt; scheduleOn(Executor::KeepAlive&lt;&gt; executor) &amp;&amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    setExecutor(<span class="built_in">std</span>::move(executor));</span><br><span class="line">    DCHECK(coro_);</span><br><span class="line">    <span class="keyword">return</span> TaskWithExecutor&lt;T&gt;&#123;<span class="built_in">std</span>::exchange(coro_, &#123;&#125;)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">detail</span>:</span>:TaskPromiseBase;</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">detail</span>:</span>:TaskPromise&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Awaiter</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    explicit Awaiter(handle_t coro) noexcept : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Awaiter(Awaiter&amp;&amp; other) <span class="keyword">noexcept</span> : coro_(<span class="built_in">std</span>::exchange(other.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Awaiter(<span class="keyword">const</span> Awaiter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~Awaiter() &#123;</span><br><span class="line">      <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">        coro_.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    <span class="function">FOLLY_NOINLINE <span class="keyword">auto</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        coroutine_handle&lt;Promise&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      DCHECK(coro_);</span><br><span class="line">      <span class="keyword">auto</span>&amp; promise = coro_.promise();</span><br><span class="line"></span><br><span class="line">      promise.continuation_ = continuation;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span>&amp; calleeFrame = promise.getAsyncFrame();</span><br><span class="line">      calleeFrame.setReturnAddress();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(detail::promiseHasAsyncFrame_v&lt;Promise&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; callerFrame = continuation.promise().getAsyncFrame();</span><br><span class="line">        folly::pushAsyncStackFrameCallerCallee(callerFrame, calleeFrame);</span><br><span class="line">        <span class="keyword">return</span> coro_;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        folly::resumeCoroutineWithNewAsyncStackRoot(coro_);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DCHECK(coro_);</span><br><span class="line">      SCOPE_EXIT &#123; <span class="built_in">std</span>::exchange(coro_, &#123;&#125;).destroy(); &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(coro_.promise().result()).value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    folly::Try&lt;StorageType&gt; await_resume_try() &#123;</span><br><span class="line">      DCHECK(coro_);</span><br><span class="line">      SCOPE_EXIT &#123; <span class="built_in">std</span>::exchange(coro_, &#123;&#125;).destroy(); &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(coro_.promise().result());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// This overload needed as Awaiter is returned from co_viaIfAsync() which is</span></span><br><span class="line">    <span class="comment">// then passed into co_withAsyncStack().</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Awaiter <span class="title">tag_invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">cpo_t</span>&lt;co_withAsyncStack&gt;, Awaiter&amp;&amp; awaiter)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(awaiter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">handle_t</span> coro_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Task(<span class="keyword">handle_t</span> coro) <span class="keyword">noexcept</span> : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">handle_t</span> coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据之前关于<code>promise_type</code>的介绍，这里当<code>co_await Task</code>时，获取到的<code>awaiter</code>是<code>Task::Awaiter</code>。</p>
<p>这里其<code>await_ready</code>始终返回false。一定会执行<code>await_suspend</code>，这里其参数<code>continuation</code>是调用者协程的<code>coroutine_handle</code>，而不是<code>co_await Task</code>里面的这个<code>Task</code>。</p>
<p>在<code>await_suspend</code>，首先设置<code>promise</code>的<code>continuation_</code>为调用者协程的<code>coroutine_handle</code>，配合上面介绍的<code>TaskPromiseBase::FinalAwaiter</code>实现被调协程完成后唤醒调用者协程。这里的<code>if constexpr (detail::promiseHasAsyncFrame_v&lt;Promise&gt;)</code>为true，这里的操作是维护协程的调用栈，将当前协程的调用栈追加到调用链路中。之后返回当前协程的<code>coroutine_handle</code>，这会立即执行当前协程。</p>
<p>当协程执行结束，会调用<code>await_resume</code>获取<code>co_await Task</code>的最终返回值，即<code>co_return expr</code>设置的值。这里实际执行的是<code>Try::value</code>。如果没有设置value，则会抛出异常，但是如果是<code>void</code>值，则不会抛出异常，这是由于<code>Try&lt;void&gt;</code>默认是有值的。因此对于返回<code>Task&lt;void&gt;</code>的协程，可以不执行<code>co_return</code>，对于其他类型的返回一定要执行<code>co_return expr</code>。</p>
<p>对于返回<code>Task&lt;void&gt;</code>的协程来说，一定要特别注意是，虽然可以不执行<code>co_return</code>，但是一定要保证函数是协程，即至少要出现<code>co_await</code>，<code>co_return</code>或者<code>co_yield</code>。由于<code>Task</code>没有将默认构造函数delete，因此如果没有出现这三个关键字，则该函数就不是协程函数，不会按照协程的方式执行（不要问我是怎么知道的…）。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="keyword">void</span>&gt; a() &#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"process func a"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就不是一个协程函数。</p>
<h1 id="TaskWithExecutor"><a href="#TaskWithExecutor" class="headerlink" title="TaskWithExecutor"></a>TaskWithExecutor</h1><p><code>Task</code>协程默认运行在调用者线程中，但在对延迟较敏感的服务中，我们需要将不同协程执行在不同线程中，也就是一般说的<code>M:N</code>模式（<code>brpc</code>中<code>bthread</code>也是这种模式，将m个用户态线程映射到n个实际liunx线程中，m远大于n）。为提供该功能，<code>Task</code>提供接口<code>scheduleOn</code>及<code>TaskWithExecutor</code>类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TaskWithExecutor&lt;T&gt; scheduleOn(Executor::KeepAlive&lt;&gt; executor) &amp;&amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    setExecutor(<span class="built_in">std</span>::move(executor));</span><br><span class="line">    DCHECK(coro_);</span><br><span class="line">    <span class="keyword">return</span> TaskWithExecutor&lt;T&gt;&#123;<span class="built_in">std</span>::exchange(coro_, &#123;&#125;)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口提供一个线程池，设置改task执行在该线程池中。返回<code>TaskWithExecutor</code>，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FOLLY_NODISCARD</span> <span class="title">TaskWithExecutor</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">handle_t</span> = coroutine_handle&lt;detail::TaskPromise&lt;T&gt;&gt;;</span><br><span class="line">  <span class="keyword">using</span> StorageType = <span class="keyword">typename</span> detail::TaskPromise&lt;T&gt;::StorageType;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @private</span></span><br><span class="line">  ~TaskWithExecutor() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">      coro_.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TaskWithExecutor(TaskWithExecutor&amp;&amp; t) <span class="keyword">noexcept</span></span><br><span class="line">      : coro_(<span class="built_in">std</span>::exchange(t.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  TaskWithExecutor&amp; <span class="keyword">operator</span>=(TaskWithExecutor t) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    swap(t);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// Returns the executor that the task is bound to</span></span><br><span class="line">  folly::<span class="function">Executor* <span class="title">executor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> coro_.promise().executor_.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(TaskWithExecutor&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">std</span>::swap(coro_, t.coro_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Start eager execution of this task.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This starts execution of the Task on the bound executor.</span></span><br><span class="line">  <span class="comment">/// @returns folly::SemiFuture&lt;T&gt; that will complete with the result.</span></span><br><span class="line">  FOLLY_NOINLINE SemiFuture&lt;<span class="keyword">lift_unit_t</span>&lt;StorageType&gt;&gt; start() &amp;&amp; &#123;</span><br><span class="line">    folly::Promise&lt;<span class="keyword">lift_unit_t</span>&lt;StorageType&gt;&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sf = p.getSemiFuture();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::move(*<span class="keyword">this</span>).startImpl(</span><br><span class="line">        [promise = <span class="built_in">std</span>::move(p)](Try&lt;StorageType&gt;&amp;&amp; result) <span class="keyword">mutable</span> &#123;</span><br><span class="line">          promise.setTry(<span class="built_in">std</span>::move(result));</span><br><span class="line">        &#125;,</span><br><span class="line">        folly::CancellationToken&#123;&#125;,</span><br><span class="line">        FOLLY_ASYNC_STACK_RETURN_ADDRESS());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Start eager execution of the task and call the passed callback on</span></span><br><span class="line">  <span class="comment">/// completion</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This starts execution of the Task on the bound executor, and call the</span></span><br><span class="line">  <span class="comment">/// passed callback upon completion. The callback takes a Try&lt;T&gt; which</span></span><br><span class="line">  <span class="comment">/// represents either th value returned by the Task on success or an</span></span><br><span class="line">  <span class="comment">/// exeception thrown by the Task</span></span><br><span class="line">  <span class="comment">/// @param tryCallback a function that takes in a Try&lt;T&gt;</span></span><br><span class="line">  <span class="comment">/// @param cancelToken a CancelationToken object</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="function">FOLLY_NOINLINE <span class="keyword">void</span> <span class="title">start</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      F&amp;&amp; tryCallback, folly::CancellationToken cancelToken = &#123;&#125;)</span> &amp;&amp; </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::move(*<span class="keyword">this</span>).startImpl(</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(tryCallback),</span><br><span class="line">        <span class="built_in">std</span>::move(cancelToken),</span><br><span class="line">        FOLLY_ASYNC_STACK_RETURN_ADDRESS());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Start eager execution of this task on this thread.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Assumes the current thread is already on the executor associated with the</span></span><br><span class="line">  <span class="comment">/// Task. Refer to TaskWithExecuter::start(F&amp;&amp; tryCallback,</span></span><br><span class="line">  <span class="comment">/// folly::CancellationToken cancelToken = &#123;&#125;) for more information.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="function">FOLLY_NOINLINE <span class="keyword">void</span> <span class="title">startInlineUnsafe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      F&amp;&amp; tryCallback, folly::CancellationToken cancelToken = &#123;&#125;)</span> &amp;&amp; </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::move(*<span class="keyword">this</span>).startInlineImpl(</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(tryCallback),</span><br><span class="line">        <span class="built_in">std</span>::move(cancelToken),</span><br><span class="line">        FOLLY_ASYNC_STACK_RETURN_ADDRESS());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Start eager execution of this task on this thread.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Assumes the current thread is already on the executor associated with the</span></span><br><span class="line">  <span class="comment">/// Task. Refer to TaskWithExecuter::start() for more information.</span></span><br><span class="line">  FOLLY_NOINLINE SemiFuture&lt;<span class="keyword">lift_unit_t</span>&lt;StorageType&gt;&gt; startInlineUnsafe() &amp;&amp; &#123;</span><br><span class="line">    folly::Promise&lt;<span class="keyword">lift_unit_t</span>&lt;StorageType&gt;&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sf = p.getSemiFuture();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::move(*<span class="keyword">this</span>).startInlineImpl(</span><br><span class="line">        [promise = <span class="built_in">std</span>::move(p)](Try&lt;StorageType&gt;&amp;&amp; result) <span class="keyword">mutable</span> &#123;</span><br><span class="line">          promise.setTry(<span class="built_in">std</span>::move(result));</span><br><span class="line">        &#125;,</span><br><span class="line">        folly::CancellationToken&#123;&#125;,</span><br><span class="line">        FOLLY_ASYNC_STACK_RETURN_ADDRESS());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      F&amp;&amp; tryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::CancellationToken cancelToken,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">void</span>* returnAddress)</span> &amp;&amp; </span>&#123;</span><br><span class="line">    coro_.promise().setCancelToken(<span class="built_in">std</span>::move(cancelToken));</span><br><span class="line">    startImpl(<span class="built_in">std</span>::move(*<span class="keyword">this</span>), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(tryCallback))</span><br><span class="line">        .start(returnAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startInlineImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      F&amp;&amp; tryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::CancellationToken cancelToken,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">void</span>* returnAddress)</span> &amp;&amp; </span>&#123;</span><br><span class="line">    coro_.promise().setCancelToken(<span class="built_in">std</span>::move(cancelToken));</span><br><span class="line">    RequestContextScopeGuard contextScope&#123;RequestContext::saveContext()&#125;;</span><br><span class="line">    startInlineImpl(<span class="built_in">std</span>::move(*<span class="keyword">this</span>), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(tryCallback))</span><br><span class="line">        .start(returnAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  detail::<span class="function">InlineTaskDetached <span class="title">startImpl</span><span class="params">(TaskWithExecutor task, F cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb(co_await folly::coro::co_awaitTry(<span class="built_in">std</span>::move(task)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      cb(Try&lt;StorageType&gt;(exception_wrapper(<span class="built_in">std</span>::current_exception())));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  detail::<span class="function">InlineTaskDetached <span class="title">startInlineImpl</span><span class="params">(TaskWithExecutor task, F cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb(co_await InlineTryAwaitable&#123;<span class="built_in">std</span>::exchange(task.coro_, &#123;&#125;)&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      cb(Try&lt;StorageType&gt;(exception_wrapper(<span class="built_in">std</span>::current_exception())));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Awaiter</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    explicit Awaiter(handle_t coro) noexcept : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Awaiter(Awaiter&amp;&amp; other) <span class="keyword">noexcept</span> : coro_(<span class="built_in">std</span>::exchange(other.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~Awaiter() &#123;</span><br><span class="line">      <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">        coro_.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    <span class="function">FOLLY_NOINLINE <span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        coroutine_handle&lt;Promise&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      DCHECK(coro_);</span><br><span class="line">      <span class="keyword">auto</span>&amp; promise = coro_.promise();</span><br><span class="line">      DCHECK(!promise.continuation_);</span><br><span class="line">      DCHECK(promise.executor_);</span><br><span class="line">      DCHECK(!<span class="keyword">dynamic_cast</span>&lt;folly::InlineExecutor*&gt;(promise.executor_.get()))</span><br><span class="line">          &lt;&lt; <span class="string">"InlineExecutor is not safe and is not supported for coro::Task. "</span></span><br><span class="line">          &lt;&lt; <span class="string">"If you need to run a task inline in a unit-test, you should use "</span></span><br><span class="line">          &lt;&lt; <span class="string">"coro::blockingWait instead."</span>;</span><br><span class="line">      DCHECK(!<span class="keyword">dynamic_cast</span>&lt;folly::QueuedImmediateExecutor*&gt;(</span><br><span class="line">          promise.executor_.get()))</span><br><span class="line">          &lt;&lt; <span class="string">"QueuedImmediateExecutor is not safe and is not supported for coro::Task. "</span></span><br><span class="line">          &lt;&lt; <span class="string">"If you need to run a task inline in a unit-test, you should use "</span></span><br><span class="line">          &lt;&lt; <span class="string">"coro::blockingWait instead."</span>;</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(kIsDebug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">dynamic_cast</span>&lt;InlineLikeExecutor*&gt;(promise.executor_.get())) &#123;</span><br><span class="line">          FB_LOG_ONCE(ERROR)</span><br><span class="line">              &lt;&lt; <span class="string">"InlineLikeExecutor is not safe and is not supported for coro::Task. "</span></span><br><span class="line">              &lt;&lt; <span class="string">"If you need to run a task inline in a unit-test, you should use "</span></span><br><span class="line">              &lt;&lt; <span class="string">"coro::blockingWait or write your test using the CO_TEST* macros instead."</span></span><br><span class="line">              &lt;&lt; <span class="string">"If you are using folly::getCPUExecutor, switch to getGlobalCPUExecutor "</span></span><br><span class="line">              &lt;&lt; <span class="string">"or be sure to call setCPUExecutor first."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 维护协程调用栈</span></span><br><span class="line">      <span class="keyword">auto</span>&amp; calleeFrame = promise.getAsyncFrame();</span><br><span class="line">      calleeFrame.setReturnAddress();</span><br><span class="line">      <span class="comment">// 这里返回true，同样是在维护协程调用栈</span></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(detail::promiseHasAsyncFrame_v&lt;Promise&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; callerFrame = continuation.promise().getAsyncFrame();</span><br><span class="line">        calleeFrame.setParentFrame(callerFrame);</span><br><span class="line">        folly::deactivateAsyncStackFrame(callerFrame);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置调用者协程为continuation_值，在当前线程执行完后恢复调用者协程调用。</span></span><br><span class="line">      promise.continuation_ = continuation;</span><br><span class="line">      <span class="comment">// 将协程丢到线程池中执行，同时传递ctx</span></span><br><span class="line">      promise.executor_-&gt;add(</span><br><span class="line">          [coro = coro_, ctx = RequestContext::saveContext()]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">            RequestContextScopeGuard contextScope&#123;<span class="built_in">std</span>::move(ctx)&#125;;</span><br><span class="line">            folly::resumeCoroutineWithNewAsyncStackRoot(coro);</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回对应的result</span></span><br><span class="line">    <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DCHECK(coro_);</span><br><span class="line">      <span class="comment">// Eagerly destroy the coroutine-frame once we have retrieved the result.</span></span><br><span class="line">      SCOPE_EXIT &#123; <span class="built_in">std</span>::exchange(coro_, &#123;&#125;).destroy(); &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(coro_.promise().result()).value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    folly::Try&lt;StorageType&gt; await_resume_try() &#123;</span><br><span class="line">      SCOPE_EXIT &#123; <span class="built_in">std</span>::exchange(coro_, &#123;&#125;).destroy(); &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(coro_.promise().result());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">handle_t</span> coro_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InlineTryAwaitable</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    InlineTryAwaitable(<span class="keyword">handle_t</span> coro) <span class="keyword">noexcept</span> : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    InlineTryAwaitable(InlineTryAwaitable&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : coro_(<span class="built_in">std</span>::exchange(other.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~InlineTryAwaitable() &#123;</span><br><span class="line">      <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">        coro_.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    FOLLY_NOINLINE coroutine_handle&lt;&gt; await_suspend(</span><br><span class="line">        coroutine_handle&lt;Promise&gt; continuation) &#123;</span><br><span class="line">      DCHECK(coro_);</span><br><span class="line">      <span class="keyword">auto</span>&amp; promise = coro_.promise();</span><br><span class="line">      DCHECK(!promise.continuation_);</span><br><span class="line">      DCHECK(promise.executor_);</span><br><span class="line"></span><br><span class="line">      promise.continuation_ = continuation;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span>&amp; calleeFrame = promise.getAsyncFrame();</span><br><span class="line">      calleeFrame.setReturnAddress();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This awaitable is only ever awaited from a DetachedInlineTask</span></span><br><span class="line">      <span class="comment">// which is an async-stack-aware coroutine.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Assume it has a .getAsyncFrame() and that this frame is currently</span></span><br><span class="line">      <span class="comment">// active.</span></span><br><span class="line">      <span class="keyword">auto</span>&amp; callerFrame = continuation.promise().getAsyncFrame();</span><br><span class="line">      folly::pushAsyncStackFrameCallerCallee(callerFrame, calleeFrame);</span><br><span class="line">      <span class="keyword">return</span> coro_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    folly::Try&lt;StorageType&gt; await_resume() &#123;</span><br><span class="line">      DCHECK(coro_);</span><br><span class="line">      <span class="comment">// Eagerly destroy the coroutine-frame once we have retrieved the result.</span></span><br><span class="line">      SCOPE_EXIT &#123; <span class="built_in">std</span>::exchange(coro_, &#123;&#125;).destroy(); &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(coro_.promise().result());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> InlineTryAwaitable <span class="title">tag_invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">cpo_t</span>&lt;co_withAsyncStack&gt;, InlineTryAwaitable&amp;&amp; awaitable)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(awaitable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">handle_t</span> coro_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Awaiter <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> &amp;&amp; <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    DCHECK(coro_);</span><br><span class="line">    <span class="keyword">return</span> Awaiter&#123;<span class="built_in">std</span>::exchange(coro_, &#123;&#125;)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> TaskWithExecutor <span class="title">co_withCancellation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::CancellationToken cancelToken, TaskWithExecutor&amp;&amp; task)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    DCHECK(task.coro_);</span><br><span class="line">    task.coro_.promise().setCancelToken(<span class="built_in">std</span>::move(cancelToken));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(task);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> TaskWithExecutor <span class="title">tag_invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">cpo_t</span>&lt;co_withAsyncStack&gt;, TaskWithExecutor&amp;&amp; task)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(task);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span>&lt;T&gt;;</span></span><br><span class="line"></span><br><span class="line">  explicit TaskWithExecutor(handle_t coro) noexcept : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">handle_t</span> coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先来看当<code>co_await TaskWithExecutor</code>时返回的<code>awaiter</code>执行逻辑，这里根据之前<code>TaskPromise</code>描述可以推断出这里返回的<code>Awaiter</code>，其执行核心为<code>Awaiter::await_suspend</code>函数，其和Task对应的awaiter核心区别是执行协程的逻辑是在被丢到指定线程池中执行，同时需要维护一下<code>ctx</code>，对于ctx的作用可以参考上一篇介绍future的文档：[RequestContext][<a href="https://www.yinkuiwang.cn/2023/01/08/folly%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%B8%8EDAG/#RequestContext]。" target="_blank" rel="noopener">https://www.yinkuiwang.cn/2023/01/08/folly%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%B8%8EDAG/#RequestContext]。</a></p>
<p>这里由于被调协程会被丢到线程池中执行，因此调用者协程如果直接在被调协程后被<code>resume</code>则会破坏调用者协程指定执行位置（线程池），因此需要<code>co_viaIfAsync</code>函数（上面有介绍）。</p>
<p>函数<code>Awaiter::await_suspend</code>还有一点需要注意的是，这里返回的是空，表示会挂起调用<code>co_await</code>方法的协程，并返回到调用该协程的地方。加入到线程池的函数逻辑较为简单，只有如下两句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestContextScopeGuard contextScope&#123;std::move(ctx)&#125;;</span><br><span class="line">folly::resumeCoroutineWithNewAsyncStackRoot(coro);</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，调用<code>folly::resumeCoroutineWithNewAsyncStackRoot(coro);</code>时会恢复当前task绑定的协程，如果恢复协程后，协程内部执行<code>co_await</code>返空了，则调用回到<code>folly::resumeCoroutineWithNewAsyncStackRoot(coro)</code>函数中的<code>h.resume()</code>语句，这时体现到线程上，这个函数就执行完成了，不会出现阻塞线程的情况。</p>
<p>这里的还有一个<code>InlineTryAwaitable</code>，似乎只有显示调用<code>startInlineUnsafe</code>时会使用，其<code>await_suspend</code>也是不加到线程池里直接调用，这一般是指调用者和被调者使用的是同一个线程池。</p>
<p><code>TaskWithExecutor</code>的另一个核心接口是<code>start</code>，其含义是执行当前协程，并返回一个<code>SemiFuture</code>，用户使用<code>SemiFuture</code>来等待调用结束。</p>
<p>其核心是将协程执行状态和一个<code>promise</code>绑定，当协程执行完成后，对promise的<code>SemiFuture</code>赋值。这里的核心点是如何触发协程的执行，其实现方式是再加一层协程，这里就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  detail::<span class="function">InlineTaskDetached <span class="title">startImpl</span><span class="params">(TaskWithExecutor task, F cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb(co_await folly::coro::co_awaitTry(<span class="built_in">std</span>::move(task)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      cb(Try&lt;StorageType&gt;(exception_wrapper(<span class="built_in">std</span>::current_exception())));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当调用start时，最终会执行到该方法，其返回<code>InlineTaskDetached</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InlineTaskDetached</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FinalAwaiter</span> &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;promise_type&gt; h)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        folly::deactivateAsyncStackFrame(h.promise().getAsyncFrame());</span><br><span class="line">        h.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">      [[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; folly::assume_unreachable(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ::folly_coro_async_malloc(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">      ::folly_coro_async_free(ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    promise_type() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">      asyncFrame_.setParentFrame(folly::getDetachedRootAsyncStackFrame());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">InlineTaskDetached <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> InlineTaskDetached&#123;</span><br><span class="line">          coroutine_handle&lt;promise_type&gt;::from_promise(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FinalAwaiter <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    [[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">std</span>::terminate(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) await_transform(Awaitable&amp;&amp; awaitable) &#123;</span><br><span class="line">      <span class="keyword">return</span> folly::coro::co_withAsyncStack(</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    folly::<span class="function">AsyncStackFrame&amp; <span class="title">getAsyncFrame</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> asyncFrame_; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    folly::AsyncStackFrame asyncFrame_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  InlineTaskDetached(InlineTaskDetached&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">      : coro_(<span class="built_in">std</span>::exchange(other.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~InlineTaskDetached() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">      coro_.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">FOLLY_NOINLINE <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    start(FOLLY_ASYNC_STACK_RETURN_ADDRESS());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">void</span>* returnAddress)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    coro_.promise().getAsyncFrame().setReturnAddress(returnAddress);</span><br><span class="line">    folly::resumeCoroutineWithNewAsyncStackRoot(<span class="built_in">std</span>::exchange(coro_, &#123;&#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">InlineTaskDetached</span><span class="params">(coroutine_handle&lt;promise_type&gt; h)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">      : coro_(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  coroutine_handle&lt;promise_type&gt; coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实现较为简单，<code>await_transform</code>方法只是对原<code>awaitable</code>增加了一层<code>co_withAsyncStack</code>。最终的协程结束处理(<code>FinalAwaiter</code>)也没干什么，只是维护了一下调用栈并且析构了一下资源。调用该函数返回<code>InlineTaskDetached</code>后会立即调用其start方法。该方法直接将自己持有的协程<code>resume</code>，这时就会执行<code>cb(co_await folly::coro::co_awaitTry(std::move(task)));</code>，从而触发我们实际要等到的协程的执行。而返回给调用者的<code>SemiFuture</code>则给用户做判断是否执行完成，当协程执行完成后，<code>cb</code>函数会完成对<code>promise</code>的<code>setTry</code>，这时调用者获得的<code>SemiFuture</code>就变成完成状态。</p>
<h1 id="等待协程执行结束"><a href="#等待协程执行结束" class="headerlink" title="等待协程执行结束"></a>等待协程执行结束</h1><p>folly官方文档介绍等待协程执行结束有两种方式：</p>
<ol>
<li>协程调用<code>scheduleOn().start()</code></li>
<li><code>folly::coro::blockingWait(std::move(task).scheduleOn())</code></li>
</ol>
<p>第一种方式在<code>TaskWithExecutor</code>中已经介绍过了，这里再来看一下<code>blockingWait</code>的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> blocking_wait_fn blocking_wait&#123;&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> blocking_wait_fn <span class="keyword">const</span>&amp; blockingWait =</span><br><span class="line">    blocking_wait; <span class="comment">// backcompat</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blocking_wait_fn</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function">FOLLY_NOINLINE <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Awaitable&amp;&amp; awaitable)</span> <span class="keyword">const</span></span></span><br><span class="line">      -&gt; detail::decay_rvalue_reference_t&lt;await_result_t&lt;Awaitable&gt;&gt; &#123;</span><br><span class="line">    folly::AsyncStackFrame frame;</span><br><span class="line">    frame.setReturnAddress();</span><br><span class="line"></span><br><span class="line">    folly::AsyncStackRoot stackRoot;</span><br><span class="line">    stackRoot.setNextRoot(folly::tryGetCurrentAsyncStackRoot());</span><br><span class="line">    stackRoot.setStackFrameContext();</span><br><span class="line">    stackRoot.setTopFrame(frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">add_rvalue_reference_t</span>&lt;<span class="keyword">await_result_t</span>&lt;Awaitable&gt;&gt;&gt;(</span><br><span class="line">        detail::makeRefBlockingWaitTask(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable))</span><br><span class="line">            .get(frame));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SemiAwaitable&gt;</span><br><span class="line">  <span class="function">FOLLY_NOINLINE <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      SemiAwaitable&amp;&amp; awaitable, folly::DrivableExecutor* executor)</span> <span class="keyword">const</span></span></span><br><span class="line">      -&gt; detail::decay_rvalue_reference_t&lt;semi_await_result_t&lt;SemiAwaitable&gt;&gt; &#123;</span><br><span class="line">    folly::AsyncStackFrame frame;</span><br><span class="line">    frame.setReturnAddress();</span><br><span class="line"></span><br><span class="line">    folly::AsyncStackRoot stackRoot;</span><br><span class="line">    stackRoot.setNextRoot(folly::tryGetCurrentAsyncStackRoot());</span><br><span class="line">    stackRoot.setStackFrameContext();</span><br><span class="line">    stackRoot.setTopFrame(frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">add_rvalue_reference_t</span>&lt;<span class="keyword">semi_await_result_t</span>&lt;SemiAwaitable&gt;&gt;&gt;(</span><br><span class="line">        detail::makeRefBlockingWaitTask(</span><br><span class="line">            folly::coro::co_viaIfAsync(</span><br><span class="line">                folly::getKeepAliveToken(executor),</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;SemiAwaitable&amp;&amp;&gt;(awaitable)))</span><br><span class="line">            .getVia(executor, frame));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;</span><br><span class="line">      <span class="keyword">typename</span> SemiAwaitable,</span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;!is_awaitable_v&lt;SemiAwaitable&gt;, <span class="keyword">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>()(SemiAwaitable&amp;&amp; awaitable) <span class="keyword">const</span></span><br><span class="line">      -&gt; detail::<span class="keyword">decay_rvalue_reference_t</span>&lt;<span class="keyword">semi_await_result_t</span>&lt;SemiAwaitable&gt;&gt; &#123;</span><br><span class="line">    <span class="built_in">std</span>::exception_ptr eptr;</span><br><span class="line">    &#123;</span><br><span class="line">      detail::BlockingWaitExecutor executor;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">operator</span>()(<span class="keyword">static_cast</span>&lt;SemiAwaitable&amp;&amp;&gt;(awaitable), &amp;executor);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        eptr = <span class="built_in">std</span>::current_exception();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::rethrow_exception(eptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里执行的主要是第一个<code>operator</code>方法。其中<code>makeRefBlockingWaitTask</code>定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;</span><br><span class="line">    typename Awaitable,</span><br><span class="line">    typename Result = await_result_t&lt;Awaitable&gt;,</span><br><span class="line">    std::enable_if_t&lt;std::is_void&lt;Result&gt;::value, int&gt; = 0&gt;</span><br><span class="line">BlockingWaitTask&lt;void&gt; makeRefBlockingWaitTask(Awaitable&amp;&amp; awaitable) &#123;</span><br><span class="line">  co_await static_cast&lt;Awaitable&amp;&amp;&gt;(awaitable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;</span><br><span class="line">    typename Awaitable,</span><br><span class="line">    typename Result = await_result_t&lt;Awaitable&gt;,</span><br><span class="line">    std::enable_if_t&lt;!std::is_void&lt;Result&gt;::value, int&gt; = 0&gt;</span><br><span class="line">auto makeRefBlockingWaitTask(Awaitable&amp;&amp; awaitable)</span><br><span class="line">    -&gt; BlockingWaitTask&lt;std::add_lvalue_reference_t&lt;Result&gt;&gt; &#123;</span><br><span class="line">  co_yield co_await static_cast&lt;Awaitable&amp;&amp;&gt;(awaitable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>BlockingWaitTask</code>是一个协程返回值。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingWaitTask</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> promise_type = BlockingWaitPromise&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">handle_t</span> = coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">  explicit BlockingWaitTask(handle_t coro) noexcept : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  BlockingWaitTask(BlockingWaitTask&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">      : coro_(<span class="built_in">std</span>::exchange(other.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  BlockingWaitTask&amp; <span class="keyword">operator</span>=(BlockingWaitTask&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~BlockingWaitTask() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">      coro_.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">FOLLY_NOINLINE T <span class="title">get</span><span class="params">(folly::AsyncStackFrame&amp; parentFrame)</span> &amp;&amp; </span>&#123;</span><br><span class="line">    folly::Try&lt;detail::<span class="keyword">lift_lvalue_reference_t</span>&lt;T&gt;&gt; result;</span><br><span class="line">    <span class="keyword">auto</span>&amp; promise = coro_.promise();</span><br><span class="line">    promise.setTry(&amp;result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; asyncFrame = promise.getAsyncFrame();</span><br><span class="line">    asyncFrame.setParentFrame(parentFrame);</span><br><span class="line">    asyncFrame.setReturnAddress();</span><br><span class="line">    &#123;</span><br><span class="line">      RequestContextScopeGuard guard&#123;RequestContext::saveContext()&#125;;</span><br><span class="line">      folly::resumeCoroutineWithNewAsyncStackRoot(coro_);</span><br><span class="line">    &#125;</span><br><span class="line">    promise.wait();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(result).value();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">handle_t</span> coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当调用get方法时，会将自己持有的协程<code>resume</code>。这里实际执行的就是<code>co_await static_cast&lt;Awaitable&amp;&amp;&gt;(awaitable);</code>，也即我们要等到执行结束的协程。之后执行<code>promise.wait()</code>等待协程执行结束。这里需要看一下<code>promise</code>的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingWaitPromiseBase</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">FinalAwaiter</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(coroutine_handle&lt;Promise&gt; coro)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      BlockingWaitPromiseBase&amp; promise = coro.promise();</span><br><span class="line">      folly::deactivateAsyncStackFrame(promise.getAsyncFrame());</span><br><span class="line">      promise.baton_.post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BlockingWaitPromiseBase() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::folly_coro_async_malloc(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    ::folly_coro_async_free(ptr, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">FinalAwaiter <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) await_transform(Awaitable&amp;&amp; awaitable) &#123;</span><br><span class="line">    <span class="keyword">return</span> folly::coro::co_withAsyncStack(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">done</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> baton_.ready(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; baton_.wait(); &#125;</span><br><span class="line"></span><br><span class="line">  folly::<span class="function">AsyncStackFrame&amp; <span class="title">getAsyncFrame</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> asyncFrame_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  folly::fibers::Baton baton_;</span><br><span class="line">  folly::AsyncStackFrame asyncFrame_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中核心在<code>BlockingWaitPromiseBase</code>中，其存在一个<code>folly::fibers::Baton</code>类。该类的实现使用的是<code>futex</code>，可以参考该文档<a href="https://man7.org/linux/man-pages/man2/futex.2.html" target="_blank" rel="noopener">futex</a>。这里不展开介绍（其实是不太会orz）。核心是一个同步原语。folly对其封装了一下，核心是两个接口，一个是<code>post</code>，另一个是<code>wait</code>。其中<code>wait</code>用于等待同步信号，<code>post</code>用于发送信号，在post发送信号前，调用<code>wait</code>的线程会被阻塞，直到另一个线程发送了<code>post</code>信号（有点像条件变量的感觉）。因此这里在将我们等待的协程resum后，就通过<code>wait</code>接口等待协程完成。</p>
<p>这里有一点需要注意，正常来说<code>BlockingWaitPromiseBase</code>持有的协程被恢复后，如果执行完成了，我们等待的协程应该执行结束了才对，为啥还需要使用<code>baton</code>来进行同步呢？这时因为，将<code>BlockingWaitPromiseBase</code>持有的协程resume，该协程不一定（在这里是大概率）表示该协程被执行完成了。当我们resume <code>BlockingWaitPromiseBase</code>持有的协程时，执行<code>co_await static_cast&lt;Awaitable&amp;&amp;&gt;(awaitable);</code>，当我们<code>co_await</code>的协程被指定到特定线程池执行时，执行<code>co_await</code>时调用的<code>await_suspend</code>方法返回就是空（可以看<code>TaskWithExecutor</code>的<code>Awaiter::await_suspend</code>方法），这时会立即回到<code>resume</code>协程的地方，这里就是回到了即回到<code>folly::resumeCoroutineWithNewAsyncStackRoot(coro_)</code>里面的<code>h.resume()</code>这条语句这里，接着执行后面的逻辑。而<code>BlockingWaitPromiseBase</code>持有的协程被挂起，当我们等待的协程执行结束时，会重新唤醒<code>BlockingWaitPromiseBase</code>持有的协程，进行后续处理。因此在这里我们使用<code>promise.wait();</code>等待<code>BlockingWaitPromiseBase</code>被重新唤醒并被执行完成（在执行完成时<code>FinalAwaiter</code>的<code>await_suspend</code>发送<code>post</code>信号告知执行结束），这样才能保证我们等待的协程确定被执行完成。</p>
<h1 id="clollectAll"><a href="#clollectAll" class="headerlink" title="clollectAll"></a>clollectAll</h1><p>想DAG中依赖关系一样，一个协程依赖的数据产出可能需要多个协程生成，这时，如果我们按照协程实际依赖的数据，每次都<code>co_await</code>对应的协程，将会导致依赖的协程顺序被触发，串行执行，这在对耗时较为敏感的系统中是不可接受的，我们需要有统一触发多个协程并发执行的接口，这就是这一节要介绍的<code>collectAll</code>接口。其传递的参数是一个<code>Task</code>的list，如果task是异步的，即指定线程池执行，则所有的task会被异步执行，如果task是同步的（没有转换为<code>TaskWithExecutor</code>，则会被同步执行）。</p>
<p>其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> InputRange,</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">        !<span class="built_in">std</span>::is_void_v&lt;</span><br><span class="line">            <span class="keyword">semi_await_result_t</span>&lt;detail::<span class="keyword">range_reference_t</span>&lt;InputRange&gt;&gt;&gt;,</span><br><span class="line">        <span class="keyword">int</span>&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">collectAllRange</span><span class="params">(InputRange awaitables)</span></span></span><br><span class="line">    -&gt; folly::coro::Task&lt;std::vector&lt;detail::collect_all_range_component_t&lt;</span><br><span class="line">        detail::<span class="keyword">range_reference_t</span>&lt;InputRange&gt;&gt;&gt;&gt; &#123;</span><br><span class="line">  <span class="comment">// 利用task promise的await_transform获取到当前协程的executor</span></span><br><span class="line">  <span class="keyword">const</span> folly::Executor::KeepAlive&lt;&gt; executor = co_await co_current_executor;</span><br><span class="line">  <span class="keyword">const</span> CancellationSource cancelSource;</span><br><span class="line">  <span class="comment">// 获取当前协程的cancellation，并和自己协程创建的cancellation进行merge</span></span><br><span class="line">  <span class="keyword">const</span> CancellationToken cancelToken = CancellationToken::merge(</span><br><span class="line">      co_await co_current_cancellation_token, cancelSource.getToken());</span><br><span class="line">  <span class="comment">//使用try list 存储结果</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;detail::<span class="keyword">collect_all_try_range_component_t</span>&lt;</span><br><span class="line">      detail::<span class="keyword">range_reference_t</span>&lt;InputRange&gt;&gt;&gt;</span><br><span class="line">      tryResults;</span><br><span class="line"></span><br><span class="line">  exception_wrapper firstException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> awaitable_type = <span class="keyword">remove_cvref_t</span>&lt;detail::<span class="keyword">range_reference_t</span>&lt;InputRange&gt;&gt;;</span><br><span class="line">  <span class="comment">// 对每一个task封装一层协程，协程返回值是detail::BarrierTask</span></span><br><span class="line">  <span class="keyword">auto</span> makeTask = [&amp;](awaitable_type semiAwaitable,</span><br><span class="line">                      <span class="built_in">std</span>::<span class="keyword">size_t</span> index) -&gt; detail::BarrierTask &#123;</span><br><span class="line">    assert(index &lt; tryResults.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// co_viaIfAsync限制我们创建的协程函数始终在当前协程设置的executor上执行</span></span><br><span class="line">      tryResults[index].emplace(co_await co_viaIfAsync(</span><br><span class="line">          executor.get_alias(),</span><br><span class="line">          co_withCancellation(cancelToken, <span class="built_in">std</span>::move(semiAwaitable))));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!cancelSource.requestCancellation()) &#123;</span><br><span class="line">        firstException = exception_wrapper&#123;<span class="built_in">std</span>::current_exception()&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 遍历awaitables，按照makeTask函数创建协程</span></span><br><span class="line">  <span class="keyword">auto</span> tasks = detail::collectMakeInnerTaskVec(awaitables, makeTask);</span><br><span class="line"></span><br><span class="line">  tryResults.resize(tasks.size());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the initial context and restore it after starting each task</span></span><br><span class="line">  <span class="comment">// as the task may have modified the context before suspending and we</span></span><br><span class="line">  <span class="comment">// want to make sure the next task is started with the same initial</span></span><br><span class="line">  <span class="comment">// context.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> context = RequestContext::saveContext();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>&amp; asyncFrame = co_await detail::co_current_async_stack_frame;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Launch the tasks and wait for them all to finish.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 设置一个屏障，值为我们要等待的协程数+1，这里的1是collectAll自己协程处理的那个1，即下面的co_await语句</span></span><br><span class="line">    detail::Barrier barrier&#123;tasks.size() + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : tasks) &#123;</span><br><span class="line">      <span class="comment">// resume我们创建的协程</span></span><br><span class="line">      task.start(&amp;barrier, asyncFrame);</span><br><span class="line">      <span class="comment">// 恢复当前线程的上下文，因为task.start可能会变更当前线程的context</span></span><br><span class="line">      RequestContext::setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置所有协程执行完成后唤醒当前协程，并等待返回。</span></span><br><span class="line">    co_await detail::UnsafeResumeInlineSemiAwaitable&#123;barrier.arriveAndWait()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 异常处理</span></span><br><span class="line">  <span class="comment">// Check if there were any exceptions and rethrow the first one.</span></span><br><span class="line">  <span class="keyword">if</span> (firstException) &#123;</span><br><span class="line">    <span class="function">co_yield <span class="title">co_error</span><span class="params">(<span class="built_in">std</span>::move(firstException))</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从try中获取结果</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;detail::<span class="keyword">collect_all_range_component_t</span>&lt;</span><br><span class="line">      detail::<span class="keyword">range_reference_t</span>&lt;InputRange&gt;&gt;&gt;</span><br><span class="line">      results;</span><br><span class="line">  results.reserve(tryResults.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; result : tryResults) &#123;</span><br><span class="line">    results.emplace_back(<span class="built_in">std</span>::move(result).value());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置结果</span></span><br><span class="line">  co_return results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> InputRange,</span><br><span class="line">    <span class="keyword">typename</span> Make,</span><br><span class="line">    <span class="keyword">typename</span> Iter = <span class="keyword">invoke_result_t</span>&lt;access::begin_fn, InputRange&amp;&gt;,</span><br><span class="line">    <span class="keyword">typename</span> Elem = <span class="keyword">remove_cvref_t</span>&lt;<span class="keyword">decltype</span>(*<span class="built_in">std</span>::declval&lt;Iter&amp;&gt;())&gt;,</span><br><span class="line">    <span class="keyword">typename</span> RTask = <span class="keyword">invoke_result_t</span>&lt;Make&amp;, Elem, <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RTask&gt; collectMakeInnerTaskVec(InputRange&amp; awaitables, Make&amp; make) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RTask&gt; tasks;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> abegin = access::begin(awaitables);</span><br><span class="line">  <span class="keyword">auto</span> aend = access::end(awaitables);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_invocable_v&lt;folly::access::size_fn, InputRange&amp;&gt;)</span> </span>&#123;</span><br><span class="line">    tasks.reserve(<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(folly::access::size(awaitables)));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (range_has_known_distance_v&lt;InputRange&amp;&gt;) &#123;</span><br><span class="line">    tasks.reserve(<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(<span class="built_in">std</span>::distance(abegin, aend)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> aiter = abegin; aiter != aend; ++aiter) &#123;</span><br><span class="line">    tasks.push_back(make(<span class="built_in">std</span>::move(*aiter), index++));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeResumeInlineSemiAwaitable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UnsafeResumeInlineSemiAwaitable</span><span class="params">(Awaitable&amp;&amp; awaitable)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">      : awaitable_(awaitable) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Awaitable&amp;&amp; <span class="title">viaIfAsync</span><span class="params">(folly::Executor::KeepAlive&lt;&gt;)</span> &amp;&amp; <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Awaitable awaitable_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>collectAllRange</code>本身也是一个协程函数，返回值是一个<code>Task</code>。因此我们调用该方法时，拿到task后，还需要<code>co_await task</code>。</p>
<p>具体的每步执行逻辑上面都进行了注解。这里核心需要关注的是<code>detail::Barrier</code>和<code>detail::BarrierTask</code>。</p>
<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p><code>Barrier</code>是一个屏障，当所以协程执行完成后，才就绪，其定义如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barrier</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 屏障计数</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Barrier</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> initialCount = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">      : count_(initialCount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> count = <span class="number">1</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    [[maybe_unused]] <span class="built_in">std</span>::<span class="keyword">size_t</span> oldCount =</span><br><span class="line">        count_.fetch_add(count, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// Check we didn't overflow the count.</span></span><br><span class="line">    assert(SIZE_MAX - oldCount &gt;= count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Query the number of remaining tasks that the barrier is waiting</span></span><br><span class="line">  <span class="comment">// for. This indicates the number of arrive() calls that must be</span></span><br><span class="line">  <span class="comment">// made before the Barrier will be released.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note that this should just be used as an approximate guide</span></span><br><span class="line">  <span class="comment">// for the number of outstanding tasks. This value may be out</span></span><br><span class="line">  <span class="comment">// of date immediately upon being returned.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> remaining() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count_.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接受一个信号（这里一般表示一个协程结束），将计数减一，并根据是否所以条件均满足来决定是否唤醒等待的协程</span></span><br><span class="line">  [[nodiscard]] coroutine_handle&lt;&gt; arrive(</span><br><span class="line">      folly::AsyncStackFrame&amp; currentFrame) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; stackRoot = *currentFrame.getStackRoot();</span><br><span class="line">    folly::deactivateAsyncStackFrame(currentFrame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> oldCount = count_.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalid to call arrive() if you haven't previously incremented the</span></span><br><span class="line">    <span class="comment">// counter using .add().</span></span><br><span class="line">    assert(oldCount &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (asyncFrame_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        folly::activateAsyncStackFrame(stackRoot, *asyncFrame_);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::exchange(continuation_, &#123;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> coro::noop_coroutine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受一个信号（这里一般表示一个协程结束），将计数减一，并根据是否所以条件均满足来决定是否唤醒等待的协程</span></span><br><span class="line">  [[nodiscard]] coroutine_handle&lt;&gt; arrive() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> oldCount = count_.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalid to call arrive() if you haven't previously incremented the</span></span><br><span class="line">    <span class="comment">// counter using .add().</span></span><br><span class="line">    assert(oldCount &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> coro = <span class="built_in">std</span>::exchange(continuation_, &#123;&#125;);</span><br><span class="line">      <span class="keyword">if</span> (asyncFrame_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        folly::resumeCoroutineWithNewAsyncStackRoot(coro, *asyncFrame_);</span><br><span class="line">        <span class="keyword">return</span> coro::noop_coroutine();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coro;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> coro::noop_coroutine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Awaiter</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    explicit Awaiter(Barrier&amp; barrier) noexcept : barrier_(barrier) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// co_await时设置最终要唤醒的协程，并将屏障计数-1，如果条件已经满足，则会立即唤醒对应协程</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">    coroutine_handle&lt;&gt; await_suspend(</span><br><span class="line">        coroutine_handle&lt;Promise&gt; continuation) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(detail::promiseHasAsyncFrame_v&lt;Promise&gt;)</span> </span>&#123;</span><br><span class="line">        barrier_.setContinuation(</span><br><span class="line">            continuation, &amp;continuation.promise().getAsyncFrame());</span><br><span class="line">        <span class="keyword">return</span> barrier_.arrive(continuation.promise().getAsyncFrame());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        barrier_.setContinuation(continuation, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> barrier_.arrive();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Awaiter <span class="title">tag_invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">cpo_t</span>&lt;co_withAsyncStack&gt;, Awaiter&amp;&amp; awaiter)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Awaiter&#123;awaiter.barrier_&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Barrier&amp; barrier_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 返回一个Awaiter，并使用this初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">arriveAndWait</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> Awaiter&#123;*<span class="keyword">this</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置屏障结束时需要唤醒的协程</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setContinuation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      coroutine_handle&lt;&gt; continuation,</span></span></span><br><span class="line"><span class="function"><span class="params">      folly::AsyncStackFrame* parentFrame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    assert(!continuation_);</span><br><span class="line">    continuation_ = continuation;</span><br><span class="line">    asyncFrame_ = parentFrame;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; count_;</span><br><span class="line">  coroutine_handle&lt;&gt; continuation_;</span><br><span class="line">  folly::AsyncStackFrame* asyncFrame_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其存在三个成员变量。</p>
<ol>
<li><code>count_</code>计数，用来记录当前还未执行完成的协程数量。</li>
<li><code>continuation_</code>表示当所有条件就绪后需要执行唤醒的协程。</li>
<li><code>asyncFrame_</code>用于维护协程栈。</li>
</ol>
<p>这里的<code>Awaiter</code>就是collectAll中最后我们<code>co_await</code>的<code>awaiter</code>。当<code>collectAll</code> <code>co_await</code>时，首先设置了最终要唤醒<code>collectAll</code>函数，并将引用计数减一。当每个协程执行结束时，也会将引用计数减一。</p>
<h2 id="BarrierTask"><a href="#BarrierTask" class="headerlink" title="BarrierTask"></a>BarrierTask</h2><p><code>BarrierTask</code>是<code>collectAll</code>中对每一个<code>task</code>包的一层协程。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarrierTask</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FinalAwaiter</span> &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">      coroutine_handle&lt;&gt; await_suspend(</span><br><span class="line">          coroutine_handle&lt;promise_type&gt; h) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; promise = h.promise();</span><br><span class="line">        assert(promise.barrier_ != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> promise.barrier_-&gt;arrive(promise.asyncFrame_);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ::folly_coro_async_malloc(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">      ::folly_coro_async_free(ptr, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BarrierTask <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> BarrierTask&#123;coroutine_handle&lt;promise_type&gt;::from_promise(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FinalAwaiter <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(Awaitable&amp;&amp; awaitable)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> folly::coro::co_withAsyncStack(</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    [[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">std</span>::terminate(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBarrier</span><span class="params">(Barrier* barrier)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      assert(barrier_ == <span class="literal">nullptr</span>);</span><br><span class="line">      barrier_ = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    folly::<span class="function">AsyncStackFrame&amp; <span class="title">getAsyncFrame</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> asyncFrame_; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    folly::AsyncStackFrame asyncFrame_;</span><br><span class="line">    Barrier* barrier_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">handle_t</span> = coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">  explicit BarrierTask(handle_t coro) noexcept : coro_(coro) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BarrierTask(BarrierTask&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">      : coro_(<span class="built_in">std</span>::exchange(other.coro_, &#123;&#125;)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~BarrierTask() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_) &#123;</span><br><span class="line">      coro_.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BarrierTask&amp; <span class="keyword">operator</span>=(BarrierTask other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    swap(other);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(BarrierTask&amp; b)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">std</span>::swap(coro_, b.coro_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">FOLLY_NOINLINE <span class="keyword">void</span> <span class="title">start</span><span class="params">(Barrier* barrier)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    start(barrier, folly::getDetachedRootAsyncStackFrame());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行当前协程</span></span><br><span class="line">  <span class="function">FOLLY_NOINLINE <span class="keyword">void</span> <span class="title">start</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Barrier* barrier, folly::AsyncStackFrame&amp; parentFrame)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    assert(coro_);</span><br><span class="line">    <span class="keyword">auto</span>&amp; calleeFrame = coro_.promise().getAsyncFrame();</span><br><span class="line">    calleeFrame.setParentFrame(parentFrame);</span><br><span class="line">    calleeFrame.setReturnAddress();</span><br><span class="line">    coro_.promise().setBarrier(barrier);</span><br><span class="line"></span><br><span class="line">    folly::resumeCoroutineWithNewAsyncStackRoot(coro_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 当前协程的coro</span></span><br><span class="line">  <span class="keyword">handle_t</span> coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>promise_type</code>持有一个<code>barrier</code>的指针，当我们调用<code>BarrierTask</code>的start函数时，传递<code>barrier</code>，将在<code>collectAll</code>中创建的<code>barrier</code>传递到<code>promise_type</code>。调用<code>start</code>函数后，就会恢复当前协程的执行。在执行完成当前协程后，<code>final_suspend</code>返回<code>FinalAwaiter</code>。当<code>co_await</code>该<code>awaiter</code>时，执行<code>await_suspend</code>函数，执行<code>barrier</code>的<code>arrive</code>函数，将<code>barrier</code>计数减一，并根据是否已经减到0了来决定是否唤醒等待的协程。</p>
<p>这里在<code>collectAll</code>中设置<code>barrier</code>为task数量+1中的+1，是collectAll调用<code>co_await detail::UnsafeResumeInlineSemiAwaitable{barrier.arriveAndWait()};</code>使用。调用这个函数，会设置barrier满足条件后唤醒的<code>collectAll</code>，并将当前协程挂起，等所以协程都执行结束后再唤醒该协程。</p>
<p>这里需要注意的是，<code>BarrierTask</code>执行start函数唤醒当前协程时，会执行在<code>collectAll</code>中<code>makeTask</code>函数，即执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">co_await <span class="title">co_viaIfAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          executor.get_alias(),</span></span></span><br><span class="line"><span class="function"><span class="params">          co_withCancellation(cancelToken, <span class="built_in">std</span>::move(semiAwaitable)))</span></span></span><br></pre></td></tr></table></figure>
<p>如果这里的<code>semiAwaitable</code>不是异步协程，则会陷入<code>semiAwaitable</code>协程执行对应协程的处理逻辑，执行完成后再返回到<code>makeTask</code>函数。而如果<code>semiAwaitable</code>是异步协程，则执行上述语句后会立即返回到<code>start</code>函数中，继续执行for循环后的其他start方法。</p>
<p>因此，当我们<code>collectAll</code>时，为了让所有协程并发执行，一定要传异步协程，否则所有协程一样会被串行执行，和一个一个<code>co_await</code>没区别（甚至因为套了一层协程更废了）。</p>
<h1 id="promise-amp-future-amp-SharedPromise"><a href="#promise-amp-future-amp-SharedPromise" class="headerlink" title="promise&amp;future&amp;SharedPromise"></a>promise&amp;future&amp;SharedPromise</h1><p>在上一节，我们解决了一个协程依赖多个协程产生的数据。但是在实际执行中，往往还有另一个问题，如果应该协程产生的数据被多个协程依赖如何处理。根据前面的学习，我们知道，肯定不能是多个协程同时<code>co_await</code>同一个task（协程正常应该只需要执行一次，并且task上线中，co_await时生成的awaiter都使用了<code>std::exchange(t.coro_, {})</code>方式，不支持多次co_await）。</p>
<p>目前对于该需求的实现，和之前介绍的future方法实现一致，即使用<code>SharedPromise</code>。具体可以参考上一篇文档：<a href="https://www.yinkuiwang.cn/2023/01/08/folly%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%E4%B8%8EDAG/#future-amp-promise" target="_blank" rel="noopener">future&amp;SharedPromise</a>。</p>
<p>将协程的task绑定到一个<code>SharedPromise</code>上，当某个协程依赖该协程使用数据时，从<code>SharedPromise</code>中获取一个<code>future</code>，<code>co_await</code>该future即可。当协程执行完成后，设置<code>SharedPromise</code>状态为完成状态，这时所有等待的协程都会被唤醒。</p>
<p>这里的关键是对<code>co_await future</code>的实现，要保证在<code>co_await future</code>时协程挂起不阻塞。其实现也较为简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> detail::FutureAwaiter&lt;T&gt;</span><br><span class="line"><span class="comment">/* implicit */</span> <span class="function"><span class="keyword">operator</span> <span class="title">co_await</span><span class="params">(Future&lt;T&gt;&amp;&amp; future)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> detail::FutureAwaiter&lt;T&gt;(<span class="built_in">std</span>::move(future));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>co_await future</code>是，返回的<code>awaiter</code>是<code>detail::FutureAwaiter</code>，其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureAwaiter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FutureAwaiter</span><span class="params">(folly::Future&lt;T&gt;&amp;&amp; future)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">      : future_(std::move(future)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (future_.isReady()) &#123;</span><br><span class="line">      result_ = <span class="built_in">std</span>::move(future_.result());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::move(result_).value(); &#125;</span><br><span class="line"></span><br><span class="line">  Try&lt;<span class="keyword">drop_unit_t</span>&lt;T&gt;&gt; await_resume_try() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Try&lt;<span class="keyword">drop_unit_t</span>&lt;T&gt;&gt;&gt;(<span class="built_in">std</span>::move(result_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">FOLLY_CORO_AWAIT_SUSPEND_NONTRIVIAL_ATTRIBUTES <span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      coro::coroutine_handle&lt;&gt; h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// FutureAwaiter may get destroyed as soon as the callback is executed.</span></span><br><span class="line">    <span class="comment">// Make sure the future object doesn't get destroyed until setCallback_</span></span><br><span class="line">    <span class="comment">// returns.</span></span><br><span class="line">    <span class="keyword">auto</span> future = <span class="built_in">std</span>::move(future_);</span><br><span class="line">    future.setCallback_(</span><br><span class="line">        [<span class="keyword">this</span>, h](Executor::KeepAlive&lt;&gt;&amp;&amp;, Try&lt;T&gt;&amp;&amp; result) <span class="keyword">mutable</span> &#123;</span><br><span class="line">          result_ = <span class="built_in">std</span>::move(result);</span><br><span class="line">          h.resume();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  folly::Future&lt;T&gt; future_;</span><br><span class="line">  folly::Try&lt;T&gt; result_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实现也较为简单，当<code>co_await future</code>时，如果<code>future</code>已经ready，则立即继续执行就好了，因此<code>await_ready</code>中先判断就绪状态。如果future未就绪，则执行<code>await_suspend</code>时，在future后增加一个<code>callback</code>，其逻辑是在future就绪后唤醒当前协程，同时返回空，挂起当前协程。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"folly/experimental/coro/BlockingWait.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/executors/GlobalExecutor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/init/Init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;folly/experimental/coro/Task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/experimental/coro/Collect.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/experimental/coro/SharedMutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"folly/executors/CPUThreadPoolExecutor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"folly/experimental/coro/SharedPromise.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"folly/futures/SharedPromise.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, folly::SharedPromise&lt;folly::Unit&gt;&gt; global_maping;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">atomic_int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">folly::coro::SharedMutexFair lock;</span><br><span class="line"></span><br><span class="line">folly::coro::Task&lt;<span class="keyword">void</span>&gt; create_depends(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, folly::SharedPromise&lt;folly::Unit&gt;&gt;&amp; <span class="built_in">map</span>) &#123;</span><br><span class="line">    folly::SharedPromise&lt;folly::Unit&gt;* promise = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> share_lock = co_await lock.co_scoped_lock_shared();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">"create_depends"</span>) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于重复对同一个SharedPromise调用setValue会抛异常，因此这里加了写锁后再确认一下</span></span><br><span class="line">    <span class="keyword">if</span>(promise == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> share_lock = co_await lock.co_scoped_lock();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">"create_depends"</span>) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="comment">// 读</span></span><br><span class="line">                promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 写</span></span><br><span class="line">                promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证只执行一次</span></span><br><span class="line">    <span class="keyword">if</span>(!promise-&gt;isFulfilled()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"create_depends value is "</span>&lt;&lt;value++&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        promise-&gt;setValue();</span><br><span class="line">    &#125;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">folly::coro::Task&lt;<span class="keyword">void</span>&gt; use_depends_a(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, folly::SharedPromise&lt;folly::Unit&gt;&gt;&amp; <span class="built_in">map</span>) &#123;</span><br><span class="line">    folly::SharedPromise&lt;folly::Unit&gt;* promise = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> share_lock = co_await lock.co_scoped_lock_shared();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">"create_depends"</span>) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(promise == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 由于读写锁生命周期问题，需要有这个标识来避免在写锁的生命周期内执行新的协程</span></span><br><span class="line">        <span class="keyword">bool</span> need_co_await = <span class="literal">false</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> share_lock = co_await lock.co_scoped_lock();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">"create_depends"</span>) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="comment">// 读</span></span><br><span class="line">                promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                写，保证依赖的协程一定会被触发，执行一次对其的co_await </span></span><br><span class="line"><span class="comment">                因此create_depends最多会被调用两次，一次是其依赖的协程对其添加，一次是最初的collectAll时添加</span></span><br><span class="line"><span class="comment">                因此create_depends需要被设计为可重入函数</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">                need_co_await = <span class="literal">true</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        co_await create_depends(map).scheduleOn(folly::getGlobalCPUExecutor());</span><br><span class="line">    &#125;</span><br><span class="line">    co_await promise-&gt;getFuture();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"use_depends_a value is "</span>&lt;&lt;value&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">folly::coro::Task&lt;<span class="keyword">void</span>&gt; use_depends_b(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, folly::SharedPromise&lt;folly::Unit&gt;&gt;&amp; <span class="built_in">map</span>) &#123;</span><br><span class="line">    folly::SharedPromise&lt;folly::Unit&gt;* promise = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> share_lock = co_await lock.co_scoped_lock_shared();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">"create_depends"</span>) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">            promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(promise == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> need_co_await = <span class="literal">false</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> share_lock = co_await lock.co_scoped_lock();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">"create_depends"</span>) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="comment">// 读</span></span><br><span class="line">                promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                写，保证依赖的协程一定会被触发，执行一次对其的co_await </span></span><br><span class="line"><span class="comment">                因此create_depends最多会被调用两次，一次是其依赖的协程对其添加，一次是最初的collectAll时添加</span></span><br><span class="line"><span class="comment">                因此create_depends需要被设计为可重入函数</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                promise = &amp;<span class="built_in">map</span>[<span class="string">"create_depends"</span>];</span><br><span class="line">                need_co_await = <span class="literal">true</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        co_await create_depends(map).scheduleOn(folly::getGlobalCPUExecutor());</span><br><span class="line">    &#125;</span><br><span class="line">    co_await promise-&gt;getFuture();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"use_depends_b value is "</span>&lt;&lt;value&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">folly::coro::Task&lt;<span class="keyword">void</span>&gt; get_all(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, folly::SharedPromise&lt;folly::Unit&gt;&gt;&amp; <span class="built_in">map</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;folly::coro::TaskWithExecutor&lt;<span class="keyword">void</span>&gt;&gt; sum;</span><br><span class="line">    sum.push_back(use_depends_a(<span class="built_in">map</span>).scheduleOn(folly::getGlobalCPUExecutor()));</span><br><span class="line">    sum.push_back(use_depends_b(<span class="built_in">map</span>).scheduleOn(folly::getGlobalCPUExecutor()));</span><br><span class="line">    co_await folly::coro::collectAllRange(<span class="built_in">std</span>::move(sum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">folly::coro::Task&lt;<span class="keyword">void</span>&gt; get_all_v2(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, folly::SharedPromise&lt;folly::Unit&gt;&gt;&amp; <span class="built_in">map</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;folly::coro::TaskWithExecutor&lt;<span class="keyword">void</span>&gt;&gt; sum;</span><br><span class="line">    sum.push_back(use_depends_a(<span class="built_in">map</span>).scheduleOn(folly::getGlobalCPUExecutor()));</span><br><span class="line">    sum.push_back(use_depends_b(<span class="built_in">map</span>).scheduleOn(folly::getGlobalCPUExecutor()));</span><br><span class="line">    sum.push_back(create_depends(<span class="built_in">map</span>).scheduleOn(folly::getGlobalCPUExecutor()));</span><br><span class="line">    co_await folly::coro::collectAllRange(<span class="built_in">std</span>::move(sum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folly::init(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="keyword">auto</span> task1 = get_all(global_maping);</span><br><span class="line">    folly::coro::blockingWait(<span class="built_in">std</span>::move(task1).scheduleOn(folly::getGlobalCPUExecutor()));</span><br><span class="line">    global_maping.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task2 = get_all_v2(global_maping);</span><br><span class="line">    folly::coro::blockingWait(<span class="built_in">std</span>::move(task2).scheduleOn(folly::getGlobalCPUExecutor()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ -L/opt/lib -I/opt/include test_coro.cpp -std=c++20 -lfolly -lglog -lgflags -lpthread -ldl -ldouble-conversion -lfmt -levent -lboost_context</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./a.out -folly_global_cpu_executor_threads=<span class="number">5</span></span><br><span class="line">create_depends value is <span class="number">0</span></span><br><span class="line">use_depends_b value is <span class="number">1</span></span><br><span class="line">use_depends_a value is <span class="number">1</span></span><br><span class="line">create_depends value is <span class="number">1</span></span><br><span class="line">use_depends_a value is <span class="number">2</span></span><br><span class="line">use_depends_b value is <span class="number">2</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>这里借助<code>SharedPromise</code>，我们将协程函数设计成了可重入函数。其中使用的<code>folly::coro::SharedMutexFair</code>是协程的读写锁，后面会进行介绍。其他相关逻辑都有注释介绍，这里就不一一解释了。</p>
<h1 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h1><p>使用协程，并且每个协程都分配一个线程池执行的情况下，执行层面优化点在哪，其实每次的调度都是需要把协程丢到线程池队列去执行，那每一个协程的实际执行需要通过线程池的分发。虽然需要通过线程池来进行分发协程任务，但是线程池在执行协程时基本不会阻塞，这就大大减少了内核调度的开销，在线程池分发协程任务时，可能会由于使用有锁队列造成一定的线程阻塞，但大部分情况来说（协程任务不是特别碎的情况下）这部分开销相对较小，因此使用协程还是会有较大收益。</p>
<p>这时我们再考虑一下folly的future，其实如果我们能够完全按照规范使用future，在任务内部不要死等，而都交于future的调度，其实也不会造成线程阻塞，效率理论上来说和协程应该不会差距很多。因此只要解决当前future实现的异步方法中死等的问题即可，利用coro就很好实现了。所以folly的coro兼容future，只需要在原来任务内部<code>future.get()</code>的地方改成<code>co_await future</code>，并且函数返回值是<code>task</code>即可，这样原来的future和现在的core其实新能应该差距不大。</p>
<h1 id="避免阻塞"><a href="#避免阻塞" class="headerlink" title="避免阻塞"></a>避免阻塞</h1><p>协程核心就是避免阻塞造成操作系统对线程的切换开销。因此如何避免阻塞就是协程库需要考虑的核心问题了，<code>folly</code>对原阻塞方法都提供了相应的非阻塞方法，下面我们针对性的进行介绍。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p><code>sleep</code>方法时明显的阻塞调用。<code>folly</code>利用事件驱动框架封装了一个非阻塞版本的<code>sleep</code>。其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="keyword">void</span>&gt; sleep(HighResDuration d, Timekeeper* tk = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Task&lt;<span class="keyword">void</span>&gt; sleep(HighResDuration d, Timekeeper* tk) &#123;</span><br><span class="line">  <span class="keyword">bool</span> cancelled&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  folly::coro::Baton baton;</span><br><span class="line">  Try&lt;Unit&gt; result;</span><br><span class="line">  <span class="keyword">auto</span> future = folly::futures::sleep(d, tk).toUnsafeFuture();</span><br><span class="line">  future.setCallback_(</span><br><span class="line">      [&amp;result, &amp;baton](Executor::KeepAlive&lt;&gt;&amp;&amp;, Try&lt;Unit&gt;&amp;&amp; t) &#123;</span><br><span class="line">        result = <span class="built_in">std</span>::move(t);</span><br><span class="line">        baton.post();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">CancellationCallback <span class="title">cancelCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        co_await co_current_cancellation_token, [&amp;]() <span class="keyword">noexcept</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">          cancelled = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">          future.cancel();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span></span>;</span><br><span class="line">    co_await baton;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">    co_yield co_cancelled;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">co_yield <span class="title">co_result</span><span class="params">(<span class="built_in">std</span>::move(result))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>folly::coro::Baton</code>在介绍等待协程结束章节已经介绍过了，这里不做赘述。这里的核心是<code>folly::futures::sleep(d, tk).toUnsafeFuture();</code>该方法返回一个<code>future</code>。其实直接将其返回，我们<code>co_await future</code>就可以了，但这里为了返回<code>task</code>，直接将<code>co_await future</code>的实现封装到了函数内部。</p>
<p><code>folly::futures::sleep(d, tk)</code>方法将超时时间加到全局的事件驱动框架中（<code>EventBase</code>类），该事件驱动框架基于<code>libevent</code>实现，这个没看过，不过可以参考<code>nginx</code>的事件驱动框架<a href="https://www.yinkuiwang.cn/2021/09/30/nginx%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">nginx时间驱动框架</a>。这里就不展开介绍了，后续如果有时间，可以研究一下。</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>IO是阻塞的重灾区，对于同步io，是没有办法解决阻塞问题的，只能改成使用异步IO。Facebook开源的thrift rpc支持异步io。可以将异步io返回值设置成<code>future</code>，当io完成后，设置对应的promise即可。这时在业务代码中，我们只需要<code>co_await future</code>即可。</p>
<p>对<code>future</code>支持<code>co_await</code>上面已经介绍过了，这里就不再赘述了。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>使用一般的线程锁，当出现锁冲突时，未获取到锁的线程将会被挂起。为了避免由于锁导致的阻塞问题，folly提供了协程锁（协程锁的设计不是为了避免协程切换导致的死锁，而是为了避免协程阻塞）。这里解释上文使用过的协程锁<code>SharedMutexFair</code>。</p>
<p><code>SharedMutexFair</code>实现时基于自旋锁和原子变量实现的，实际以原子变量状态控制锁信息，自旋锁只在读写原子变量时使用。每次读写完原子变量立即释放锁，避免阻塞。</p>
<p>这里只介绍核心接口及其实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedMutexFair</span> :</span> <span class="keyword">private</span> folly::NonCopyableNonMovable &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Awaiter&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LockOperation</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LockAwaiter</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ScopedLockAwaiter</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LockSharedAwaiter</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ScopedLockSharedAwaiter</span>;</span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SharedMutexFair() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  ~SharedMutexFair();</span><br><span class="line">  <span class="comment">// 尝试获取读锁</span></span><br><span class="line">  <span class="keyword">bool</span> SharedMutexFair::try_lock() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> lock = state_.contextualLock();</span><br><span class="line">    <span class="comment">// 仅锁不被任何协程持有时可以加写锁</span></span><br><span class="line">    <span class="keyword">if</span> (lock-&gt;lockedFlagAndReaderCount_ == kUnlocked) &#123;</span><br><span class="line">      lock-&gt;lockedFlagAndReaderCount_ = kExclusiveLockFlag;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尝试获取读锁</span></span><br><span class="line">  <span class="keyword">bool</span> SharedMutexFair::try_lock_shared() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> lock = state_.contextualLock();</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    如果没人持有任何锁，或者有人持有读锁，但是没有正在等待的协程，则表示可以成功获取读锁，在lockedFlagAndReaderCount_增加计数</span></span><br><span class="line"><span class="comment">    由于1-63位表示读锁数量，因此一次加2。</span></span><br><span class="line"><span class="comment">    这里分析一下为啥大于读锁数量并且没有等待协程时可以加锁</span></span><br><span class="line"><span class="comment">    当读锁被别的协程持有时，获取写锁的协程一定时在等待队列中</span></span><br><span class="line"><span class="comment">    当lockedFlagAndReaderCount_ &gt; kSharedLockCountIncrement时，表示当前有协程持有读锁，正常来说可以直接加读锁即可</span></span><br><span class="line"><span class="comment">    但是如果一直优先读锁，将会导致写锁被饿死，永远无法被调度。</span></span><br><span class="line"><span class="comment">    因此这里先判断一下是否等待队列是否为空，如果不为空，则表示现在有协程在尝试获取写锁了，这时就不让再加读锁了，优先写锁。</span></span><br><span class="line"><span class="comment">    如果没有写锁请求，则可以直接加锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (lock-&gt;lockedFlagAndReaderCount_ == kUnlocked ||</span><br><span class="line">        (lock-&gt;lockedFlagAndReaderCount_ &gt;= kSharedLockCountIncrement &amp;&amp;</span><br><span class="line">         lock-&gt;waitersHead_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      lock-&gt;lockedFlagAndReaderCount_ += kSharedLockCountIncrement;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取写锁，需要用户自己释放</span></span><br><span class="line">  [[nodiscard]] LockOperation&lt;LockAwaiter&gt; co_lock() <span class="keyword">noexcept</span>;</span><br><span class="line">  <span class="comment">// 获取写锁，当返回值生命周期结束，自动释放锁</span></span><br><span class="line">  [[nodiscard]] LockOperation&lt;ScopedLockAwaiter&gt; co_scoped_lock() <span class="keyword">noexcept</span>;</span><br><span class="line">  <span class="comment">// 获取读锁，需要用户自己释放</span></span><br><span class="line">  [[nodiscard]] LockOperation&lt;LockSharedAwaiter&gt; co_lock_shared() <span class="keyword">noexcept</span>;</span><br><span class="line">  <span class="comment">// 获取读锁，当生命周期结束，自动释放</span></span><br><span class="line">  [[nodiscard]] LockOperation&lt;ScopedLockSharedAwaiter&gt;</span><br><span class="line">  co_scoped_lock_shared() <span class="keyword">noexcept</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放写死</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放读锁</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock_shared</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 标识锁状态</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">LockType</span> :</span> <span class="built_in">std</span>::<span class="keyword">uint8_t</span> &#123; EXCLUSIVE, SHARED &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    State() <span class="keyword">noexcept</span></span><br><span class="line">        : lockedFlagAndReaderCount_(kUnlocked),</span><br><span class="line">          waitersHead_(<span class="literal">nullptr</span>),</span><br><span class="line">          waitersTailNext_(&amp;waitersHead_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bit 0          - locked by writer</span></span><br><span class="line">    <span class="comment">// bits 1-[31/63] - reader lock count</span></span><br><span class="line">    <span class="comment">// 标识锁状态，第0位标识是否被被加了读锁，1-63位标识读锁数量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> lockedFlagAndReaderCount_;</span><br><span class="line">    <span class="comment">// 将等待锁的协程使用链表串连</span></span><br><span class="line">    LockAwaiterBase* waitersHead_;</span><br><span class="line">    LockAwaiterBase** waitersTailNext_;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 等待锁的协程awaiter</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LockAwaiterBase</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedMutexFair</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockAwaiterBase</span><span class="params">(SharedMutexFair&amp; mutex, LockType lockType)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">        : mutex_(&amp;mutex), nextAwaiter_(nullptr), lockType_(lockType) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; continuation_.resume(); &#125;</span><br><span class="line">		<span class="comment">// 等待的锁</span></span><br><span class="line">    SharedMutexFair* mutex_;</span><br><span class="line">    <span class="comment">// 执行下一个awaiter，串连成链表</span></span><br><span class="line">    LockAwaiterBase* nextAwaiter_;</span><br><span class="line">    <span class="comment">// 好像没用到</span></span><br><span class="line">    LockAwaiterBase* nextReader_;</span><br><span class="line">    <span class="comment">// 协程的coroutine_handle</span></span><br><span class="line">    coroutine_handle&lt;&gt; continuation_;</span><br><span class="line">    <span class="comment">// 需要获取锁类型</span></span><br><span class="line">    LockType lockType_;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  对awaiter提供viaIfAsync方法，由于在锁释放后会会串行执行一些列的协程resume，使用viaIfAsync提供异步支持，保证resume的协程都在原指定的线程池运行，并且是异步运行，避免所有阻塞的协程串行</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LockOperation</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    explicit LockOperation(SharedMutexFair&amp; mutex) noexcept : mutex_(mutex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">viaIfAsync</span><span class="params">(folly::Executor::KeepAlive&lt;&gt; executor)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> folly::coro::co_viaIfAsync(<span class="built_in">std</span>::move(executor), Awaiter&#123;mutex_&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    SharedMutexFair&amp; mutex_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kUnlocked = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kExclusiveLockFlag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kSharedLockCountIncrement = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  使用自旋锁的同步原语，当调用auto lock = state_.contextualLock()时，State被folly::SpinLock加锁保护</span></span><br><span class="line"><span class="comment">  当lock生命周期结束，自动释放锁</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  folly::Synchronized&lt;State, folly::SpinLock&gt; state_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个核心结构<code>folly::Synchronized&lt;State, folly::SpinLock&gt;</code>。这里不展开启实现细节，我们只需要知道其是同步原语即可，其持有一个<code>state</code>数据，访问其中数据都应该通过<code>auto lock = state_.contextualLock()</code>的<code>lock</code>访问，<code>state</code>里面的数据都可以通过<code>lock</code>利用<code>-&gt;</code>操作符直接访问到。调用<code>auto lock = state_.contextualLock()</code>时，不仅获取到了对应存储的数据，同时获取了对应的<code>folly::SpinLock</code>锁，即获取的数据被<code>folly::SpinLock</code>锁保护。这里使用的是folly实现的自旋锁，这里也不展开介绍了，其可以理解为就是linux提供的自旋锁。自旋锁理论上是更废cpu的，但是这里为什么要是有自旋锁呢。这就要考虑自旋锁使用的场景了，自旋锁一般用于预期很快就能获取到锁的场景，这样可以避免像互斥锁一样需要将线程先挂起，再恢复的操作。这正是协程调度时所需要的，由于线程池较少，一般不会有很多锁竞争，即使有锁竞争也应该很快会获取到锁，并且要避免执行协程的线程阻塞，因此这里选取的是自旋锁。</p>
<p>对于可自动释放的锁来说，其实现就比不自动释放的增加了在<code>await_resume</code>中返回自动释放的class，其他没啥区别。下面我们来依次介绍锁的获取与释放。</p>
<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> SharedMutexFair::LockOperation&lt;SharedMutexFair::LockSharedAwaiter&gt;</span><br><span class="line">SharedMutexFair::co_lock_shared() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> LockOperation&lt;LockSharedAwaiter&gt;&#123;*<span class="keyword">this</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>co_await co_lock_shared()</code>时，获取的<code>awaiter</code>是<code>LockSharedAwaiter</code>，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockSharedAwaiter</span> :</span> <span class="keyword">public</span> LockAwaiterBase &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockSharedAwaiter</span><span class="params">(SharedMutexFair&amp; mutex)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">        : LockAwaiterBase(mutex, LockType::SHARED) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> mutex_-&gt;try_lock_shared(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FOLLY_CORO_AWAIT_SUSPEND_NONTRIVIAL_ATTRIBUTES <span class="keyword">bool</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        coroutine_handle&lt;&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> lock = mutex_-&gt;state_.contextualLock();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// shared-lock can be acquired if it's either unlocked or it is</span></span><br><span class="line">      <span class="comment">// currently locked shared and there is no queued waiters.</span></span><br><span class="line">      <span class="keyword">if</span> (lock-&gt;lockedFlagAndReaderCount_ == kUnlocked ||</span><br><span class="line">          (lock-&gt;lockedFlagAndReaderCount_ != kExclusiveLockFlag &amp;&amp;</span><br><span class="line">           lock-&gt;waitersHead_ == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        lock-&gt;lockedFlagAndReaderCount_ += kSharedLockCountIncrement;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Lock not available immediately.</span></span><br><span class="line">      <span class="comment">// Queue up for later resumption.</span></span><br><span class="line">      continuation_ = continuation;</span><br><span class="line">      *lock-&gt;waitersTailNext_ = <span class="keyword">this</span>;</span><br><span class="line">      lock-&gt;waitersTailNext_ = &amp;nextAwaiter_;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>首先尝试获取读锁，如果获取成功，则继续执行协程。如果失败，则执行<code>await_suspend</code>。在<code>await_suspend</code>中，再次执行一次可以直接上锁的判断，如果可以上锁，则不suspend协程。否则，记录当前协程的<code>continuation_</code>，将当前协程加入到等待列表中。其中如下两句语句比较绕：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*lock-&gt;waitersTailNext_ = <span class="keyword">this</span>;</span><br><span class="line">lock-&gt;waitersTailNext_ = &amp;nextAwaiter_;</span><br></pre></td></tr></table></figure>
<p>第一句是把队尾的指针赋值为当前<code>awaiter</code>，关键是第二句，这里<code>waitersTailNext_</code>是一个双重指针，即<code>LockAwaiterBase**</code>这里将<code>waitersTailNext_</code>指向了当前awaiter的<code>nextAwaiter_</code>结构，则下次再向列表中添加元素时，执行的还是这两个语句，这时，第一条语句<code>*lock-&gt;waitersTailNext_ = this;</code>，就是将这一次的<code>nextAwaiter_</code>赋值为指向添加的<code>awaiter</code>。这样，每次对<code>*lock-&gt;waitersTailNext_</code>赋值，都是在对链表最后一个<code>awaiter</code>的<code>nextAwaiter_</code>赋值，以此达到串连所有<code>awaiter</code>的目的（妙啊）。这里还有个问题是起始指针，即<code>State</code>的<code>waitersHead_</code>变量，这就要再来看一下<code>State</code>的初始化了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">State() noexcept</span><br><span class="line">        : lockedFlagAndReaderCount_(kUnlocked),</span><br><span class="line">          waitersHead_(nullptr),</span><br><span class="line">          waitersTailNext_(&amp;waitersHead_) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>waitersTailNext_</code>初始化执行<code>waitersHead_</code>，则第一次执行<code>*lock-&gt;waitersTailNext_</code>就是对<code>waitersHead_</code>赋值（好家伙，指针是被他玩明白了）。</p>
<p>至此，完成了等待协程<code>awaiter</code>的串连。</p>
<p>将等待读锁添加到等待链表后，当写锁释放时会遍历链表，对等待的协程加读锁。</p>
<h3 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h3><p>释放读锁逻辑如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SharedMutexFair::unlock_shared() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  LockAwaiterBase* awaitersToResume = <span class="literal">nullptr</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取自旋锁</span></span><br><span class="line">    <span class="keyword">auto</span> lockedState = state_.contextualLock();</span><br><span class="line">    assert(lockedState-&gt;lockedFlagAndReaderCount_ &gt;= kSharedLockCountIncrement);</span><br><span class="line">    <span class="comment">// 计数-2，标记释放读锁</span></span><br><span class="line">    lockedState-&gt;lockedFlagAndReaderCount_ -= kSharedLockCountIncrement;</span><br><span class="line">    <span class="comment">// 如果还有锁在（这里一定是读锁），则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (lockedState-&gt;lockedFlagAndReaderCount_ != kUnlocked) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经没有锁了，则遍历等待队列，查询能够获得锁的协程，加锁</span></span><br><span class="line">    awaitersToResume = unlockOrGetNextWaitersToResume(*lockedState);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 唤醒协程</span></span><br><span class="line">  resumeWaiters(awaitersToResume);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的核心逻辑是<code>unlockOrGetNextWaitersToResume</code>函数，其作用是获取可以获得锁的列表，其逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SharedMutexFair::LockAwaiterBase*</span><br><span class="line">SharedMutexFair::unlockOrGetNextWaitersToResume(</span><br><span class="line">    SharedMutexFair::State&amp; state) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// 头指针指向等待队列头部</span></span><br><span class="line">  <span class="keyword">auto</span>* head = state.waitersHead_;</span><br><span class="line">  <span class="comment">// 不为空表示存在等等获取锁的协程</span></span><br><span class="line">  <span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果第一个是要获取写锁，则直接标记锁状态为写锁，让其获得写锁</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;lockType_ == LockType::EXCLUSIVE) &#123;</span><br><span class="line">      <span class="comment">// 让头指针指向之后的列表</span></span><br><span class="line">      state.waitersHead_ = <span class="built_in">std</span>::exchange(head-&gt;nextAwaiter_, <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="comment">// 标记状态为写锁被获取</span></span><br><span class="line">      state.lockedFlagAndReaderCount_ = kExclusiveLockFlag;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果第一个是读锁，则遍历出所有连续的读锁，加到队列中</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span> newState = kSharedLockCountIncrement;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Scan for a run of SHARED lock types.</span></span><br><span class="line">      <span class="keyword">auto</span>* last = head;</span><br><span class="line">      <span class="keyword">auto</span>* next = last-&gt;nextAwaiter_;</span><br><span class="line">      <span class="keyword">while</span> (next != <span class="literal">nullptr</span> &amp;&amp; next-&gt;lockType_ == LockType::SHARED) &#123;</span><br><span class="line">        last = next;</span><br><span class="line">        next = next-&gt;nextAwaiter_;</span><br><span class="line">        newState += kSharedLockCountIncrement;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 输出对了最后是nullpter</span></span><br><span class="line">      last-&gt;nextAwaiter_ = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="comment">// 标记获取了多少把读锁</span></span><br><span class="line">      state.lockedFlagAndReaderCount_ = newState;</span><br><span class="line">      <span class="comment">// 维持头指针指向最后不满足条件的awaiter，要么是写锁，要么是nullptr</span></span><br><span class="line">      state.waitersHead_ = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果最后是空，则要维持waitersTailNext_指向waitersHead_，保证添加时正常</span></span><br><span class="line">    <span class="keyword">if</span> (state.waitersHead_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      state.waitersTailNext_ = &amp;state.waitersHead_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果为空，表示当前不需要加锁，标记状态</span></span><br><span class="line">    state.lockedFlagAndReaderCount_ = kUnlocked;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其逻辑是按照等等的头部属性来拉取满足条件的<code>awaiter</code>，同时加锁。</p>
<p><code>resumeWaiters</code>逻辑较为简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SharedMutexFair::resumeWaiters(LockAwaiterBase* awaiters) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (awaiters != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::exchange(awaiters, awaiters-&gt;nextAwaiter_)-&gt;resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历获取的<code>awaiters</code>，<code>resume</code>即可。但这里有个问题，如果<code>resume</code>协程后，协程串行执行，将会导致效率低下，即使协程本身绑定了<code>executor</code>，也不能保证被挂起后执行依然是异步的，这时就需要使用<code>co_viaIfAsync</code>方法，即在调用<code>co_await</code>时，对<code>awaiter</code>增加一层<code>co_viaIfAsync</code>封装，这就保证协程始终时异步协程（如果<code>executor</code>不为空），并且是被执行在指定的线程池上。这也是为什么返回的<code>awaiter</code>都由<code>LockOperation</code>包一层，因为其定义了<code>viaIfAsync</code>方法。对于<code>task</code>来说，这些是不必要的，但是如果是自己定义的协程<code>promise_type</code>就需要注意，执行锁获取应该使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> folly::Executor::KeepAlive&lt;&gt; executor = co_await co_current_executor;</span><br><span class="line"><span class="keyword">auto</span> lock = co_await share_mutex_fair.co_scoped_lock_shared().viaIfAsync(executor);</span><br></pre></td></tr></table></figure>
<p>避免被唤醒的协程被串行执行。</p>
<h3 id="自动释放的读锁"><a href="#自动释放的读锁" class="headerlink" title="自动释放的读锁"></a>自动释放的读锁</h3><p>自动释放的读锁不需要用户显示调用<code>unlock_shared()</code>，在返回值的生命周期结束会自动释放，接口是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] LockOperation&lt;ScopedLockSharedAwaiter&gt;</span><br><span class="line"> co_scoped_lock_shared() <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<p>其中实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedLockSharedAwaiter</span> :</span> <span class="keyword">public</span> LockSharedAwaiter &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> LockSharedAwaiter::LockSharedAwaiter;</span><br><span class="line"></span><br><span class="line">  [[nodiscard]] SharedLock&lt;SharedMutexFair&gt; await_resume() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    LockSharedAwaiter::await_resume();</span><br><span class="line">    <span class="keyword">return</span> SharedLock&lt;SharedMutexFair&gt;&#123;*mutex_, <span class="built_in">std</span>::adopt_lock&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，其相对<code>LockSharedAwaiter</code>唯一区别是其增加了返回值，该返回值将<code>mutex_</code>包起来，在析构时，调用释放锁的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~SharedLock() &#123;</span><br><span class="line">  <span class="keyword">if</span> (locked_) &#123;</span><br><span class="line">    mutex_-&gt;unlock_shared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他与正常读锁没什么区别。</p>
<h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>介绍完了读锁，写锁就简单很多了。获取锁接口有两个，一个会自动释放，一个不会，这里只简单介绍不自动释放的。</p>
<p>获取写锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> SharedMutexFair::LockOperation&lt;SharedMutexFair::LockAwaiter&gt;</span><br><span class="line">SharedMutexFair::co_lock() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> LockOperation&lt;LockAwaiter&gt;&#123;*<span class="keyword">this</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockAwaiter</span> :</span> <span class="keyword">public</span> LockAwaiterBase &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockAwaiter</span><span class="params">(SharedMutexFair&amp; mutex)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      <span class="comment">// 标记为写锁</span></span></span><br><span class="line">        : LockAwaiterBase(mutex, LockType::EXCLUSIVE) &#123;&#125;</span><br><span class="line">    <span class="comment">// 尝试获取写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> mutex_-&gt;try_lock(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FOLLY_CORO_AWAIT_SUSPEND_NONTRIVIAL_ATTRIBUTES <span class="keyword">bool</span> <span class="title">await_suspend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        coroutine_handle&lt;&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> lock = mutex_-&gt;state_.contextualLock();</span><br><span class="line">      <span class="comment">// 再次判断是否可以加写锁</span></span><br><span class="line">      <span class="comment">// Exclusive lock can only be acquired if it's currently unlocked.</span></span><br><span class="line">      <span class="keyword">if</span> (lock-&gt;lockedFlagAndReaderCount_ == kUnlocked) &#123;</span><br><span class="line">        lock-&gt;lockedFlagAndReaderCount_ = kExclusiveLockFlag;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将当前的awaiter添加到链表末尾</span></span><br><span class="line">      <span class="comment">// Append to the end of the waiters queue.</span></span><br><span class="line">      continuation_ = continuation;</span><br><span class="line">      *lock-&gt;waitersTailNext_ = <span class="keyword">this</span>;</span><br><span class="line">      lock-&gt;waitersTailNext_ = &amp;nextAwaiter_;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>释放写锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SharedMutexFair::unlock() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  LockAwaiterBase* awaitersToResume = <span class="literal">nullptr</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> lockedState = state_.contextualLock();</span><br><span class="line">    assert(lockedState-&gt;lockedFlagAndReaderCount_ == kExclusiveLockFlag);</span><br><span class="line">    awaitersToResume = unlockOrGetNextWaitersToResume(*lockedState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resumeWaiters(awaitersToResume);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接获取可以添加的队列而没有标记<code>lockedFlagAndReaderCount_</code>为<code>kUnlocked</code>是因为<code>unlockOrGetNextWaitersToResume</code>实现时是直接对<code>unlockOrGetNextWaitersToResume</code>赋值的，而不是再远基础上加减，因此没有必要执行这一步。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/01/08/folly异步框架与DAG/" rel="next" title="folly中异步框架future与DAG">
                <i class="fa fa-chevron-left"></i> folly中异步框架future与DAG
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chst</p>
              <p class="site-description motion-element" itemprop="description">人生苦酒,自酿自品</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础背景"><span class="nav-number">1.</span> <span class="nav-text">基础背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Task使用"><span class="nav-number">2.</span> <span class="nav-text">Task使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TaskPromiseBase"><span class="nav-number">3.</span> <span class="nav-text">TaskPromiseBase</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ExtendedCoroutineHandle"><span class="nav-number">3.1.</span> <span class="nav-text">ExtendedCoroutineHandle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncStackFrame"><span class="nav-number">3.2.</span> <span class="nav-text">AsyncStackFrame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncStackRoot"><span class="nav-number">3.3.</span> <span class="nav-text">AsyncStackRoot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程栈与异步栈"><span class="nav-number">3.4.</span> <span class="nav-text">线程栈与异步栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pushAsyncStackFrameCallerCallee"><span class="nav-number">3.4.1.</span> <span class="nav-text">pushAsyncStackFrameCallerCallee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#popAsyncStackFrameCallee"><span class="nav-number">3.4.2.</span> <span class="nav-text">popAsyncStackFrameCallee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ScopedAsyncStackRoot"><span class="nav-number">3.4.3.</span> <span class="nav-text">ScopedAsyncStackRoot</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CancellationToken"><span class="nav-number">3.5.</span> <span class="nav-text">CancellationToken</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配Coroutine-state"><span class="nav-number">3.6.</span> <span class="nav-text">分配Coroutine state</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒加载"><span class="nav-number">3.7.</span> <span class="nav-text">懒加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#co-await时获取awaitable和awaiter"><span class="nav-number">3.8.</span> <span class="nav-text">co_await时获取awaitable和awaiter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#co-withCancellation"><span class="nav-number">3.8.1.</span> <span class="nav-text">co_withCancellation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#co-viaIfAsync"><span class="nav-number">3.8.2.</span> <span class="nav-text">co_viaIfAsync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#co-withAsyncStack"><span class="nav-number">3.8.3.</span> <span class="nav-text">co_withAsyncStack</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对awaiter的处理"><span class="nav-number">3.9.</span> <span class="nav-text">对awaiter的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程结束"><span class="nav-number">3.10.</span> <span class="nav-text">协程结束</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TaskPromise"><span class="nav-number">4.</span> <span class="nav-text">TaskPromise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Task"><span class="nav-number">5.</span> <span class="nav-text">Task</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TaskWithExecutor"><span class="nav-number">6.</span> <span class="nav-text">TaskWithExecutor</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#等待协程执行结束"><span class="nav-number">7.</span> <span class="nav-text">等待协程执行结束</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#clollectAll"><span class="nav-number">8.</span> <span class="nav-text">clollectAll</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Barrier"><span class="nav-number">8.1.</span> <span class="nav-text">Barrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BarrierTask"><span class="nav-number">8.2.</span> <span class="nav-text">BarrierTask</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#promise-amp-future-amp-SharedPromise"><span class="nav-number">9.</span> <span class="nav-text">promise&amp;future&amp;SharedPromise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心点"><span class="nav-number">10.</span> <span class="nav-text">核心点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#避免阻塞"><span class="nav-number">11.</span> <span class="nav-text">避免阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep"><span class="nav-number">11.1.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">11.2.</span> <span class="nav-text">IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁"><span class="nav-number">11.3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁"><span class="nav-number">11.3.1.</span> <span class="nav-text">读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放读锁"><span class="nav-number">11.3.2.</span> <span class="nav-text">释放读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动释放的读锁"><span class="nav-number">11.3.3.</span> <span class="nav-text">自动释放的读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写锁"><span class="nav-number">11.3.4.</span> <span class="nav-text">写锁</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chst</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="/js/src/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '0j9TGrGA2Aq8e4SO1sUkgQCv-gzGzoHsz',
        appKey: 'Q6jotQjlp43pwpkFCJhQ9s95',
        placeholder: '请留下联系方式，我会尽快回复',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  


  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
