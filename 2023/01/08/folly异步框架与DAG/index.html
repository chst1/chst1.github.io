<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="folly,">










<meta name="description" content="深入学习了一下folly的异步框架future和基于该异步框架实现的DAG调度，只是说是叹为观止，十分优雅。">
<meta name="keywords" content="folly">
<meta property="og:type" content="article">
<meta property="og:title" content="folly中异步框架future与DAG">
<meta property="og:url" content="http://yoursite.com/2023/01/08/folly异步框架与DAG/index.html">
<meta property="og:site_name" content="chst&#39;s Blog">
<meta property="og:description" content="深入学习了一下folly的异步框架future和基于该异步框架实现的DAG调度，只是说是叹为观止，十分优雅。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2023-01-08T15:00:13.684Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="folly中异步框架future与DAG">
<meta name="twitter:description" content="深入学习了一下folly的异步框架future和基于该异步框架实现的DAG调度，只是说是叹为观止，十分优雅。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2023/01/08/folly异步框架与DAG/">





  <title>folly中异步框架future与DAG | chst's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chst's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人网站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/01/08/folly异步框架与DAG/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">folly中异步框架future与DAG</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-01-08T16:23:18+08:00">
                2023-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DAG/" itemprop="url" rel="index">
                    <span itemprop="name">DAG</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2023/01/08/folly异步框架与DAG/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2023/01/08/folly异步框架与DAG/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  
                </span>
              
            </div>
          

          
              <div class="post-description">
                  深入学习了一下folly的异步框架future和基于该异步框架实现的DAG调度，只是说是叹为观止，十分优雅。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="DAG设计"><a href="#DAG设计" class="headerlink" title="DAG设计"></a>DAG设计</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>DAG将执行流程构建一个单向无环图，其中每个点表示一个逻辑执行单元，有向边表示逻辑单元的依赖关系，其中入节点依赖出节点的执行结果。对于个人节点来说，所有执行其的节点（对该节点来说是入节点）执行完成后立即执行该节点。</p>
<p>对于无依赖关系可以同步执行的节点来说，使用线程池来统一并发执行，通过图编排尽可能的保证执行的高效性。</p>
<p>同时由于存再依赖关系，所已需要考虑某个节点其执行错误时，依赖其结果的所有节点处理逻辑，folly中使用的方式是当任意一个节点失败时，依赖其结果的节点都停止执行。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>对于所有依赖节点执行完成才能执行当前节点的实现首先想到的是屏障或者条件变量，但是folly都未使用，而是使用了更为优雅的方式：智能指针（原子变量），通过依赖的节点每个持有一个智能指针的拷贝，当依赖节点执行完成时会释放该智能指针，当所以智能指针都被释放时将执行析构函数，在析构函数中将执行当前节点（并非立即执行，而是放到线程池中）。</p>
<p>对于节点并发执行来说，每个节点可指定使用的线程池，当某个节点未指定使用的线程池将使用其依赖节点的线程池（依赖的最后执行完成的那个节点）。</p>
<p>在执行开始和完成都有两个单独节点，其中开始节点是第一层节点的依赖，由于设置触发，对于最后一个节点则是依赖所有的最后一层节点，用于监控所有节点执行完成。</p>
<h1 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h1><p>待补充，可看folly源码中test部分。</p>
<h1 id="源码代码解析"><a href="#源码代码解析" class="headerlink" title="源码代码解析"></a>源码代码解析</h1><p>这里对folly的DAG源码进行详细阅读。要学习DAG，首先要学习folly的future，其类似std提供的future，但是更加灵活。future的基类是core，我们先来了解一下core相关内容。</p>
<h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>core对应于文件<code>folly/futures/detail/Core.h</code>其包含了如下内容<code>State</code>,<code>Spin Lock</code>，<code>DeferredExecutor</code>，<code>KeepAliveOrDeferred</code>，<code>InterruptHandler</code>，<code>CoreBase</code>，<code>Core</code>。</p>
<p>其中core的核心是一个FSM即有限状态机。其状态流转如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">///   +----------------------------------------------------------------+</span><br><span class="line">///   |                       ---&gt; OnlyResult -----                    |</span><br><span class="line">///   |                     /                       \                  |</span><br><span class="line">///   |                  (setResult())             (setCallback())     |</span><br><span class="line">///   |                   /                           \                |</span><br><span class="line">///   |   Start ---------&gt;                              ------&gt; Done   |</span><br><span class="line">///   |     \             \                           /                |</span><br><span class="line">///   |      \           (setCallback())           (setResult())       |</span><br><span class="line">///   |       \             \                       /                  |</span><br><span class="line">///   |        \              ---&gt; OnlyCallback ---                    |</span><br><span class="line">///   |         \           or OnlyCallbackAllowInline                 |</span><br><span class="line">///   |          \                                  \                  |</span><br><span class="line">///   |      (setProxy())                          (setProxy())        |</span><br><span class="line">///   |            \                                  \                |</span><br><span class="line">///   |             \                                   ------&gt; Empty  |</span><br><span class="line">///   |              \                                /                |</span><br><span class="line">///   |               \                            (setCallback())     |</span><br><span class="line">///   |                \                            /                  |</span><br><span class="line">///   |                  --------&gt; Proxy ----------                    |</span><br><span class="line">///   +----------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>本文介绍中暂不考虑<code>setProxy()</code>这条支路。</p>
<p>这里需要对一些名称进行一个定义：</p>
<ol>
<li>result：即结果，一个Try类型数据，包含一个T类型数据或者一个exception。对于链式控制来说（使用then）上一个的结果会作为下一个的输出，当设置当前的result即表示上一个执行单元完成处理，对于当前执行单元来说，执行完成的结果会被设置到下一个执行单元，以此来触发下一个执行单元的执行，以此达到链式的控制及数据传递。</li>
<li>callback：回调函数。当设置了result时会执行函数并为下一个执行单元设置result。</li>
<li>executor：执行器。执行callback的结构，也会作为参数传递到callback中，可以暂时理解为线程池。</li>
<li>consumer thread：消费线程，这里的消费线程时指消费整个future执行结果的线程（而不是消费任务的线程），其提供<code>callback</code>。</li>
<li>producer thread：生产者线程，这里指生成结果的线程（而不是生成任务的线程）。</li>
<li><code>interrupt</code>：exception_wrapper，表示异常结果。及try机制。</li>
<li>interrupt handler：出现异常时的执行函数。</li>
</ol>
<p>core持有三组数据，每组数据都是并发控制的：</p>
<ol>
<li>producer-to-consumer(生产者到消费者)的信息流：这组数据包含：<code>result</code>，<code>callback</code>，<code>executor</code>以及运行<code>callback</code>的·优先级。控制并发的方式是使用上图的FSM，其中有State表示状态，状态是原子的进行变更的。</li>
<li>consumer-to-producer(消费者到生产者)的请求干预：包含<code>interrupt-handler</code>和<code>interrupt</code>。通过<code>Spin Lock</code>控制并发。</li>
<li>生命周期控制：包含了两个引用计数，均为原子变量。</li>
</ol>
<p>这里为了区分生产者和消费者，并且为了方便使用，有两个结构共同维护该FSM（共用同一个core），分别是<code>future</code>和<code>promise</code>。其中<code>future</code>一般由消费者线程持有，消费者可以注册<code>callback</code>。<code>promise</code>一般由生产者线程持有，其接受上一层的<code>result</code>，执行<code>callback</code>，设置下一层的<code>result</code>。消费者持有的一般是下一层的<code>future</code>，当消费者判断持有的<code>future</code>已经设置了<code>result</code>则表示设置的<code>callback</code>已经执行完成。对于多层级执行链来说，处于中间的<code>future</code>和<code>promise</code>对用户来说均是不可见的，我们只能获取到最起点的<code>future</code>和<code>promise</code>，以及最后一个<code>future</code>。对于中间的<code>future</code>来说，其执行完成链路的构建就会被析构掉（由于不会被任何变量持有，生命周期结束），对于<code>promise</code>来说，会被生产者线程持有（准确的来说，其实不是被生产者线程持有，因为此时<code>callback</code>未被添加到生产者线程池中，其实际是被每个的上一层的<code>callback</code>持有），当最初的<code>promise</code>设置了<code>resul</code>t后，就会按照执行链路执行对应的<code>callback</code>。当每个<code>callback</code>执行完成时，会先设置下一个<code>promise</code>的<code>result</code>（此时就会触发下一层<code>callabck</code>执行），之后会执行自身<code>callback</code>的析构，此时就会析构<code>callback</code>持有的下一层的<code>promise</code>（在下一层开始执行<code>callback</code>时，会自己保证在执行完成<code>callback</code>前自生不被析构，因此不用担心此时<code>promise</code>被析构，同样在其执行完成<code>callback</code>再执行析构），通过这种方式达到链式执行效果。</p>
<p>上面介绍的可能相对较为复杂，很多概念还未提到，暂时可以先有一个大致的概念，不用现在就完全搞明白，后面会详细介绍。</p>
<p>为了实现上述功能，需要有很多基础的class，下面对这些class进行简单介绍。</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State相对较为简单，一个枚举类型来表示状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> :</span> <span class="keyword">uint8_t</span> &#123;</span><br><span class="line">  Start = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">  OnlyResult = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  OnlyCallback = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  OnlyCallbackAllowInline = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">  Proxy = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">  Done = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">  Empty = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> State <span class="keyword">operator</span>&amp;(State a, State b) &#123;</span><br><span class="line">  <span class="keyword">return</span> State(<span class="keyword">uint8_t</span>(a) &amp; <span class="keyword">uint8_t</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> State <span class="keyword">operator</span>|(State a, State b) &#123;</span><br><span class="line">  <span class="keyword">return</span> State(<span class="keyword">uint8_t</span>(a) | <span class="keyword">uint8_t</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> State <span class="keyword">operator</span>^(State a, State b) &#123;</span><br><span class="line">  <span class="keyword">return</span> State(<span class="keyword">uint8_t</span>(a) ^ <span class="keyword">uint8_t</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> State <span class="keyword">operator</span>~(State a) &#123;</span><br><span class="line">  <span class="keyword">return</span> State(~<span class="keyword">uint8_t</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不过多介绍。</p>
<h3 id="SpinLock"><a href="#SpinLock" class="headerlink" title="SpinLock"></a>SpinLock</h3><p><code>SpinLock</code>就是一个自己实现的自旋锁，这里可以将其当做一个简单的锁就好了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// SpinLock is and must stay a 1-byte object because of how Core is laid out.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpinLock</span> :</span> <span class="keyword">private</span> MicroSpinLock &#123;</span><br><span class="line">  SpinLock() : MicroSpinLock&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> MicroSpinLock::lock;</span><br><span class="line">  <span class="keyword">using</span> MicroSpinLock::unlock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(SpinLock) == <span class="number">1</span>, <span class="string">"missized"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="DeferredExecutor"><a href="#DeferredExecutor" class="headerlink" title="DeferredExecutor"></a>DeferredExecutor</h3><p><code>DeferredExecutor</code>延迟执行器。其主要功能是持有一个函数，但不立即执行，等待时机成熟（达到某种条件时才执行）。</p>
<p>该class使用场景似乎很特殊，目前没有看到应用场景，读者可暂时忽略该部分（或者有大佬知道怎么用，辛苦不吝赐教）。</p>
<p>其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeferredExecutor</span> <span class="title">final</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// addFrom will:</span></span><br><span class="line">  <span class="comment">//  * run func inline if there is a stored executor and completingKA matches</span></span><br><span class="line">  <span class="comment">//    the stored executor</span></span><br><span class="line">  <span class="comment">//  * enqueue func into the stored executor if one exists</span></span><br><span class="line">  <span class="comment">//  * store func until an executor is set otherwise</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果已经存再executor，并且executor与completingKA一致，则立即执行函数</span></span><br><span class="line"><span class="comment">  如果已经存再executor，但不一致，则将函数添加到executor</span></span><br><span class="line"><span class="comment">  否则只存储func，直到设置了一个executor</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addFrom</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor::KeepAlive&lt;&gt;&amp;&amp; completingKA,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor::KeepAlive&lt;&gt;::KeepAliveFunc func)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Executor* <span class="title">getExecutor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果func为空，则只设置executor，否则将func添加进入executor，并设置executor</span></span><br><span class="line"><span class="comment">  递归的对所有nestedExecutors_中元素执行相同操作。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(folly::Executor::KeepAlive&lt;&gt; executor)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setNestedExecutors</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DeferredWrapper&gt; executors)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">DeferredWrapper <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> DeferredWrapper <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueDeleter</span>;</span></span><br><span class="line"></span><br><span class="line">  DeferredExecutor();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span> EMPTY, HAS_FUNCTION, HAS_EXECUTOR, DETACHED &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;State&gt; state_&#123;State::EMPTY&#125;;</span><br><span class="line">  Executor::KeepAlive&lt;&gt;::KeepAliveFunc func_;</span><br><span class="line">  folly::Executor::KeepAlive&lt;&gt; executor_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DeferredWrapper&gt;&gt; nestedExecutors_;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">ssize_t</span>&gt; keepAliveCount_&#123;<span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueDeleter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(DeferredExecutor* ptr)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> DeferredWrapper = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DeferredExecutor, UniqueDeleter&gt;;</span><br></pre></td></tr></table></figure>
<p>其中<code>Executor::KeepAlive</code>就是folly自己实现的对<code>Executor</code>封装的安全指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecutorKeepAliveBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//  A dummy keep-alive is a keep-alive to an executor which does not support</span></span><br><span class="line">  <span class="comment">//  the keep-alive mechanism.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uintptr_t</span> kDummyFlag = <span class="keyword">uintptr_t</span>(<span class="number">1</span>) &lt;&lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  An alias keep-alive is a keep-alive to an executor to which there is</span></span><br><span class="line">  <span class="comment">//  known to be another keep-alive whose lifetime surrounds the lifetime of</span></span><br><span class="line">  <span class="comment">//  the alias.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uintptr_t</span> kAliasFlag = <span class="keyword">uintptr_t</span>(<span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uintptr_t</span> kFlagMask = kDummyFlag | kAliasFlag;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uintptr_t</span> kExecutorMask = ~kFlagMask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutorT = Executor&gt;</span><br><span class="line">  class KeepAlive : <span class="keyword">private</span> detail::ExecutorKeepAliveBase;</span><br></pre></td></tr></table></figure>
<p><code>KeepAlive</code>利用指针最后两位一定是0的特性，使用最好两位来做标识。<code>kDummyFlag</code>表示假的<code>keep-alive</code>，<code>kAliasFlag</code>标识当前的<code>Executor</code>是一个别名·。</p>
<p><code>KeepAlive</code>封装的<code>ExecutorT</code>，正常都需要继承<code>Executor</code>，其提供了三个接口：<code>keepAliveAcquire</code>和<code>keepAliveRelease</code>，在两个接口用于提供引用计数计算的，默认返回值为false，表示不支持引用计数，此时的<code>KeepAlive</code>是一个假的支持<code>keep-alive</code>，此时执行copy操作时，直接返回<code>ExecutorT</code>的地址（加上kDummyFlag），如果继承<code>Executor</code>的类实现了上述两个接口，则<code>copy</code>返回指针（加上kAliasFlag）的同时，会增加引用计数。另一个接口时线程池都需要有的接口<code>add</code>，即向其中添加task任务，默认的函数时立即执行函数。</p>
<h3 id="KeepAliveOrDeferred"><a href="#KeepAliveOrDeferred" class="headerlink" title="KeepAliveOrDeferred"></a>KeepAliveOrDeferred</h3><p><code>KeepAliveOrDeferred</code>是一个折叠类型，包含一个<code>Executor::KeepAlive</code>或者<code>DeferredWrapper</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrapper type that represents either a KeepAlive or a DeferredExecutor.</span></span><br><span class="line"><span class="comment"> * Acts as if a type-safe tagged union of the two using knowledge that the two</span></span><br><span class="line"><span class="comment"> * can safely be distinguished.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepAliveOrDeferred</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> KA = Executor::KeepAlive&lt;&gt;;</span><br><span class="line">  <span class="keyword">using</span> DW = DeferredWrapper;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  KeepAliveOrDeferred() <span class="keyword">noexcept</span>;</span><br><span class="line">  <span class="comment">/* implicit */</span> KeepAliveOrDeferred(KA ka) <span class="keyword">noexcept</span>;</span><br><span class="line">  <span class="comment">/* implicit */</span> KeepAliveOrDeferred(DW deferred) <span class="keyword">noexcept</span>;</span><br><span class="line">  KeepAliveOrDeferred(KeepAliveOrDeferred&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">  ~KeepAliveOrDeferred();</span><br><span class="line"></span><br><span class="line">  KeepAliveOrDeferred&amp; <span class="keyword">operator</span>=(KeepAliveOrDeferred&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">DeferredExecutor* <span class="title">getDeferredExecutor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Executor* <span class="title">getKeepAliveExecutor</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">KA <span class="title">stealKeepAlive</span><span class="params">()</span> &amp;&amp; <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">DW <span class="title">stealDeferred</span><span class="params">()</span> &amp;&amp; <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isDeferred</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isKeepAlive</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">KeepAliveOrDeferred <span class="title">copy</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredExecutor</span>;</span></span><br><span class="line">  <span class="comment">// 枚举被折叠类型</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span> Deferred, KeepAlive &#125; state_;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DW deferred_;</span><br><span class="line">    KA keepAlive_;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断类型</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> KeepAliveOrDeferred::isDeferred() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> state_ == State::Deferred;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> KeepAliveOrDeferred::isKeepAlive() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> state_ == State::KeepAlive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们主要使用<code>Executor::KeepAlive&lt;&gt;</code>类型，可不考虑<code>DeferredExecutor</code>。</p>
<p>由于<code>KeepAlive</code>存再隐式构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* implicit */</span> KeepAlive(ExecutorT* executor) &#123;</span><br><span class="line">  *<span class="keyword">this</span> = getKeepAliveToken(executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutorT&gt;</span><br><span class="line"><span class="keyword">static</span> KeepAlive&lt;ExecutorT&gt; getKeepAliveToken(ExecutorT* executor) &#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(</span><br><span class="line">    <span class="built_in">std</span>::is_base_of&lt;Executor, ExecutorT&gt;::value,</span><br><span class="line">    <span class="string">"getKeepAliveToken only works for folly::Executor implementations."</span>);</span><br><span class="line">  <span class="keyword">if</span> (!executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  folly::Executor* executorPtr = executor;</span><br><span class="line">  <span class="keyword">if</span> (executorPtr-&gt;keepAliveAcquire()) &#123;</span><br><span class="line">    <span class="keyword">return</span> makeKeepAlive&lt;ExecutorT&gt;(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> makeKeepAliveDummy&lt;ExecutorT&gt;(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此对于使用的时候，如果一个函数参数要求是<code>KeepAlive</code>，但是传递的是一个<code>Executor</code>的指针时，默认都会转成<code>KeepAlive</code>。</p>
<p>而<code>KeepAliveOrDeferred</code>中又存再</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* implicit */</span> KeepAliveOrDeferred(KA ka) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<p>以<code>KeepAlive</code>作为参数的的隐式构造函数，因此当使用<code>Executor</code>的指针作为参数时，往往使用的是<code>KeepAliveOrDeferred</code>中的<code>KeepAlive</code>模式。这也是我前文所述主要使用的是<code>KeepAlive</code>的原因，后面可以看到在<code>feature</code>中参数均为<code>KeepAlive</code>，使用时经常会传递线程池指针，这种情况下，都是使用的上述内容。</p>
<h3 id="InterruptHandler-amp-InterruptHandlerImpl"><a href="#InterruptHandler-amp-InterruptHandlerImpl" class="headerlink" title="InterruptHandler&amp;InterruptHandlerImpl"></a>InterruptHandler&amp;InterruptHandlerImpl</h3><p>这两个类提供了异常处理机制，都比较简单，这里不做详细介绍。主要包括三部分，引用计数，异常处理函数，异常类（folly::exception_wrapper），其中folly::exception_wrapper相对复杂，这里不展开介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class InterruptHandler &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual ~InterruptHandler();</span><br><span class="line"></span><br><span class="line">  virtual void handle(const folly::exception_wrapper&amp; ew) const = 0;</span><br><span class="line"></span><br><span class="line">  void acquire();</span><br><span class="line">  void release();</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  std::atomic&lt;ssize_t&gt; refCount_&#123;1&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class F&gt;</span><br><span class="line">class InterruptHandlerImpl final : public InterruptHandler &#123;</span><br><span class="line"> public:</span><br><span class="line">  template &lt;typename R&gt;</span><br><span class="line">  explicit InterruptHandlerImpl(R&amp;&amp; f) noexcept(</span><br><span class="line">      noexcept(F(static_cast&lt;R&amp;&amp;&gt;(f))))</span><br><span class="line">      : f_(static_cast&lt;R&amp;&amp;&gt;(f)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  void handle(const folly::exception_wrapper&amp; ew) const override &#123; f_(ew); &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  F f_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="CoreBase"><a href="#CoreBase" class="headerlink" title="CoreBase"></a>CoreBase</h3><p><code>CoreBase</code>是核心类，其维护了之前介绍了数据流转和FSM。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// context用于传递请求相关信息，主要是架构使用，用户可不关心，future中会详细介绍</span></span><br><span class="line">  <span class="keyword">using</span> Context = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;RequestContext&gt;;</span><br><span class="line">  <span class="comment">// Callback函数包含线程池和异常，线程池主要用于链式传递</span></span><br><span class="line">  <span class="keyword">using</span> Callback = folly::Function&lt;<span class="keyword">void</span>(</span><br><span class="line">      CoreBase&amp;, Executor::KeepAlive&lt;&gt;&amp;&amp;, exception_wrapper* ew)&gt;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// CoreBase不可拷贝和移动</span></span><br><span class="line">  <span class="comment">// not copyable</span></span><br><span class="line">  CoreBase(CoreBase <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CoreBase&amp; <span class="keyword">operator</span>=(CoreBase <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// not movable (see comment in the implementation of Future::then)</span></span><br><span class="line">  CoreBase(CoreBase&amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">delete</span>;</span><br><span class="line">  CoreBase&amp; <span class="keyword">operator</span>=(CoreBase&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// May call from any thread</span></span><br><span class="line">  <span class="comment">// 判断是否设置了callback，消费者和生产者线程均可能调用</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCallback</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> allowed = State::OnlyCallback |</span><br><span class="line">        State::OnlyCallbackAllowInline | State::Done | State::Empty;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> state = state_.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">    <span class="keyword">return</span> State() != (state &amp; allowed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// May call from any thread</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// True if state is OnlyResult or Done.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Identical to `this-&gt;ready()`</span></span><br><span class="line">  <span class="comment">// 判断是否已经有result了，所有线程均有可能调用，和this-&gt;ready()一致。</span></span><br><span class="line">  <span class="comment">// 设置了result和done均返回成功</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasResult</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// May call from any thread</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// True if state is OnlyResult or Done.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Identical to `this-&gt;hasResult()`</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> hasResult(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// // 消费者线程调用，如果引用计数为0，执行析构函数</span></span><br><span class="line">  <span class="comment">/// Called by a destructing Future (in the consumer thread, by definition).</span></span><br><span class="line">  <span class="comment">/// Calls `delete this` if there are no more references to `this`</span></span><br><span class="line">  <span class="comment">/// (including if `detachPromise()` is called previously or concurrently).</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detachFuture</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; detachOne(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产者线程调用，如果引用计数为0，执行析构函数</span></span><br><span class="line">  <span class="comment">/// Called by a destructing Promise (in the producer thread, by definition).</span></span><br><span class="line">  <span class="comment">/// Calls `delete this` if there are no more references to `this`</span></span><br><span class="line">  <span class="comment">/// (including if `detachFuture()` is called previously or concurrently).</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detachPromise</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    DCHECK(hasResult());</span><br><span class="line">    detachOne();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 消费者线程调用，调用要么在设置一个callback之前，要么在callback已经执行完成后。</span></span><br><span class="line">  <span class="comment">// 不能和任意可能导致callback被执行的操作并发</span></span><br><span class="line">  <span class="comment">// 这里也是上面说的，参数是`KeepAliveOrDeferred`，目前看到的基本都是KeepAlive</span></span><br><span class="line">  <span class="comment">/// Call only from consumer thread, either before attaching a callback or</span></span><br><span class="line">  <span class="comment">/// after the callback has already been invoked, but not concurrently with</span></span><br><span class="line">  <span class="comment">/// anything which might trigger invocation of the callback.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(KeepAliveOrDeferred&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    DCHECK(</span><br><span class="line">        state_ != State::OnlyCallback &amp;&amp;</span><br><span class="line">        state_ != State::OnlyCallbackAllowInline);</span><br><span class="line">    executor_ = <span class="built_in">std</span>::move(x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取线程池</span></span><br><span class="line">  <span class="function">Executor* <span class="title">getExecutor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">DeferredExecutor* <span class="title">getDeferredExecutor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">DeferredWrapper <span class="title">stealDeferredExecutor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 消费者抛出一个异常，如果已经有异常处理函数了，则立即执行异常处理函数</span></span><br><span class="line">  <span class="comment">/// Call only from consumer thread</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Eventual effect is to pass `e` to the Promise's interrupt handler, either</span></span><br><span class="line">  <span class="comment">/// synchronously within this call or asynchronously within</span></span><br><span class="line">  <span class="comment">/// `setInterruptHandler()`, depending on which happens first (a coin-toss if</span></span><br><span class="line">  <span class="comment">/// the two calls are racing).</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Has no effect if it was called previously.</span></span><br><span class="line">  <span class="comment">/// Has no effect if State is OnlyResult or Done.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">raise</span><span class="params">(exception_wrapper e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新的corebase，使用旧的interrupt handler来初始化自己的interrupt handler</span></span><br><span class="line">  <span class="comment">/// Copy the interrupt handler from another core. This should be done only</span></span><br><span class="line">  <span class="comment">/// when initializing a new core:</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - interruptHandler_ must be nullptr</span></span><br><span class="line">  <span class="comment">/// - interruptLock_ is not acquired.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initCopyInterruptHandlerFrom</span><span class="params">(<span class="keyword">const</span> CoreBase&amp; other)</span></span>;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 生产者线程调用，设置一个异常处理函数，如果有异常了，则立即执行异常处理函数</span></span><br><span class="line">  <span class="comment">/// Call only from producer thread</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// May invoke `fn()` (passing the interrupt) synchronously within this call</span></span><br><span class="line">  <span class="comment">/// (if `raise()` preceded or perhaps if `raise()` is called concurrently).</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Has no effect if State is OnlyResult or Done.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Note: `fn()` must not touch resources that are destroyed immediately after</span></span><br><span class="line">  <span class="comment">///   `setResult()` is called. Reason: it is possible for `fn()` to get called</span></span><br><span class="line">  <span class="comment">///   asynchronously (in the consumer thread) after the producer thread calls</span></span><br><span class="line">  <span class="comment">///   `setResult()`.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setInterruptHandler</span><span class="params">(F&amp;&amp; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> handler_type = InterruptHandlerImpl&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;F&gt;&gt;;</span><br><span class="line">    <span class="keyword">if</span> (hasResult()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    handler_type* handler = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> interrupt = interrupt_.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">    <span class="keyword">switch</span> (interrupt &amp; InterruptMask) &#123;</span><br><span class="line">      <span class="keyword">case</span> InterruptInitial: &#123; <span class="comment">// store the handler</span></span><br><span class="line">        assert(!interrupt);</span><br><span class="line">        handler = <span class="keyword">new</span> handler_type(<span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(fn));</span><br><span class="line">        <span class="keyword">auto</span> exchanged = folly::atomic_compare_exchange_strong_explicit(</span><br><span class="line">            &amp;interrupt_,</span><br><span class="line">            &amp;interrupt,</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(handler) | InterruptHasHandler,</span><br><span class="line">            <span class="built_in">std</span>::memory_order_release,</span><br><span class="line">            <span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> (exchanged) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lost the race!</span></span><br><span class="line">        <span class="keyword">if</span> (interrupt &amp; InterruptHasHandler) &#123;</span><br><span class="line">          terminate_with&lt;<span class="built_in">std</span>::logic_error&gt;(<span class="string">"set-interrupt-handler race"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        assert(interrupt &amp; InterruptHasObject);</span><br><span class="line">        FOLLY_FALLTHROUGH;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> InterruptHasObject: &#123; <span class="comment">// invoke over the stored object</span></span><br><span class="line">        <span class="keyword">auto</span> exchanged = interrupt_.compare_exchange_strong(</span><br><span class="line">            interrupt, InterruptTerminal, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (!exchanged) &#123;</span><br><span class="line">          terminate_with&lt;<span class="built_in">std</span>::logic_error&gt;(<span class="string">"set-interrupt-handler race"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> pointer = interrupt &amp; ~InterruptMask;</span><br><span class="line">        <span class="keyword">auto</span> object = <span class="keyword">reinterpret_cast</span>&lt;exception_wrapper*&gt;(pointer);</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">          handler-&gt;handle(*object);</span><br><span class="line">          <span class="keyword">delete</span> handler;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// mimic constructing and invoking a handler: 1 copy; non-const invoke</span></span><br><span class="line">          <span class="keyword">auto</span> fn_ = <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(fn);</span><br><span class="line">          fn_(as_const(*object));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> object;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> InterruptHasHandler: <span class="comment">// fail all calls after the first</span></span><br><span class="line">        terminate_with&lt;<span class="built_in">std</span>::logic_error&gt;(<span class="string">"set-interrupt-handler duplicate"</span>);</span><br><span class="line">      <span class="keyword">case</span> InterruptTerminal: <span class="comment">// fail all calls after the first</span></span><br><span class="line">        terminate_with&lt;<span class="built_in">std</span>::logic_error&gt;(<span class="string">"set-interrupt-handler after done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  CoreBase(State state, <span class="keyword">unsigned</span> <span class="keyword">char</span> attached);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~CoreBase();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Helper class that stores a pointer to the `Core` object and calls</span></span><br><span class="line">  <span class="comment">// `derefCallback` and `detachOne` in the destructor.</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CoreAndCallbackReference</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// interrupt_ is an atomic acyclic finite state machine with guarded state</span></span><br><span class="line">  <span class="comment">// which takes the form of either a pointer to a copy of the object passed to</span></span><br><span class="line">  <span class="comment">// raise or a pointer to a copy of the handler passed to setInterruptHandler</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the object and the handler values are both at least pointer-aligned so they</span></span><br><span class="line">  <span class="comment">// leave the bottom 2 bits free on all supported platforms; these bits are</span></span><br><span class="line">  <span class="comment">// stolen for the state machine</span></span><br><span class="line">  <span class="keyword">enum</span> : <span class="keyword">uintptr_t</span> &#123;</span><br><span class="line">    InterruptMask = <span class="number">0x3</span>u,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">enum</span> InterruptState : <span class="keyword">uintptr_t</span> &#123;</span><br><span class="line">    InterruptInitial = <span class="number">0x0</span>u,</span><br><span class="line">    InterruptHasHandler = <span class="number">0x1</span>u,</span><br><span class="line">    InterruptHasObject = <span class="number">0x2</span>u,</span><br><span class="line">    InterruptTerminal = <span class="number">0x3</span>u,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果状态为start，则变更到OnlyCallback | OnlyCallbackAllowInline</span></span><br><span class="line"><span class="comment">  如果状态为OnlyResult，则立即执行doCallback，变更到Done</span></span><br><span class="line"><span class="comment">  其中allowInline控制是否立即执行callback，及切换状态为OnlyCallbackAllowInline还是OnlyCallback</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setCallback_</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Callback&amp;&amp; callback,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;folly::RequestContext&gt;&amp;&amp; context,</span></span></span><br><span class="line"><span class="function"><span class="params">      futures::detail::InlineContinuation allowInline)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果是OnlyCallback || OnlyCallbackAllowInline，则变更为done 立即执行doCallback</span></span><br><span class="line"><span class="comment">  否则仅变更为OnlyResult</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setResult_</span><span class="params">(Executor::KeepAlive&lt;&gt;&amp;&amp; completingKA)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProxy_</span><span class="params">(CoreBase* proxy)</span></span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  将executor_替换为一个新的空的executor_（bool判断为false）</span></span><br><span class="line"><span class="comment">  如果此前未设置executor_，则立即执行callback_，传参this、completingKA、nullptr</span></span><br><span class="line"><span class="comment">  否则：</span></span><br><span class="line"><span class="comment">      如果状态不为OnlyCallbackAllowInline，则completingKA赋值为新创建的一个KeepAlive</span></span><br><span class="line"><span class="comment">      如果当前executor_为DeferredExecutor，使用completingKA和封装的callback_执行addFrom</span></span><br><span class="line"><span class="comment">      如果当前executor_为KeepAliveExecutor，同样判断executor_和completingKA是否一致，如果一致，则立即执行封装的callback_，</span></span><br><span class="line"><span class="comment">    否则将封装的callback_添加进入当前的executor_</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doCallback</span><span class="params">(Executor::KeepAlive&lt;&gt;&amp;&amp; completingKA, State priorState)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">proxyCallback</span><span class="params">(State priorState)</span></span>;</span><br><span class="line">  <span class="comment">// 执行core的析构，将attached_ -1， 如果将attached_ == 0时，析构this</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detachOne</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  执行context_&amp;callback_的析构，callbackReferences_ -1， </span></span><br><span class="line"><span class="comment">  如果callbackReferences_==0，执行context_&amp;callback_析构函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">derefCallback</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    Callback callback_;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;State&gt; state_;</span><br><span class="line">  <span class="comment">// 自生引用计数</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; attached_;</span><br><span class="line">  <span class="comment">// callback引用计数</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt; callbackReferences_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  KeepAliveOrDeferred executor_;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    Context context_;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">uintptr_t</span>&gt; interrupt_&#123;&#125;; <span class="comment">// see InterruptMask, InterruptState</span></span><br><span class="line">  CoreBase* proxy_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>setExecutor</code>使用参数是<code>KeepAliveOrDeferred</code>，也就是在上面介绍的，实际往往都是<code>keepalive</code>。</p>
<p>大部分情况下使用<code>corebase</code>时，会先提前设置一个<code>Executor</code>和设置<code>callback</code>，当设置<code>Result</code>时往往是链式请求中的上一个<code>future</code>，这时会将上一个执行的线程池传递过来，如果之前已经设置的线程池和传递的线程池不一致，则使用旧版的线程池（优先用户设置的，传过来的是架构透传的，后面讲到<code>future</code>的then会详细介绍）。</p>
<p>对于执行方式有两种类型，一个是立即执行，另一种是放到线程池中等待调度执行。当<code>setResult_</code>（如果已经设置了<code>callback</code>，将调用<code>doCallback</code>）时，之前未设置线程池，则认为是在原线程池中立即执行，所以直接执行<code>callback</code>。当此前已经设置了线程池时，则可以通过<code>state</code>是<code>OnlyCallbackAllowInline</code>还是<code>OnlyCallback</code>，对于前者来说，表示立即执行<code>callback</code>，对后者来说，则表示将<code>callback</code>添加到线程池中，等待线程池调度。</p>
<p><a id="RequestContext">RequestContext</a>：其中<code>context_</code>是线程维度数据，其实现为一个线程维度单例（使用static thread local），用于传递一些线程数据。一个比较常见使用场景是，对于一个线程执行的任务，向该结构内增加数据，当出问题，确定是哪个请求导致的。</p>
<p>有了上面介绍，我们来详细看一下<code>doCallback</code>函数实现<a id="doCallback">doCallback</a>“：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// May be called at most once.</span></span><br><span class="line"><span class="keyword">void</span> CoreBase::doCallback(</span><br><span class="line">    Executor::KeepAlive&lt;&gt;&amp;&amp; completingKA, State priorState) &#123;</span><br><span class="line">  DCHECK(state_ == State::Done);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> executor = <span class="built_in">std</span>::exchange(executor_, KeepAliveOrDeferred&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Customise inline behaviour</span></span><br><span class="line">  <span class="comment">// If addCompletingKA is non-null, then we are allowing inline execution</span></span><br><span class="line">  <span class="keyword">auto</span> doAdd = [](Executor::KeepAlive&lt;&gt;&amp;&amp; addCompletingKA,</span><br><span class="line">                  KeepAliveOrDeferred&amp;&amp; currentExecutor,</span><br><span class="line">                  <span class="keyword">auto</span>&amp;&amp; keepAliveFunc) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> deferredExecutorPtr = currentExecutor.getDeferredExecutor()) &#123;</span><br><span class="line">      deferredExecutorPtr-&gt;addFrom(</span><br><span class="line">          <span class="built_in">std</span>::move(addCompletingKA), <span class="built_in">std</span>::move(keepAliveFunc));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If executors match call inline</span></span><br><span class="line">      <span class="keyword">auto</span> currentKeepAlive = <span class="built_in">std</span>::move(currentExecutor).stealKeepAlive();</span><br><span class="line">      <span class="keyword">if</span> (addCompletingKA.get() == currentKeepAlive.get()) &#123;</span><br><span class="line">        keepAliveFunc(<span class="built_in">std</span>::move(currentKeepAlive));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::move(currentKeepAlive).add(<span class="built_in">std</span>::move(keepAliveFunc));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (executor) &#123;</span><br><span class="line">    <span class="comment">// If we are not allowing inline, clear the completing KA to disallow</span></span><br><span class="line">    <span class="keyword">if</span> (!(priorState == State::OnlyCallbackAllowInline)) &#123;</span><br><span class="line">      completingKA = Executor::KeepAlive&lt;&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    exception_wrapper ew;</span><br><span class="line">    <span class="comment">// We need to reset `callback_` after it was executed (which can happen</span></span><br><span class="line">    <span class="comment">// through the executor or, if `Executor::add` throws, below). The</span></span><br><span class="line">    <span class="comment">// executor might discard the function without executing it (now or</span></span><br><span class="line">    <span class="comment">// later), in which case `callback_` also needs to be reset.</span></span><br><span class="line">    <span class="comment">// The `Core` has to be kept alive throughout that time, too. Hence we</span></span><br><span class="line">    <span class="comment">// increment `attached_` and `callbackReferences_` by two, and construct</span></span><br><span class="line">    <span class="comment">// exactly two `CoreAndCallbackReference` objects, which call</span></span><br><span class="line">    <span class="comment">// `derefCallback` and `detachOne` in their destructor. One will guard</span></span><br><span class="line">    <span class="comment">// this scope, the other one will guard the lambda passed to the executor.</span></span><br><span class="line">    attached_.fetch_add(<span class="number">2</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    callbackReferences_.fetch_add(<span class="number">2</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="function">CoreAndCallbackReference <span class="title">guard_local_scope</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">CoreAndCallbackReference <span class="title">guard_lambda</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doAdd(</span><br><span class="line">          <span class="built_in">std</span>::move(completingKA),</span><br><span class="line">          <span class="built_in">std</span>::move(executor),</span><br><span class="line">          [core_ref =</span><br><span class="line">               <span class="built_in">std</span>::move(guard_lambda)](Executor::KeepAlive&lt;&gt;&amp;&amp; ka) <span class="keyword">mutable</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> cr = <span class="built_in">std</span>::move(core_ref);</span><br><span class="line">            CoreBase* <span class="keyword">const</span> core = cr.getCore();</span><br><span class="line">            RequestContextScopeGuard rctx(<span class="built_in">std</span>::move(core-&gt;context_));</span><br><span class="line">            core-&gt;callback_(*core, <span class="built_in">std</span>::move(ka), <span class="literal">nullptr</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">      ew = exception_wrapper(<span class="built_in">std</span>::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ew) &#123;</span><br><span class="line">      <span class="function">RequestContextScopeGuard <span class="title">rctx</span><span class="params">(<span class="built_in">std</span>::move(context_))</span></span>;</span><br><span class="line">      callback_(*<span class="keyword">this</span>, Executor::KeepAlive&lt;&gt;&#123;&#125;, &amp;ew);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    attached_.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    SCOPE_EXIT &#123;</span><br><span class="line">      context_.~Context();</span><br><span class="line">      callback_.~Callback();</span><br><span class="line">      detachOne();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">RequestContextScopeGuard <span class="title">rctx</span><span class="params">(<span class="built_in">std</span>::move(context_))</span></span>;</span><br><span class="line">    callback_(*<span class="keyword">this</span>, <span class="built_in">std</span>::move(completingKA), <span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传参中<code>completingKA</code>有两种情况：</p>
<ol>
<li>如果是先设置的result，再设置的callback，则是新建的一个新的。</li>
<li>如果是先设置的callback，再设置的result，则大部分情况是上一个task任务执行时所使用的线程池。</li>
</ol>
<p>其中doAdd是实际执行callback的函数，参数中<code>addCompletingKA</code>是新传入的线程池，<code>currentExecutor</code>是旧版线程池，<code>keepAliveFunc</code>是又进过一层封装的callback。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> doAdd = [](Executor::KeepAlive&lt;&gt;&amp;&amp; addCompletingKA,</span><br><span class="line">                 KeepAliveOrDeferred&amp;&amp; currentExecutor,</span><br><span class="line">                 <span class="keyword">auto</span>&amp;&amp; keepAliveFunc) <span class="keyword">mutable</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">auto</span> deferredExecutorPtr = currentExecutor.getDeferredExecutor()) &#123;</span><br><span class="line">     deferredExecutorPtr-&gt;addFrom(</span><br><span class="line">         <span class="built_in">std</span>::move(addCompletingKA), <span class="built_in">std</span>::move(keepAliveFunc));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// If executors match call inline</span></span><br><span class="line">     <span class="keyword">auto</span> currentKeepAlive = <span class="built_in">std</span>::move(currentExecutor).stealKeepAlive();</span><br><span class="line">     <span class="keyword">if</span> (addCompletingKA.get() == currentKeepAlive.get()) &#123;</span><br><span class="line">       keepAliveFunc(<span class="built_in">std</span>::move(currentKeepAlive));</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">std</span>::move(currentKeepAlive).add(<span class="built_in">std</span>::move(keepAliveFunc));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>首先判断原线程池是否为defer线程池，这里一般不是，暂时不考虑。</p>
<p>对于均为keepalive线程池来说，判断新旧线程池是否一致，如果一致，则立即执行callback，否则将callback添加到线程池中。</p>
<p>如果之前存再线程池，执行逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(priorState == State::OnlyCallbackAllowInline)) &#123;</span><br><span class="line">    completingKA = Executor::KeepAlive&lt;&gt;&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  exception_wrapper ew;</span><br><span class="line">  <span class="comment">// We need to reset `callback_` after it was executed (which can happen</span></span><br><span class="line">  <span class="comment">// through the executor or, if `Executor::add` throws, below). The</span></span><br><span class="line">  <span class="comment">// executor might discard the function without executing it (now or</span></span><br><span class="line">  <span class="comment">// later), in which case `callback_` also needs to be reset.</span></span><br><span class="line">  <span class="comment">// The `Core` has to be kept alive throughout that time, too. Hence we</span></span><br><span class="line">  <span class="comment">// increment `attached_` and `callbackReferences_` by two, and construct</span></span><br><span class="line">  <span class="comment">// exactly two `CoreAndCallbackReference` objects, which call</span></span><br><span class="line">  <span class="comment">// `derefCallback` and `detachOne` in their destructor. One will guard</span></span><br><span class="line">  <span class="comment">// this scope, the other one will guard the lambda passed to the executor.</span></span><br><span class="line">  attached_.fetch_add(<span class="number">2</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  callbackReferences_.fetch_add(<span class="number">2</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="function">CoreAndCallbackReference <span class="title">guard_local_scope</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="function">CoreAndCallbackReference <span class="title">guard_lambda</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    doAdd(</span><br><span class="line">        <span class="built_in">std</span>::move(completingKA),</span><br><span class="line">        <span class="built_in">std</span>::move(executor),</span><br><span class="line">        [core_ref =</span><br><span class="line">             <span class="built_in">std</span>::move(guard_lambda)](Executor::KeepAlive&lt;&gt;&amp;&amp; ka) <span class="keyword">mutable</span> &#123;</span><br><span class="line">          <span class="keyword">auto</span> cr = <span class="built_in">std</span>::move(core_ref);</span><br><span class="line">          CoreBase* <span class="keyword">const</span> core = cr.getCore();</span><br><span class="line">          RequestContextScopeGuard rctx(<span class="built_in">std</span>::move(core-&gt;context_));</span><br><span class="line">          core-&gt;callback_(*core, <span class="built_in">std</span>::move(ka), <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    ew = exception_wrapper(<span class="built_in">std</span>::current_exception());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ew) &#123;</span><br><span class="line">    <span class="function">RequestContextScopeGuard <span class="title">rctx</span><span class="params">(<span class="built_in">std</span>::move(context_))</span></span>;</span><br><span class="line">    callback_(*<span class="keyword">this</span>, Executor::KeepAlive&lt;&gt;&#123;&#125;, &amp;ew);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><a id="执行方式">执行方式</a>：如果不允许立即执行函数（即非OnlyCallbackAllowInline），则让新线程池变成一个空的线程池，这样保证不会和之前线程池一致，在doAdd时就不会立即执行callback了。</p>
<p>在介绍下面代码之前，先看一下<code>CoreAndCallbackReference</code>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreBase</span>:</span>:CoreAndCallbackReference &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  explicit CoreAndCallbackReference(CoreBase* core) noexcept : core_(core) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~CoreAndCallbackReference() <span class="keyword">noexcept</span> &#123; detach(); &#125;</span><br><span class="line"></span><br><span class="line">  CoreAndCallbackReference(CoreAndCallbackReference <span class="keyword">const</span>&amp; o) = <span class="keyword">delete</span>;</span><br><span class="line">  CoreAndCallbackReference&amp; <span class="keyword">operator</span>=(CoreAndCallbackReference <span class="keyword">const</span>&amp; o) =</span><br><span class="line">      <span class="keyword">delete</span>;</span><br><span class="line">  CoreAndCallbackReference&amp; <span class="keyword">operator</span>=(CoreAndCallbackReference&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  CoreAndCallbackReference(CoreAndCallbackReference&amp;&amp; o) <span class="keyword">noexcept</span></span><br><span class="line">      : core_(<span class="built_in">std</span>::exchange(o.core_, <span class="literal">nullptr</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">CoreBase* <span class="title">getCore</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> core_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (core_) &#123;</span><br><span class="line">      core_-&gt;derefCallback();</span><br><span class="line">      core_-&gt;detachOne();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CoreBase* core_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实现相当简单，就是存储core，并且负责管理coar自身生命周期以及callback和context生命周期。利用变量作用域结束后调用析构函数保证执行core的<code>derefCallback</code>和<code>detachOne()</code>。</p>
<p>下面再来看接下来的四行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to reset `callback_` after it was executed (which can happen</span></span><br><span class="line">  <span class="comment">// through the executor or, if `Executor::add` throws, below). The</span></span><br><span class="line">  <span class="comment">// executor might discard the function without executing it (now or</span></span><br><span class="line">  <span class="comment">// later), in which case `callback_` also needs to be reset.</span></span><br><span class="line">  <span class="comment">// The `Core` has to be kept alive throughout that time, too. Hence we</span></span><br><span class="line">  <span class="comment">// increment `attached_` and `callbackReferences_` by two, and construct</span></span><br><span class="line">  <span class="comment">// exactly two `CoreAndCallbackReference` objects, which call</span></span><br><span class="line">  <span class="comment">// `derefCallback` and `detachOne` in their destructor. One will guard</span></span><br><span class="line">  <span class="comment">// this scope, the other one will guard the lambda passed to the executor.</span></span><br><span class="line">  attached_.fetch_add(<span class="number">2</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  callbackReferences_.fetch_add(<span class="number">2</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="function">CoreAndCallbackReference <span class="title">guard_local_scope</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="function">CoreAndCallbackReference <span class="title">guard_lambda</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中注释给了详细介绍。我们要在<code>callback_</code>执行结束时reset（这里应该是指要执行析构函数），<code>doAdd</code>执行后有可能会丢弃<code>callback_</code>，即使这种情况下，我们依然需要reset callback，因此需要有两个<code>CoreAndCallbackReference</code>来维护<code>callback_</code>的生命周期。而执行<code>keepAliveFunc</code>需要core，因此core也不能在执行doAdd（有可能只是将keepAliveFunc加到了线程池中而未执行）完成后就被析构，因此对core的生命周期监控也需要两个<code>CoreAndCallbackReference</code>，因此这里将core和callback的引用计数都先加2，使用两个<code>CoreAndCallbackReference</code>来对core和callback进行生命周期监控。</p>
<p>这里解释了此前说的，在执行<code>callback</code>执行时会自己维护FSM，保证自己不被析构（在执行callback时，future和promise可能都已经被析构了，当callback执行完成后core被析构）。</p>
<p><a id="异常处理">异常处理</a>：如果执行doAdd抛出异常，则使用该异常执行callback，因此callback应该有对异常处理的能力。目前异常处理不需要通过函数中判断参数是否存再异常，这一步由future架构实现了，目前实现异常处理可以通过<code>thenError</code>来实现，这部分在future中将详细介绍。</p>
<p>当此前未设置线程池时，其处理相对简单，先注册执行完成的析构方法，用于析构<code>callback_</code>，而后立即执行callback。</p>
<p>这里关于<code>core</code>的生命周期还有两个重要函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Called by a destructing Future (in the consumer thread, by definition).</span></span><br><span class="line"> <span class="comment">/// Calls `delete this` if there are no more references to `this`</span></span><br><span class="line"> <span class="comment">/// (including if `detachPromise()` is called previously or concurrently).</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">detachFuture</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; detachOne(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// Called by a destructing Promise (in the producer thread, by definition).</span></span><br><span class="line"> <span class="comment">/// Calls `delete this` if there are no more references to `this`</span></span><br><span class="line"> <span class="comment">/// (including if `detachFuture()` is called previously or concurrently).</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">detachPromise</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">   DCHECK(hasResult());</span><br><span class="line">   detachOne();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">void</span> CoreBase::detachOne() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">   <span class="keyword">auto</span> a = attached_.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">   assert(a &gt;= <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面说过，维护FSM有两个结构，future和promise，<code>detachFuture</code>和<code>detachPromise</code>分别对应于两个结构的析构函数。由于<code>future</code>析构时，可能什么也未操作（只设置了callback），因此可以直接尝试执行析构即可。而析构<code>promise</code>时，正常来说已经设置了<code>result</code>(上一层的promise设置的这一层的result)，因此这里先做了一个检查，如果未设置，打日志。</p>
<p>后面可以看到，正常创建一个空的core时，其引用计数就是2，表示会有两个结构持有，分别执行析构函数，最终来析构core。</p>
<h3 id="ResultHolder"><a href="#ResultHolder" class="headerlink" title="ResultHolder"></a>ResultHolder</h3><p><code>ResultHolder</code>用处存储<code>result</code>。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultHolder</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ResultHolder() &#123;&#125;</span><br><span class="line">  ~ResultHolder() &#123;&#125;</span><br><span class="line">  <span class="comment">// Using a separate base class allows us to control the placement of result_,</span></span><br><span class="line">  <span class="comment">// making sure that it's in the same cache line as the vtable pointer and the</span></span><br><span class="line">  <span class="comment">// callback_ (assuming it's small enough).</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    Try&lt;T&gt; result_;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>Try</code>存储一个<code>T</code>类型原始，或者一个<code>expection</code>或者未空，其中有枚举值标记其类型。</p>
<h3 id="core-1"><a href="#core-1" class="headerlink" title="core"></a>core</h3><p>core继承了corebase和resultholder，组成了FSM的原始。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="title">final</span> :</span> <span class="keyword">private</span> ResultHolder&lt;T&gt;, <span class="keyword">public</span> CoreBase &#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(</span><br><span class="line">      !<span class="built_in">std</span>::is_void&lt;T&gt;::value,</span><br><span class="line">      <span class="string">"void futures are not supported. Use Unit instead."</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Result = Try&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// State will be Start</span></span><br><span class="line">  <span class="comment">// 创建空的core，状态为start，core自生计数为2</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Core* <span class="title">make</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Core(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// State will be OnlyResult</span></span><br><span class="line">  <span class="comment">/// Result held will be move-constructed from `t`</span></span><br><span class="line">  <span class="comment">// 创建含有result的core，状态为OnlyResult，core自生计数为1</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Core* <span class="title">make</span><span class="params">(Try&lt;T&gt;&amp;&amp; t)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Core(<span class="built_in">std</span>::move(t)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// State will be OnlyResult</span></span><br><span class="line">  <span class="comment">/// Result held will be the `T` constructed from forwarded `args`</span></span><br><span class="line">  <span class="comment">// 创建含有result的core，状态为OnlyResult，core自生计数为1</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="keyword">static</span> Core&lt;T&gt;* make(<span class="keyword">in_place_t</span>, Args&amp;&amp;... args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Core&lt;T&gt;(in_place, <span class="keyword">static_cast</span>&lt;Args&amp;&amp;&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Call only from consumer thread (since the consumer thread can modify the</span></span><br><span class="line">  <span class="comment">///   referenced Try object; see non-const overloads of `future.result()`,</span></span><br><span class="line">  <span class="comment">///   etc., and certain Future-provided callbacks which move-out the result).</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Unconditionally returns a reference to the result.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// State dependent preconditions:</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - Start, OnlyCallback or OnlyCallbackAllowInline: Never safe - do not</span></span><br><span class="line">  <span class="comment">/// call. (Access in those states</span></span><br><span class="line">  <span class="comment">///   would be undefined behavior since the producer thread can, in those</span></span><br><span class="line">  <span class="comment">///   states, asynchronously set the referenced Try object.)</span></span><br><span class="line">  <span class="comment">/// - OnlyResult: Always safe. (Though the consumer thread should not use the</span></span><br><span class="line">  <span class="comment">///   returned reference after it attaches a callback unless it knows that</span></span><br><span class="line">  <span class="comment">///   the callback does not move-out the referenced result.)</span></span><br><span class="line">  <span class="comment">/// - Done: Safe but sometimes unusable. (Always returns a valid reference,</span></span><br><span class="line">  <span class="comment">///   but the referenced result may or may not have been modified, including</span></span><br><span class="line">  <span class="comment">///   possibly moved-out, depending on what the callback did; some but not</span></span><br><span class="line">  <span class="comment">///   all callbacks modify (possibly move-out) the result.)</span></span><br><span class="line">  <span class="comment">// 消费者线程调用，获取结果</span></span><br><span class="line">  Try&lt;T&gt;&amp; getTry() &#123;</span><br><span class="line">    DCHECK(hasResult());</span><br><span class="line">    <span class="keyword">auto</span> core = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (core-&gt;state_.load(<span class="built_in">std</span>::memory_order_relaxed) == State::Proxy) &#123;</span><br><span class="line">      core = <span class="keyword">static_cast</span>&lt;Core*&gt;(core-&gt;proxy_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> core-&gt;result_;</span><br><span class="line">  &#125;</span><br><span class="line">  Try&lt;T&gt; <span class="function"><span class="keyword">const</span>&amp; <span class="title">getTry</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    DCHECK(hasResult());</span><br><span class="line">    <span class="keyword">auto</span> core = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (core-&gt;state_.load(<span class="built_in">std</span>::memory_order_relaxed) == State::Proxy) &#123;</span><br><span class="line">      core = <span class="keyword">static_cast</span>&lt;Core <span class="keyword">const</span>*&gt;(core-&gt;proxy_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> core-&gt;result_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Call only from consumer thread.</span></span><br><span class="line">  <span class="comment">/// Call only once - else undefined behavior.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// See FSM graph for allowed transitions.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// If it transitions to Done, synchronously initiates a call to the callback,</span></span><br><span class="line">  <span class="comment">/// and might also synchronously execute that callback (e.g., if there is no</span></span><br><span class="line">  <span class="comment">/// executor or if the executor is inline).</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">setCallback</span>(</span></span><br><span class="line"><span class="class">      <span class="title">F</span>&amp;&amp; <span class="title">func</span>,</span></span><br><span class="line"><span class="class">      <span class="title">std</span>:</span>:<span class="built_in">shared_ptr</span>&lt;folly::RequestContext&gt;&amp;&amp; context,</span><br><span class="line">      futures::detail::InlineContinuation allowInline) &#123;</span><br><span class="line">    Callback callback = [func = <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                            CoreBase&amp; coreBase,</span><br><span class="line">                            Executor::KeepAlive&lt;&gt;&amp;&amp; ka,</span><br><span class="line">                            exception_wrapper* ew) <span class="keyword">mutable</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; core = <span class="keyword">static_cast</span>&lt;Core&amp;&gt;(coreBase);</span><br><span class="line">      <span class="keyword">if</span> (ew != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        core.result_ = Try&lt;T&gt;&#123;<span class="built_in">std</span>::move(*ew)&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      func(<span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(core.result_));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    setCallback_(<span class="built_in">std</span>::move(callback), <span class="built_in">std</span>::move(context), allowInline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Call only from producer thread.</span></span><br><span class="line">  <span class="comment">/// Call only once - else undefined behavior.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// See FSM graph for allowed transitions.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// If it transitions to Done, synchronously initiates a call to the callback,</span></span><br><span class="line">  <span class="comment">/// and might also synchronously execute that callback (e.g., if there is no</span></span><br><span class="line">  <span class="comment">/// executor or if the executor is inline).</span></span><br><span class="line">  <span class="comment">// 生产者线程调用，设置结果</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Try&lt;T&gt;&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    setResult(Executor::KeepAlive&lt;&gt;&#123;&#125;, <span class="built_in">std</span>::move(t));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Call only from producer thread.</span></span><br><span class="line">  <span class="comment">/// Call only once - else undefined behavior.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// See FSM graph for allowed transitions.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// If it transitions to Done, synchronously initiates a call to the callback,</span></span><br><span class="line">  <span class="comment">/// and might also synchronously execute that callback (e.g., if there is no</span></span><br><span class="line">  <span class="comment">/// executor, if the executor is inline or if completingKA represents the</span></span><br><span class="line">  <span class="comment">/// same executor as does executor_).</span></span><br><span class="line">  <span class="comment">// 生产者线程调用，设置结果，其中completingKA用于控制链式执行使用的线程池</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Executor::KeepAlive&lt;&gt;&amp;&amp; completingKA, Try&lt;T&gt;&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    ::<span class="keyword">new</span> (&amp;<span class="keyword">this</span>-&gt;result_) Result(<span class="built_in">std</span>::move(t));</span><br><span class="line">    setResult_(<span class="built_in">std</span>::move(completingKA));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Call only from producer thread.</span></span><br><span class="line">  <span class="comment">/// Call only once - else undefined behavior.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// See FSM graph for allowed transitions.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This can not be called concurrently with setResult().</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProxy</span><span class="params">(Core* proxy)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> We could just expose this from the base, but that accepts any</span></span><br><span class="line">    <span class="comment">// CoreBase, while we want to enforce the same Core&lt;T&gt; in the interface.</span></span><br><span class="line">    setProxy_(proxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Core() : CoreBase(State::Start, <span class="number">2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  explicit Core(Try&lt;T&gt;&amp;&amp; t) : CoreBase(State::OnlyResult, 1) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;<span class="keyword">this</span>-&gt;result_) Result(<span class="built_in">std</span>::move(t));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Core</span><span class="params">(<span class="keyword">in_place_t</span>, Args&amp;&amp;... args)</span> <span class="title">noexcept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="built_in">std</span>::is_nothrow_constructible&lt;T, Args&amp;&amp;...&gt;::value)</span></span></span><br><span class="line">      : CoreBase(State::OnlyResult, 1) &#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;<span class="keyword">this</span>-&gt;result_) Result(in_place, <span class="keyword">static_cast</span>&lt;Args&amp;&amp;&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 析构函数只负责处理result_，并不析构其他内容，包括callback和自生的引用计数</span></span><br><span class="line">  ~Core() override &#123;</span><br><span class="line">    DCHECK(attached_ == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> state = state_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">      <span class="keyword">case</span> State::OnlyResult:</span><br><span class="line">        FOLLY_FALLTHROUGH;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> State::Done:</span><br><span class="line">        <span class="keyword">this</span>-&gt;result_.~Result();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> State::Proxy:</span><br><span class="line">        proxy_-&gt;detachFuture();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> State::Empty:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> State::Start:</span><br><span class="line">      <span class="keyword">case</span> State::OnlyCallback:</span><br><span class="line">      <span class="keyword">case</span> State::OnlyCallbackAllowInline:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        terminate_with&lt;<span class="built_in">std</span>::logic_error&gt;(<span class="string">"~Core unexpected state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>core</code>相较<code>corebase</code>增加内容不多，主要看一下其<code>setCallback</code>，其主要对<code>fun</code>进行了一层封装，将对异常的处理进行了封装：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">void</span> <span class="title">setCallback</span>(</span></span><br><span class="line"><span class="class">     <span class="title">F</span>&amp;&amp; <span class="title">func</span>,</span></span><br><span class="line"><span class="class">     <span class="title">std</span>:</span>:<span class="built_in">shared_ptr</span>&lt;folly::RequestContext&gt;&amp;&amp; context,</span><br><span class="line">     futures::detail::InlineContinuation allowInline) &#123;</span><br><span class="line">   Callback callback = [func = <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                           CoreBase&amp; coreBase,</span><br><span class="line">                           Executor::KeepAlive&lt;&gt;&amp;&amp; ka,</span><br><span class="line">                           exception_wrapper* ew) <span class="keyword">mutable</span> &#123;</span><br><span class="line">     <span class="keyword">auto</span>&amp; core = <span class="keyword">static_cast</span>&lt;Core&amp;&gt;(coreBase);</span><br><span class="line">     <span class="keyword">if</span> (ew != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       core.result_ = Try&lt;T&gt;&#123;<span class="built_in">std</span>::move(*ew)&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     func(<span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(core.result_));</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   setCallback_(<span class="built_in">std</span>::move(callback), <span class="built_in">std</span>::move(context), allowInline);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当传递的异常不为空时，表示出现了异常，这时将会把异常添加到result中，此前说过<a href="#异常处理">异常处理</a>由folly架构完成，这里是其中实现的一部分。更多的部分则在future中介绍。这里可以回头看一下<code>doCallback</code>在遇到异常时的处理，会将异常作为参数传递到callback中执行。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此基本介绍完成了core的基本信息，对folly的异步框架的FSM进行了深入的了解，同时对future的链式执行有了初步认识。接下来会更加细致的介绍folly链式执行的实现原理及DAG的实现。</p>
<h2 id="future-amp-promise"><a href="#future-amp-promise" class="headerlink" title="future&amp;promise"></a>future&amp;promise</h2><p>由于future&amp;promise通过了大量接口，全部介绍比较啰嗦（很多很简单的接口），这里只介绍一些核心接口。</p>
<p>如上文所说folly&amp;promise沟通维护一个core结构，共同维护FSM。promise一般会由生产者线程持有，负载生产result，future有消费者线程持有（用户线程），负责添加callback并且控制执行流程，以及最终结果获取。</p>
<p>promise持有core（成员变量），并且可以通过promise获取到future。</p>
<h3 id="正常异步执行流程为"><a href="#正常异步执行流程为" class="headerlink" title="正常异步执行流程为"></a>正常异步执行流程为</h3><p>异步执行流程如下</p>
<ol>
<li>创建一个promise。</li>
<li>从promise中获取一个future，并将future给消费者线程。</li>
<li>用户向future中添加callback（同时可设置executor）。添加callback后会新建一个promise，并通过新的promise获取一个新的future。其中promise自生被生产者线程持有（上一层的callback持有，future的then将详细介绍）。future被返回给消费者线程。</li>
<li>如果返回的future也设置了callback，即链式设置callback，则继续执行第三步，直到不再添加callback为止。</li>
<li>用户设置最最初的promise的result，开启链式执行（这一步也可能是在第一个执行，这时创建的一般是future）。</li>
<li>链式执行中，当上一层执行了callback后，设置当前层promise的result，执行当前层级的callback，设置下一层的result。析构当前的promise。</li>
<li>如果没有下一层了，则用户通过future获取到结构。如果依然有下一层，则当前层的future已经被析构（构建完成多次执行链就已经被析构了），重复执行第七步。</li>
<li>通过最后一个返回的future，调用阻塞方法，等待所有callback执行完成（或出错）。</li>
</ol>
<p>对于一个简单代码实例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/futures/Future.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;folly/executors/ThreadedExecutor.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> folly;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do something with x</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"foo("</span> &lt;&lt; x &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do something with x</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"foo1("</span> &lt;&lt; x &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do something with x</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"foo2("</span> &lt;&lt; x &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  folly::ThreadedExecutor executor;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"making Promise"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  Promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">  Future&lt;<span class="keyword">int</span>&gt; f = p.getSemiFuture().via(&amp;executor);</span><br><span class="line">  <span class="keyword">auto</span> f2 = move(f)</span><br><span class="line">    					.thenValue(foo).via(&amp;executor)</span><br><span class="line">    					.thenValue(foo1).via(&amp;executor)</span><br><span class="line">    					.thenValue(foo2).via(&amp;executor)</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Future chain made"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... now perhaps in another event callback</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"fulfilling Promise"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  p.setValue(<span class="number">42</span>);</span><br><span class="line">  move(f2).get();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Promise fulfilled"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>下面我们就按照上面的步骤，进行介绍。</p>
<h3 id="创建promise"><a href="#创建promise" class="headerlink" title="创建promise"></a>创建promise</h3><p>一般创建promise使用默认构造函数，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Promise</span>&lt;T&gt;:</span>:Promise() : retrieved_(<span class="literal">false</span>), core_(Core::make()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中retrieved由于记录是否已经从当前的promise中获取到了future，该参数用于析构时判断。core_是core的引用。其中使用<code>make()</code>创建的core将有两个引用计数。</p>
<p>由于retrieved_用于析构，我们先来看一下Promise的析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Promise</span>&lt;T&gt;:</span>:~Promise() &#123;</span><br><span class="line">  detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Promise</span>&lt;T&gt;:</span>:detach() &#123;</span><br><span class="line">  <span class="keyword">if</span> (core_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!retrieved_) &#123;</span><br><span class="line">      core_-&gt;detachFuture();</span><br><span class="line">    &#125;</span><br><span class="line">    futures::detail::coreDetachPromiseMaybeWithResult(*core_);</span><br><span class="line">    core_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coreDetachPromiseMaybeWithResult</span><span class="params">(Core&lt;T&gt;&amp; core)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!core.hasResult()) &#123;</span><br><span class="line">    core.setResult(Try&lt;T&gt;(exception_wrapper(BrokenPromise(pretty_name&lt;T&gt;()))));</span><br><span class="line">  &#125;</span><br><span class="line">  core.detachPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，首先会判断是否存再core，之后，如果retrieved_未false，及还未从promise获取到future，则会执行对future的析构，否则仅执行promise析构（之间有一个处理异常的处理）。</p>
<p>这里主要作用是保证core被完整析构，如果还未创建future在，则future的引用计数也有promise释放，如果已经创建了future，则future的引用计数则有future自生释放。</p>
<p>这里我们再看一下future的析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">FutureBase</span>&lt;T&gt;:</span>:~FutureBase() &#123;</span><br><span class="line">  detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">FutureBase</span>&lt;T&gt;:</span>:detach() &#123;</span><br><span class="line">  <span class="keyword">if</span> (core_) &#123;</span><br><span class="line">    core_-&gt;detachFuture();</span><br><span class="line">    core_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>future继承自FutureBase。这里可以看到，future析构时会释放掉core的future的引用计数。</p>
<p>上面说的启动方式，是callback等待result，还有一种方式是result等待callback。这是创建方式一般是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future::makeFuture(T);</span><br><span class="line">future::makeFeature();</span><br></pre></td></tr></table></figure>
<p>其中<code>makeFeature()</code>等价调用<code>makeFeature(Unit{})</code>，<code>Unit</code>可以理解为void：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// In functional programming, the degenerate case is often called "unit". In</span></span><br><span class="line"><span class="comment">/// C++, "void" is often the best analogue. However, because of the syntactic</span></span><br><span class="line"><span class="comment">/// special-casing required for void, it is frequently a liability for template</span></span><br><span class="line"><span class="comment">/// metaprogramming. So, instead of writing specializations to handle cases like</span></span><br><span class="line"><span class="comment">/// SomeContainer&lt;void&gt;, a library author may instead rule that out and simply</span></span><br><span class="line"><span class="comment">/// have library users use SomeContainer&lt;Unit&gt;. Contained values may be ignored.</span></span><br><span class="line"><span class="comment">/// Much easier.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// "void" is the type that admits of no values at all. It is not possible to</span></span><br><span class="line"><span class="comment">/// construct a value of this type.</span></span><br><span class="line"><span class="comment">/// "unit" is the type that admits of precisely one unique value. It is</span></span><br><span class="line"><span class="comment">/// possible to construct a value of this type, but it is always the same value</span></span><br><span class="line"><span class="comment">/// every time, so it is uninteresting.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Unit</span> &#123;</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Unit&amp; <span class="comment">/*other*/</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Unit&amp; <span class="comment">/*other*/</span>) <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要用于对void的封装。</p>
<p>其中<code>makeFuture(t)</code>实现为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;T&gt; <span class="title">makeFuture</span>(<span class="title">Try</span>&lt;T&gt; <span class="title">t</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> Future&lt;T&gt;(Future&lt;T&gt;::Core::make(<span class="built_in">std</span>::move(t)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里由于已经设置了result，因此不需要promise，因此引用计数是1。</p>
<h3 id="从promise中获取future"><a href="#从promise中获取future" class="headerlink" title="从promise中获取future"></a>从promise中获取future</h3><p>promise可以获取future，有两种future，一个是<code>SemiFuture</code>，另一个是<code>future</code>。其中二者区别主要是在是否设置了<code>executor</code>。<code>SemiFuture</code>未设置<code>executor</code>，<code>SemiFuture</code>通过via设置<code>executor</code>后就变成了future。设置<code>executor</code>含义是指定callback在那个线程池中执行。</p>
<p>对应的两个方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">SemiFuture&lt;T&gt; Promise&lt;T&gt;::getSemiFuture() &#123;</span><br><span class="line">  if (retrieved_) &#123;</span><br><span class="line">    throw_exception&lt;FutureAlreadyRetrieved&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  retrieved_ = true;</span><br><span class="line">  return SemiFuture&lt;T&gt;(&amp;getCore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">Future&lt;T&gt; Promise&lt;T&gt;::getFuture() &#123;</span><br><span class="line">  // An InlineExecutor approximates the old behaviour of continuations</span><br><span class="line">  // running inine on setting the value of the promise.</span><br><span class="line">  return getSemiFuture().via(&amp;InlineExecutor::instance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会设置<code>retrieved_</code>为true，标识已经生成了future，避免重复析构。其中如果返回future，则会使用folly提供的默认executor。一般我们返回<code>SemiFuture</code>，由用户自定义<code>executor</code>。</p>
<h3 id="添加callback"><a href="#添加callback" class="headerlink" title="添加callback"></a>添加callback</h3><p>添加<code>callback</code>主要有四个方法，分别是<code>thenValue</code>，<code>thenTry</code>，<code>thenValueInline</code>，<code>thenTryInline</code>。其中<code>Value</code>和<code>try</code>主要区别是<code>callback</code>参数不同，value是普通类似，try是对value的封装，同时有可能是还有异常。<code>Inline</code>和非<code>inline</code>区别时设置callback时是允许立即执行，还是放到线程池中执行，可参考<a href="#执行方式">执行方式</a>。</p>
<p>其中四个函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename F&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;typename futures::detail::tryCallableResult&lt;T, F&gt;::value_type&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;T&gt;:</span>:thenTry(F&amp;&amp; func) &amp;&amp; &#123;</span><br><span class="line">  <span class="keyword">auto</span> lambdaFunc = [f = <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                        folly::Executor::KeepAlive&lt;&gt;&amp;&amp;,</span><br><span class="line">                        folly::Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(f)(<span class="built_in">std</span>::move(t));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> R = futures::detail::tryExecutorCallableResult&lt;T, <span class="keyword">decltype</span>(lambdaFunc)&gt;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;thenImplementation(</span><br><span class="line">      <span class="built_in">std</span>::move(lambdaFunc), R&#123;&#125;, futures::detail::InlineContinuation::forbid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename F&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;typename futures::detail::tryCallableResult&lt;T, F&gt;::value_type&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;T&gt;:</span>:thenTryInline(F&amp;&amp; func) &amp;&amp; &#123;</span><br><span class="line">  <span class="keyword">auto</span> lambdaFunc = [f = <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                        folly::Executor::KeepAlive&lt;&gt;&amp;&amp;,</span><br><span class="line">                        folly::Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(f)(<span class="built_in">std</span>::move(t));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> R = futures::detail::tryExecutorCallableResult&lt;T, <span class="keyword">decltype</span>(lambdaFunc)&gt;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;thenImplementation(</span><br><span class="line">      <span class="built_in">std</span>::move(lambdaFunc), R&#123;&#125;, futures::detail::InlineContinuation::permit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename F&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;typename futures::detail::valueCallableResult&lt;T, F&gt;::value_type&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;T&gt;:</span>:thenValue(F&amp;&amp; func) &amp;&amp; &#123;</span><br><span class="line">  <span class="keyword">auto</span> lambdaFunc = [f = <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                        Executor::KeepAlive&lt;&gt;&amp;&amp;, folly::Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> futures::detail::wrapInvoke(<span class="built_in">std</span>::move(t), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(f));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> R = futures::detail::tryExecutorCallableResult&lt;T, <span class="keyword">decltype</span>(lambdaFunc)&gt;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;thenImplementation(</span><br><span class="line">      <span class="built_in">std</span>::move(lambdaFunc), R&#123;&#125;, futures::detail::InlineContinuation::forbid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename F&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;typename futures::detail::valueCallableResult&lt;T, F&gt;::value_type&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;T&gt;:</span>:thenValueInline(F&amp;&amp; func) &amp;&amp; &#123;</span><br><span class="line">  <span class="keyword">auto</span> lambdaFunc = [f = <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                        Executor::KeepAlive&lt;&gt;&amp;&amp;, folly::Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> futures::detail::wrapInvoke(<span class="built_in">std</span>::move(t), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(f));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> R = futures::detail::tryExecutorCallableResult&lt;T, <span class="keyword">decltype</span>(lambdaFunc)&gt;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;thenImplementation(</span><br><span class="line">      <span class="built_in">std</span>::move(lambdaFunc), R&#123;&#125;, futures::detail::InlineContinuation::permit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先可以看到是否有<code>inline</code>，仅在调用<code>thenImplementation</code>时最后一个参数有<code>diff</code>。</p>
<p>对应<code>thenTry</code>来说，其封装的<code>lambdaFunc</code>直接执行<code>callback</code>，而对于<code>thenValue</code>来说，则是使用<code>futures::detail::wrapInvoke</code>又进行了一层封装。这是因为，在future框架代码执行过程中，数据交换都是通过<code>try</code>进行传递的，如果<code>callback</code>参数是try，则可以直接使用，如果参数是value，则需要从try中提取出value（如果有的话）。这也导致了异常处理的差异，对于使用<code>thenTry</code>来说，需要在处理函数内部判断是否有异常，并对异常进行处理，如果使用<code>thenValue</code>，则在出现异常时，不会调用对应的callback，当用户设置了<code>thenError</code>时，根据<code>thenError</code>匹配的错误类型进行执行对应的callback（这部分后面会详细介绍）。</p>
<p>我们看一下<code>futures::detail::wrapInvoke</code>的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">wrapInvoke</span><span class="params">(folly::Try&lt;T&gt;&amp;&amp; t, F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fn = [&amp;]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(f)(</span><br><span class="line">        t.<span class="keyword">template</span> get&lt;</span><br><span class="line">            <span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">typename</span> futures::detail::valueCallableResult&lt;T, F&gt;::FirstArg&gt;());</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">using</span> FnResult = <span class="keyword">decltype</span>(fn());</span><br><span class="line">  <span class="keyword">using</span> Wrapper = InvokeResultWrapper&lt;FnResult&gt;;</span><br><span class="line">  <span class="keyword">if</span> (t.hasException()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Wrapper::wrapException(<span class="built_in">std</span>::move(t).exception());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Wrapper::wrapResult(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fn</code>执行callback函数，参数为try中的value。</p>
<p>首先判断try中是是否有异常，如果有直接返回异常，如果没有，则返回<code>fn</code>执行结果。其中返回类型是callback的返回结果类型。可以大致看一下<code>InvokeResultWrapper</code>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InvokeResultWrapperBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> T <span class="title">wrapResult</span><span class="params">(F fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T(fn());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> T <span class="title">wrapException</span><span class="params">(exception_wrapper&amp;&amp; e)</span> </span>&#123; <span class="keyword">return</span> T(<span class="built_in">std</span>::move(e)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应返回类型为<code>void</code>，及callback未设置返回的来说，利用模板的偏特化，返回的类型是<code>Try&lt;Unit&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InvokeResultWrapper</span>&lt;void&gt; :</span> InvokeResultWrapperBase&lt;Try&lt;Unit&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">  <span class="keyword">static</span> Try&lt;Unit&gt; wrapResult(F fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="keyword">return</span> Try&lt;Unit&gt;(unit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述四个<code>then</code>方法中构建的<code>lambdaFunc</code>函数中，传递了参数<code>Executor::KeepAlive&lt;&gt;&amp;&amp;</code>，但是并未使用，这是由于除了上述方法，还有三个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">template &lt;typename R, typename Caller, typename... Args&gt;</span><br><span class="line">Future&lt;typename isFuture&lt;R&gt;::Inner&gt; Future&lt;T&gt;::then(</span><br><span class="line">    R (Caller::*func)(Args...), Caller* instance) &amp;&amp; &#123;</span><br><span class="line">  using FirstArg =</span><br><span class="line">      remove_cvref_t&lt;typename futures::detail::ArgType&lt;Args...&gt;::FirstArg&gt;;</span><br><span class="line"></span><br><span class="line">  return std::move(*this).thenTry([instance, func](Try&lt;T&gt;&amp;&amp; t) &#123;</span><br><span class="line">    return (instance-&gt;*func)(t.template get&lt;isTry&lt;FirstArg&gt;::value, Args&gt;()...);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">template &lt;typename F&gt;</span><br><span class="line">Future&lt;typename futures::detail::tryExecutorCallableResult&lt;T, F&gt;::value_type&gt;</span><br><span class="line">Future&lt;T&gt;::thenExTry(F&amp;&amp; func) &amp;&amp; &#123;</span><br><span class="line">  auto lambdaFunc = [f = static_cast&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                        Executor::KeepAlive&lt;&gt;&amp;&amp; ka, folly::Try&lt;T&gt;&amp;&amp; t) mutable &#123;</span><br><span class="line">    // Enforce that executor cannot be null</span><br><span class="line">    DCHECK(ka);</span><br><span class="line">    return static_cast&lt;F&amp;&amp;&gt;(f)(std::move(ka), std::move(t));</span><br><span class="line">  &#125;;</span><br><span class="line">  using R = futures::detail::tryExecutorCallableResult&lt;T, decltype(lambdaFunc)&gt;;</span><br><span class="line">  return this-&gt;thenImplementation(</span><br><span class="line">      std::move(lambdaFunc), R&#123;&#125;, futures::detail::InlineContinuation::forbid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">template &lt;typename F&gt;</span><br><span class="line">Future&lt;typename futures::detail::tryExecutorCallableResult&lt;T, F&gt;::value_type&gt;</span><br><span class="line">Future&lt;T&gt;::thenExTryInline(F&amp;&amp; func) &amp;&amp; &#123;</span><br><span class="line">  auto lambdaFunc = [f = static_cast&lt;F&amp;&amp;&gt;(func)](</span><br><span class="line">                        Executor::KeepAlive&lt;&gt;&amp;&amp; ka, folly::Try&lt;T&gt;&amp;&amp; t) mutable &#123;</span><br><span class="line">    // Enforce that executor cannot be null</span><br><span class="line">    DCHECK(ka);</span><br><span class="line">    return static_cast&lt;F&amp;&amp;&gt;(f)(std::move(ka), std::move(t));</span><br><span class="line">  &#125;;</span><br><span class="line">  using R = futures::detail::tryExecutorCallableResult&lt;T, decltype(lambdaFunc)&gt;;</span><br><span class="line">  return this-&gt;thenImplementation(</span><br><span class="line">      std::move(lambdaFunc), R&#123;&#125;, futures::detail::InlineContinuation::permit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>thenExTry</code>和<code>thenExTryInline</code>传递的<code>callback</code>会将<code>Executor::KeepAlive&lt;&gt;&amp;&amp;</code>作为参数传递，这三个方法均不常使用，这里不做过多介绍。</p>
<p>其中<code>R</code>是作为<code>callback</code>的辅助数据。这里不展开介绍。</p>
<p>对于<code>thenImplementation</code>来说，根据<code>callback</code>返回值类型不同，有两个重载：</p>
<ol>
<li>当返回普通类型时，执行callback返回结果时，直接设置下一层<code>promise</code>的result。</li>
<li>当返回类型为<code>future</code>时，执行完callback，替换下一层的<code>promise</code>的core到<code>callback</code>返回的future的core，同时将下一层的future中设置的callback传递给这一层返回的future，这样相当于在执行时，对返回的future进行了替换，替换为callback返回的future。</li>
</ol>
<p>下面针对上面两个类型的callback详细介绍。</p>
<h4 id="callback返回try"><a href="#callback返回try" class="headerlink" title="callback返回try"></a><code>callback</code>返回try</h4><p><code>callback</code>返回try类型的逻辑相对简单一些，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Variant: returns a value</span></span><br><span class="line"><span class="comment">// e.g. f.then([](Try&lt;T&gt;&amp;&amp; t)&#123; return t.value(); &#125;);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename F, typename R&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;!R::ReturnsFuture::value, <span class="keyword">typename</span> R::Return&gt;::type</span><br><span class="line">FutureBase&lt;T&gt;::thenImplementation(</span><br><span class="line">    F&amp;&amp; func, R, futures::detail::InlineContinuation allowInline) &#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(R::Arg::ArgsSize::value == <span class="number">2</span>, <span class="string">"Then must take two arguments"</span>);</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> R::ReturnsFuture::Inner B;</span><br><span class="line"></span><br><span class="line">  Promise&lt;B&gt; p;</span><br><span class="line">  <span class="comment">// 继承上一层的异常处理</span></span><br><span class="line">  p.core_-&gt;initCopyInterruptHandlerFrom(<span class="keyword">this</span>-&gt;getCore());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// grab the Future now before we lose our handle on the Promise</span></span><br><span class="line">  <span class="keyword">auto</span> sf = p.getSemiFuture();</span><br><span class="line">  <span class="comment">// 继承上一层的执行器</span></span><br><span class="line">  sf.setExecutor(folly::Executor::KeepAlive&lt;&gt;&#123;<span class="keyword">this</span>-&gt;getExecutor()&#125;);</span><br><span class="line">  <span class="keyword">auto</span> f = Future&lt;B&gt;(sf.core_);</span><br><span class="line">  <span class="comment">// 复制触发析构，置空</span></span><br><span class="line">  sf.core_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;setCallback_(</span><br><span class="line">      [state = futures::detail::makeCoreCallbackState(</span><br><span class="line">           <span class="built_in">std</span>::move(p), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func))](</span><br><span class="line">          Executor::KeepAlive&lt;&gt;&amp;&amp; ka, Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!R::Arg::isTry() &amp;&amp; t.hasException()) &#123;</span><br><span class="line">          state.setException(<span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(t.exception()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">auto</span> propagateKA = ka.copy();</span><br><span class="line">          state.setTry(<span class="built_in">std</span>::move(propagateKA), makeTryWith([&amp;] &#123;</span><br><span class="line">                         <span class="keyword">return</span> detail_msvc_15_7_workaround::invoke(</span><br><span class="line">                             R&#123;&#125;, state, <span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(t));</span><br><span class="line">                       &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      allowInline);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会新建一个<code>Promise</code>，作为下一层的FSM，其拷贝本层的异常处理函数。从新建的<code>promise</code>获取到一个future作为返回结果。其默认使用的执行器与本层的执行器一致。</p>
<p><code>setCallback_</code>对传递的<code>callback</code>又进行了一次封装。其中<code>futures::detail::makeCoreCallbackState</code>创建的结构为<code>CoreCallbackState</code>，其用于控制callback执行，其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Guarantees that the stored functor is destructed before the stored promise</span></span><br><span class="line"><span class="comment">//  may be fulfilled. Assumes the stored functor to be noexcept-destructible.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreCallbackState</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> DF = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;F&gt;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  CoreCallbackState(Promise&lt;T&gt;&amp;&amp; promise, F&amp;&amp; func) <span class="keyword">noexcept</span>(</span><br><span class="line">      <span class="keyword">noexcept</span>(DF(<span class="built_in">std</span>::declval&lt;F&amp;&amp;&gt;())))</span><br><span class="line">      : func_(<span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func)), promise_(<span class="built_in">std</span>::move(promise)) &#123;</span><br><span class="line">    assert(before_barrier());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CoreCallbackState(CoreCallbackState&amp;&amp; that) <span class="keyword">noexcept</span>(</span><br><span class="line">      <span class="keyword">noexcept</span>(DF(<span class="built_in">std</span>::declval&lt;F&amp;&amp;&gt;()))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (that.before_barrier()) &#123;</span><br><span class="line">      <span class="keyword">new</span> (&amp;func_) DF(<span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(that.func_));</span><br><span class="line">      promise_ = that.stealPromise();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CoreCallbackState&amp; <span class="keyword">operator</span>=(CoreCallbackState&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~CoreCallbackState() &#123;</span><br><span class="line">    <span class="keyword">if</span> (before_barrier()) &#123;</span><br><span class="line">      stealPromise();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">invoke</span><span class="params">(Args&amp;&amp;... args)</span> <span class="title">noexcept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">noexcept</span>(<span class="built_in">std</span>::declval&lt;F&amp;&amp;&gt;()(<span class="built_in">std</span>::declval&lt;Args&amp;&amp;&gt;()...)))</span> </span>&#123;</span><br><span class="line">    assert(before_barrier());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func_)(<span class="keyword">static_cast</span>&lt;Args&amp;&amp;&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">tryInvoke</span><span class="params">(Args&amp;&amp;... args)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> makeTryWith([&amp;] &#123; <span class="keyword">return</span> invoke(<span class="keyword">static_cast</span>&lt;Args&amp;&amp;&gt;(args)...); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setTry</span><span class="params">(Executor::KeepAlive&lt;&gt;&amp;&amp; keepAlive, Try&lt;T&gt;&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    stealPromise().setTry(<span class="built_in">std</span>::move(keepAlive), <span class="built_in">std</span>::move(t));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setException</span><span class="params">(Executor::KeepAlive&lt;&gt;&amp;&amp; keepAlive, exception_wrapper&amp;&amp; ew)</span> </span>&#123;</span><br><span class="line">    setTry(<span class="built_in">std</span>::move(keepAlive), Try&lt;T&gt;(<span class="built_in">std</span>::move(ew)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Promise&lt;T&gt; stealPromise() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    assert(before_barrier());</span><br><span class="line">    func_.~DF();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(promise_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">before_barrier</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> !promise_.isFulfilled(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DF func_;</span><br><span class="line">  &#125;;</span><br><span class="line">  Promise&lt;T&gt; promise_&#123;Promise&lt;T&gt;::makeEmpty()&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其持有一次<code>func</code>和一个<code>promise</code>，其中<code>func</code>是本层的<code>callback</code>，而<code>promise</code>是下一层的<code>promise</code>。</p>
<p><code>callback</code>函数使用move方法拷贝到<code>CoreCallbackState</code>中，因此其负责管理<code>callback</code>的生命周期。调用<code>stealPromise()</code>方法就会析构<code>callback</code>。</p>
<p><code>Invoke</code>方法用于实际执行<code>callback</code>，<code>setTry</code>和<code>setException</code>负责将<code>callback</code>结果传递到<code>promise</code>（下一层的FMS）。当设置的<code>promise</code>时，<code>promise</code>的<code>isFulfilled()</code>方法将会返回ture，通过该方式来控制析构<code>CoreCallbackState</code>不会double free <code>callback</code>。</p>
<p>下面来分析一下封装的<code>callback</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[state = futures::detail::makeCoreCallbackState(</span><br><span class="line">        <span class="built_in">std</span>::move(p), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func))](</span><br><span class="line">       Executor::KeepAlive&lt;&gt;&amp;&amp; ka, Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!R::Arg::isTry() &amp;&amp; t.hasException()) &#123;</span><br><span class="line">       state.setException(<span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(t.exception()));</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">auto</span> propagateKA = ka.copy();</span><br><span class="line">       state.setTry(<span class="built_in">std</span>::move(propagateKA), makeTryWith([&amp;] &#123;</span><br><span class="line">                      <span class="keyword">return</span> detail_msvc_15_7_workaround::invoke(</span><br><span class="line">                          R&#123;&#125;, state, <span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(t));</span><br><span class="line">                    &#125;));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>callback</code>参数为<code>Executor::KeepAlive&lt;&gt;</code>和<code>Try&lt;T&gt;</code>，其中前者用于传递执行器，后者是上一层的<code>promise</code>执行返回的结果。</p>
<p><a id="异常传递">异常传递</a>首先判断上一层结果是否方式异常，如果存再异常，则不在执行本层的<code>callback</code>，设置下一层结果为异常，这样如果下一层依然是这样的处理逻辑，则会一直往下一层设置结果为异常，直到设置到异常处理的<code>callback</code>，或者到最有一层，返回给用于。</p>
<p>如果未出现异常，则执行本层的<code>callback</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> State, <span class="keyword">typename</span> T, IfArgsSizeIs&lt;R, <span class="number">2</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) invoke(R, State&amp; state, Executor::KeepAlive&lt;&gt;&amp;&amp; ka, Try&lt;T&gt;&amp;&amp; t) &#123;</span><br><span class="line">  <span class="keyword">using</span> Arg1 = <span class="keyword">typename</span> R::Arg::ArgList::Tail::FirstArg;</span><br><span class="line">  <span class="keyword">return</span> state.invoke(</span><br><span class="line">      <span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(t).<span class="keyword">template</span> get&lt;R::Arg::isTry(), Arg1&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并将结果赋值到下一层的<code>promise</code>，这里设置的都是<code>Try</code>类型数据，但是由于上一层的封装中(<code>thenTry</code>,<code>thenValue</code>)会对类型进行一次转换，保证传递的参数是下一层·<code>callback</code>需要的参数·。</p>
<p>如果本层<code>callback</code>执行结果出现异常，则下一层如果是<code>then</code>类型的处理，则就会像上面介绍的一样进行<a href="#异常传递">异常传递</a>。如果下一层就是异常处理函数(<code>thenError</code>)则立即就执行异常处理了（相对于跳过的异常传递的传递部分）。</p>
<p>如果本层<code>callback</code>执行结果正常，则会在设置下一层<code>promise</code>时，立即开始执行下一层的<code>callback</code>，之后依次链式执行。</p>
<p>这里再来看一下<code>setCallback_</code>内容，其对传递的<code>callback</code>又进行了一层封装(无线套娃了属于是):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;class F&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">FutureBase</span>&lt;T&gt;:</span>:setCallback_(</span><br><span class="line">    F&amp;&amp; func, futures::detail::InlineContinuation allowInline) &#123;</span><br><span class="line">  throwIfContinued();</span><br><span class="line">  getCore().setCallback(</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func), RequestContext::saveContext(), allowInline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里封装较为简单，仅仅只是增加了一个<code>RequestContext</code>，这部分可以结合<a href="#RequestContext">RequestContext</a>阅读。</p>
<p>其中<code>RequestContext</code>是一个folly提供的线程维度全局单例(<code>thread local</code>)。其作用就是在线程之间传递数据。实现原理较为简单。当请求到来时，我们可以在请求处理的主线程中设置<code>RequestContext</code>，向其中添加数据。当我们在主线程之外使用别的线程池的时候，folly架构通过<code>RequestContext::saveContext()</code>方法获取到主线程的<code>RequestContext</code>数据。将该数据作为参数传递到异步线程要执行的函数中，这样在异步线程执行函数之前，通过<code>RequestContextScopeGuard</code>类，来将主线程的<code>RequestContext</code>数据拷贝到当前线程中，同时将自己的<code>RequestContext</code>存储起来，在<code>RequestContextScopeGuard</code>析构时，使用存储的<code>RequestContext</code>恢复自生的线程数据。以此导致数据屏蔽用户进行传递的作用。可以参考<a href="#doCallback">doCallback</a>中<code>doAdd</code>传递的<code>func</code>，其在执行<code>callback</code>时会先创建<code>RequestContextScopeGuard</code>，并将这里传递的<code>RequestContext::saveContext()</code>作为参数。</p>
<p>该数据的一个典型使用场景是日志打点，对于某个大型服务来说，经常出现<code>coredump</code>，但是这些数据往往是由于实验导致的（毕竟如果上线就有core就上不去了），这时我们可能需要有一个添加方式来确定是哪个实验导致的问题，这个时候就可以使用<code>RequestContext</code>。我们在请求构建时，将实验参数写到<code>RequestContext</code>中，这样就会在请求使用到的所有线程中都可以获取到该数据，当出现core时，使用core的信号处理还是将实验参数打印出来。这样就不需要在每次使用异步线程的时候手动传递该值了。</p>
<h4 id="callback返回future"><a href="#callback返回future" class="headerlink" title="callback返回future"></a><code>callback</code>返回future</h4><p>对于<code>callback</code>返回<code>future</code>的场景来说，较为复杂，其实现逻辑就是，在构建时返回的future将会被运行时返回的future隐式替换，这样原本等待返回的future被设置result变成了等待执行时返回的future被设置result，其实现通过此前未介绍的<code>Proxy</code>。下面来看一下具体代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Variant: returns a Future</span></span><br><span class="line"><span class="comment">// e.g. f.then([](T&amp;&amp; t)&#123; return makeFuture&lt;T&gt;(t); &#125;);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;typename F, typename R&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;R::ReturnsFuture::value, <span class="keyword">typename</span> R::Return&gt;::type</span><br><span class="line">FutureBase&lt;T&gt;::thenImplementation(</span><br><span class="line">    F&amp;&amp; func, R, futures::detail::InlineContinuation allowInline) &#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(R::Arg::ArgsSize::value == <span class="number">2</span>, <span class="string">"Then must take two arguments"</span>);</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> R::ReturnsFuture::Inner B;</span><br><span class="line"></span><br><span class="line">  Promise&lt;B&gt; p;</span><br><span class="line">  p.core_-&gt;initCopyInterruptHandlerFrom(<span class="keyword">this</span>-&gt;getCore());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// grab the Future now before we lose our handle on the Promise</span></span><br><span class="line">  <span class="keyword">auto</span> sf = p.getSemiFuture();</span><br><span class="line">  <span class="keyword">auto</span> e = getKeepAliveToken(<span class="keyword">this</span>-&gt;getExecutor());</span><br><span class="line">  sf.setExecutor(<span class="built_in">std</span>::move(e));</span><br><span class="line">  <span class="keyword">auto</span> f = Future&lt;B&gt;(sf.core_);</span><br><span class="line">  sf.core_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;setCallback_(</span><br><span class="line">      [state = futures::detail::makeCoreCallbackState(</span><br><span class="line">           <span class="built_in">std</span>::move(p), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func))](</span><br><span class="line">          Executor::KeepAlive&lt;&gt;&amp;&amp; ka, Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!R::Arg::isTry() &amp;&amp; t.hasException()) &#123;</span><br><span class="line">          state.setException(<span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(t.exception()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Ensure that if function returned a SemiFuture we correctly chain</span></span><br><span class="line">          <span class="comment">// potential deferral.</span></span><br><span class="line">          <span class="keyword">auto</span> tf2 = detail_msvc_15_7_workaround::tryInvoke(</span><br><span class="line">              R&#123;&#125;, state, ka.copy(), <span class="built_in">std</span>::move(t));</span><br><span class="line">          <span class="keyword">if</span> (tf2.hasException()) &#123;</span><br><span class="line">            state.setException(<span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(tf2.exception()));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> statePromise = state.stealPromise();</span><br><span class="line">            <span class="keyword">auto</span> tf3 = chainExecutor(<span class="built_in">std</span>::move(ka), *<span class="built_in">std</span>::move(tf2));</span><br><span class="line">            <span class="built_in">std</span>::exchange(statePromise.core_, <span class="literal">nullptr</span>)</span><br><span class="line">                -&gt;setProxy(<span class="built_in">std</span>::exchange(tf3.core_, <span class="literal">nullptr</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      allowInline);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应异常处理之前的部分和原来没有区别。当上一层执行未出异常时，首先执行本层的<code>callback</code>。如果本层<code>callback</code>出现异常，则进行与上一层出现异常一样的处理。未出异常时，获取到原本的下一层<code>promise</code>，将下一层的<code>promise</code>的core设置<code>Proxy</code>为返回的future的core。同时为了避免重复析构，将二者的core都设置为空值。</p>
<p>这里我们详细看一下<code>setProxy</code>执行逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CoreBase::setProxy_(CoreBase* proxy) &#123;</span><br><span class="line">  DCHECK(!hasResult());</span><br><span class="line"></span><br><span class="line">  proxy_ = proxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = state_.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> State::Start:</span><br><span class="line">      <span class="keyword">if</span> (folly::atomic_compare_exchange_strong_explicit(</span><br><span class="line">              &amp;state_,</span><br><span class="line">              &amp;state,</span><br><span class="line">              State::Proxy,</span><br><span class="line">              <span class="built_in">std</span>::memory_order_release,</span><br><span class="line">              <span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      assume(</span><br><span class="line">          state == State::OnlyCallback ||</span><br><span class="line">          state == State::OnlyCallbackAllowInline);</span><br><span class="line">      FOLLY_FALLTHROUGH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> State::OnlyCallback:</span><br><span class="line">    <span class="keyword">case</span> State::OnlyCallbackAllowInline:</span><br><span class="line">      proxyCallback(state);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> State::OnlyResult:</span><br><span class="line">    <span class="keyword">case</span> State::Proxy:</span><br><span class="line">    <span class="keyword">case</span> State::Done:</span><br><span class="line">    <span class="keyword">case</span> State::Empty:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      terminate_with&lt;<span class="built_in">std</span>::logic_error&gt;(<span class="string">"setCallback unexpected state"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  detachOne();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应原本返回的future后面有设置的链式处理来说，执行的是<code>proxyCallback</code>处理函数，其逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void CoreBase::proxyCallback(State priorState) &#123;</span><br><span class="line">  // If the state of the core being proxied had a callback that allows inline</span><br><span class="line">  // execution, maintain this information in the proxy</span><br><span class="line">  futures::detail::InlineContinuation allowInline =</span><br><span class="line">      (priorState == State::OnlyCallbackAllowInline</span><br><span class="line">           ? futures::detail::InlineContinuation::permit</span><br><span class="line">           : futures::detail::InlineContinuation::forbid);</span><br><span class="line">  state_.store(State::Empty, std::memory_order_relaxed);</span><br><span class="line">  proxy_-&gt;setExecutor(std::move(executor_));</span><br><span class="line">  proxy_-&gt;setCallback_(std::move(callback_), std::move(context_), allowInline);</span><br><span class="line">  proxy_-&gt;detachFuture();</span><br><span class="line">  context_.~Context();</span><br><span class="line">  callback_.~Callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其逻辑就是把当前core的所有信息都迁移到<code>proxy_</code>中，包括要执行的<code>callback_</code>。这样，对于原本需要等待原<code>promise</code>设置<code>result</code>才能执行的<code>callback</code>来说，变成了依赖<code>proxy_</code>对应的<code>promise</code>被设置<code>result</code>，这样就完成了运行时对原<code>future</code>依赖的替换(妙啊!!!)。</p>
<p>这时，其实原本的<code>promise</code>就没有作用了，使用的就是替换后的future对应的<code>promise</code>。</p>
<h3 id="callback设置线程池"><a href="#callback设置线程池" class="headerlink" title="callback设置线程池"></a><code>callback</code>设置线程池</h3><p>对于每个<code>callback</code>都可以设置对应的执行线程池，由于每个<code>callback</code>都有一个future持有，因此设置future使用的线程池即可。通过<code>via</code>方法设置，一般设置执行的线程池是在<code>SemiFuture</code>设置，较为简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;T&gt; <span class="title">SemiFuture</span>&lt;T&gt;:</span>:via(Executor::KeepAlive&lt;&gt; executor) &amp;&amp; &#123;</span><br><span class="line">  folly::async_tracing::logSemiFutureVia(<span class="keyword">this</span>-&gt;getExecutor(), executor.get());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!executor) &#123;</span><br><span class="line">    throw_exception&lt;FutureNoExecutor&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不考虑defer执行</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> deferredExecutor = <span class="keyword">this</span>-&gt;getDeferredExecutor()) &#123;</span><br><span class="line">    deferredExecutor-&gt;setExecutor(executor.copy());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> newFuture = Future&lt;T&gt;(<span class="keyword">this</span>-&gt;core_);</span><br><span class="line">  <span class="keyword">this</span>-&gt;core_ = <span class="literal">nullptr</span>;</span><br><span class="line">  newFuture.setExecutor(<span class="built_in">std</span>::move(executor));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="等待执行结束"><a href="#等待执行结束" class="headerlink" title="等待执行结束"></a>等待执行结束</h3><p>对应异步来说，最终用户拿到一个<code>future</code>，我们需要在合适的时候等待异步的结束，调用<code>get</code>方法获取执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">SemiFuture</span>&lt;T&gt;:</span>:get() &amp;&amp; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(*<span class="keyword">this</span>).getTry().value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Try</span>&lt;T&gt; <span class="title">SemiFuture</span>&lt;T&gt;:</span>:getTry() &amp;&amp; &#123;</span><br><span class="line">  wait();</span><br><span class="line">  <span class="keyword">auto</span> future = folly::Future&lt;T&gt;(<span class="keyword">this</span>-&gt;core_);</span><br><span class="line">  <span class="keyword">this</span>-&gt;core_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(<span class="built_in">std</span>::move(future).result());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Future</span>&lt;T&gt;&amp; <span class="title">Future</span>&lt;T&gt;:</span>:wait() &amp; &#123;</span><br><span class="line">  futures::detail::waitImpl(*<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FutureType</span>, <span class="title">typename</span> <span class="title">T</span> = <span class="title">typename</span> <span class="title">FutureType</span>:</span>:value_type&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitImpl</span><span class="params">(FutureType&amp; f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">std</span>::is_base_of&lt;Future&lt;T&gt;, FutureType&gt;::value) &#123;</span><br><span class="line">    f = <span class="built_in">std</span>::move(f).via(&amp;InlineExecutor::instance());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// short-circuit if there's nothing to do</span></span><br><span class="line">  <span class="keyword">if</span> (f.isReady()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Promise&lt;T&gt; promise;</span><br><span class="line">  <span class="keyword">auto</span> ret = convertFuture(promise.getSemiFuture(), f);</span><br><span class="line">  FutureBatonType baton;</span><br><span class="line">  f.setCallback_([&amp;baton, promise = <span class="built_in">std</span>::move(promise)](</span><br><span class="line">                     Executor::KeepAlive&lt;&gt;&amp;&amp;, Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    promise.setTry(<span class="built_in">std</span>::move(t));</span><br><span class="line">    baton.post();</span><br><span class="line">  &#125;);</span><br><span class="line">  f = <span class="built_in">std</span>::move(ret);</span><br><span class="line">  baton.wait();</span><br><span class="line">  assert(f.isReady());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，等待的核心逻辑在<code>waitImpl</code>中。其核心是增加一层调用链，使用条件变量来等待执行完成。</p>
<p>在<code>waitImpl</code>中，增加一个<code>promise</code>，<code>baton</code>可以理解为一个条件变量。新增的调用链设置的callback只有两个作用，将上一层的结果写到新的future里面，作为最终返回给用户的结构，执行<code>baton.post()</code>方法，让在等待条件变量的线程被唤醒。设置完成<code>callback</code>后，线程就调用等待条件变量成立的环节，一直扥到最后的<code>callback</code>被执行完成，唤醒该线程，从而返回结果。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>上面已经介绍了不少关于异常处理的内容，但是一直未介绍如果设置异常处理函数。首先关于c++异常，可以参考该博客<a href="https://www.cnblogs.com/QG-whz/p/5136883.html" target="_blank" rel="noopener">C++异常</a>。</p>
<p>设置异常处理使用<code>thenError</code>方法，其逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;class ExceptionType, class F&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">    !isFutureOrSemiFuture&lt;<span class="keyword">invoke_result_t</span>&lt;F, ExceptionType&gt;&gt;::value,</span><br><span class="line">    Future&lt;T&gt;&gt;::type</span><br><span class="line">Future&lt;T&gt;::thenError(<span class="keyword">tag_t</span>&lt;ExceptionType&gt;, F&amp;&amp; func) &amp;&amp; &#123;</span><br><span class="line">  Promise&lt;T&gt; p;</span><br><span class="line">  p.core_-&gt;initCopyInterruptHandlerFrom(<span class="keyword">this</span>-&gt;getCore());</span><br><span class="line">  <span class="keyword">auto</span> sf = p.getSemiFuture();</span><br><span class="line">  <span class="keyword">auto</span>* ePtr = <span class="keyword">this</span>-&gt;getExecutor();</span><br><span class="line">  <span class="keyword">auto</span> e = folly::getKeepAliveToken(ePtr ? *ePtr : InlineExecutor::instance());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;setCallback_([state = futures::detail::makeCoreCallbackState(</span><br><span class="line">                          <span class="built_in">std</span>::move(p), <span class="keyword">static_cast</span>&lt;F&amp;&amp;&gt;(func))](</span><br><span class="line">                         Executor::KeepAlive&lt;&gt;&amp;&amp; ka, Try&lt;T&gt;&amp;&amp; t) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> ex = t.<span class="keyword">template</span> tryGetExceptionObject&lt;</span><br><span class="line">                  <span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;ExceptionType&gt;&gt;()) &#123;</span><br><span class="line">      state.setTry(<span class="built_in">std</span>::move(ka), makeTryWith([&amp;] &#123;</span><br><span class="line">                     <span class="keyword">return</span> state.invoke(<span class="built_in">std</span>::move(*ex));</span><br><span class="line">                   &#125;));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      state.setTry(<span class="built_in">std</span>::move(ka), <span class="built_in">std</span>::move(t));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(sf).via(<span class="built_in">std</span>::move(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">E</span>* <span class="title">tryGetExceptionObject</span>() &#123;</span></span><br><span class="line">    <span class="keyword">return</span> hasException() ? e_.get_exception&lt;E&gt;() : <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>异常处理的返回值也区分<code>try</code>类型和<code>future</code>类型，一般<code>future</code>类似使用的较少，这里仅展示<code>try</code>类型。</p>
<p>可以看到<code>thenError</code>整体实现与<code>thenTry</code>,<code>thenValue</code>区别不大，同样是增加一层调用链，区别只在设置的<code>callback</code>上。</p>
<p><code>thenError</code>一般有两个参数，第一个指示错误类型，当出错是进行类型匹配，只执行匹配到的那个，第二个则是设置的<code>callback</code>。</p>
<p><code>callback</code>处理逻辑为，先判断上一层执行的结构是否是参数中的异常类型（当未出现异常或者出现异常类型不匹配，均返回false），如果匹配，则执行<code>callback</code>为下一层设置<code>result</code>，否则直接将结果传递到下一层，开始下一层的逻辑。结合<a href="#异常传递">异常传递</a>更易理解。</p>
<h2 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h2><p>上面介绍了folly的异步框架实现，下面我们来看如何基于异步框架来实现DAG。首先介绍两个异步框架使用的额外方法<code>collect</code>函数和<code>SharedPromise</code>类。</p>
<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a><code>collect</code></h3><p><code>collect</code>方法参数是一个<code>future</code>的list，返回是一个<code>SemiFuture</code>，其<code>result</code>所有<code>future</code>的<code>result</code>构成的元组。其实现的功能是，新创建一个<code>future</code>，以参数中的所有<code>future</code>的结果作为其输入，即新建的<code>future</code>仅在参数中所有<code>future</code>获取到结果才执行自身的<code>callback</code>。这是DAG中重要的一环，即某个算子依赖多个算子，在多个算子执行完成时才能够执行，该功能即由<code>collect</code>来实现。</p>
<p>下面来看一下其具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Fs&gt;</span><br><span class="line">SemiFuture&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">typename</span> <span class="keyword">remove_cvref_t</span>&lt;Fs&gt;::value_type...&gt;&gt; collect(</span><br><span class="line">    Fs&amp;&amp;... fs) &#123;</span><br><span class="line">  <span class="keyword">using</span> Result = <span class="built_in">std</span>::tuple&lt;<span class="keyword">typename</span> <span class="keyword">remove_cvref_t</span>&lt;Fs&gt;::value_type...&gt;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">    ~Context() &#123;</span><br><span class="line">      <span class="keyword">if</span> (!threw.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// if any of the input futures were off the end of a weakRef(), the</span></span><br><span class="line">        <span class="comment">// logic added in setCallback_ will not execute as an executor</span></span><br><span class="line">        <span class="comment">// weakRef() drops all callbacks added silently without executing them</span></span><br><span class="line">        <span class="keyword">auto</span> brokenPromise = <span class="literal">false</span>;</span><br><span class="line">        folly::for_each(results, [&amp;](<span class="keyword">auto</span>&amp; result) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!result.hasValue() &amp;&amp; !result.hasException()) &#123;</span><br><span class="line">            brokenPromise = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (brokenPromise) &#123;</span><br><span class="line">          p.setException(BrokenPromise&#123;pretty_name&lt;Result&gt;()&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          p.setValue(unwrapTryTuple(<span class="built_in">std</span>::move(results)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Promise&lt;Result&gt; p;</span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;Try&lt;<span class="keyword">typename</span> <span class="keyword">remove_cvref_t</span>&lt;Fs&gt;::value_type&gt;...&gt; results;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; threw&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该步骤时获取执行器中所有defer执行器，这里不考虑该逻辑</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;futures::detail::DeferredWrapper&gt; executors;</span><br><span class="line">  futures::detail::stealDeferredExecutorsVariadic(executors, fs...);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> ctx = <span class="built_in">std</span>::make_shared&lt;Context&gt;();</span><br><span class="line">  futures::detail::foreach(</span><br><span class="line">      [&amp;](<span class="keyword">auto</span> i, <span class="keyword">auto</span>&amp;&amp; f) &#123;</span><br><span class="line">        f.setCallback_([i, ctx](Executor::KeepAlive&lt;&gt;&amp;&amp;, <span class="keyword">auto</span>&amp;&amp; t) &#123;</span><br><span class="line">          <span class="keyword">if</span> (t.hasException()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ctx-&gt;threw.exchange(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">              ctx-&gt;p.setException(<span class="built_in">std</span>::move(t.exception()));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ctx-&gt;threw.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::get&lt;i.value&gt;(ctx-&gt;results) = <span class="built_in">std</span>::move(t);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;Fs&amp;&amp;&gt;(fs)...);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> future = ctx-&gt;p.getSemiFuture();</span><br><span class="line">  <span class="comment">// 不考虑该逻辑，不考虑defer执行器</span></span><br><span class="line">  <span class="keyword">if</span> (!executors.empty()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> work = [](Try&lt;<span class="keyword">typename</span> <span class="keyword">decltype</span>(future)::value_type&gt;&amp;&amp; t) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::move(t).value();</span><br><span class="line">    &#125;;</span><br><span class="line">    future = <span class="built_in">std</span>::move(future).defer(work);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; deferredExecutor = futures::detail::getDeferredExecutor(future);</span><br><span class="line">    deferredExecutor-&gt;setNestedExecutors(<span class="built_in">std</span>::move(executors));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过看代码，我们可以看到，其实现就是利用<code>shared_ptr</code>的特性，即只在引用计数为0时，才执行析构函数。这样，我们让参数中所有<code>folly</code>均通过<code>callback</code>持有<code>shared_ptr</code>，让所有<code>future</code>执行<code>callback</code>结束时，就会执行析构函数，自动将<code>shared_ptr</code>的引用计数减一，直到所有的<code>future</code>均执行完成<code>callback</code>，就会最终析构<code>shared_ptr</code>，这时在析构函数中对新建的<code>promise</code>设置<code>result</code>，这样新建的<code>promise</code>就依赖所有参数中<code>future</code>执行结果，保证在所有<code>future</code>的<code>callback</code>执行·完成才执行。</p>
<p>其中<code>Context</code>就充当该<code>shared_ptr</code>的数据。对每个传递的<code>future</code>设置<code>callback</code>为将结果写到<code>Context</code>中对应的位置（或者抛出异常）。</p>
<p>在参数中所有<code>future</code>的<code>callback</code>执行完成后，就获取到了所有<code>folly</code>的结果，执行<code>Context</code>的析构函数，判断是否有异常产生，如果没有异常产生，则设置下一层的<code>promise</code>，完成计算。对应返回的<code>future</code>来说，如果后面还有别的链式执行逻辑，则会在这里被设置<code>result</code>后继续执行，如果没有，则用户直接获取到结果。</p>
<h3 id="SharedPromise类"><a href="#SharedPromise类" class="headerlink" title="SharedPromise类"></a><code>SharedPromise</code>类</h3><p>上面介绍的<code>collect</code>解决了一个算子依赖多个算子的情况，但还有另一个情况，就是多个算了依赖了同一个算子。这部分则是通过<code>SharedPromise</code>类来实现，其实现逻辑也相对简单，就是其会持有一个<code>promise</code>的list，当某个算子要依赖该算子时，就会将list增加一个<code>promise</code>，这样依赖其的算子就会获得一个<code>future</code>，当该算子执行完成后，会对该list中所有<code>promise</code>设置<code>result</code>，这样持有该算子<code>future</code>的·所有算子都可以继续执行了。</p>
<p>我们来看其具体实现，仅看核心数据和接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SharedPromise</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	SemiFuture&lt;T&gt; getSemiFuture() <span class="keyword">const</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setTry</span><span class="params">(Try&lt;T&gt;&amp;&amp; t)</span></span>;</span><br><span class="line">  <span class="keyword">mutable</span> Mutex mutex_;</span><br><span class="line">  <span class="keyword">mutable</span> Defaulted&lt;<span class="keyword">size_t</span>&gt; size_;</span><br><span class="line">  Defaulted&lt;Try&lt;T&gt;&gt; try_;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Promise&lt;T&gt;&gt; promises_;</span><br><span class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(exception_wrapper <span class="keyword">const</span>&amp;)&gt; interruptHandler_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SemiFuture</span>&lt;T&gt; <span class="title">SharedPromise</span>&lt;T&gt;:</span>:getSemiFuture() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; g(mutex_);</span><br><span class="line">  size_.value++;</span><br><span class="line">  <span class="keyword">if</span> (hasResult()) &#123;</span><br><span class="line">    <span class="keyword">return</span> makeFuture&lt;T&gt;(Try&lt;T&gt;(try_.value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    promises_.emplace_back();</span><br><span class="line">    <span class="keyword">if</span> (interruptHandler_) &#123;</span><br><span class="line">      promises_.back().setInterruptHandler(interruptHandler_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promises_.back().getSemiFuture();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SharedPromise</span>&lt;T&gt;:</span>:setTry(Try&lt;T&gt;&amp;&amp; t) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Promise&lt;T&gt;&gt; promises;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不能重复设置result</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; g(mutex_);</span><br><span class="line">    <span class="keyword">if</span> (hasResult()) &#123;</span><br><span class="line">      throw_exception&lt;PromiseAlreadySatisfied&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    try_.value = <span class="built_in">std</span>::move(t);</span><br><span class="line">    promises.swap(promises_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : promises) &#123;</span><br><span class="line">    p.setTry(Try&lt;T&gt;(try_.value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用中，每个算子持有一个<code>SharedPromise</code>，当某个算子依赖自身时，通过<code>getSemiFuture()</code>方法获取一个<code>SemiFuture</code>。当算子执行完成后，通过<code>setTry</code>向所有生成的<code>promise</code>设置结果，这样所有依赖该算子的算子，都可以开始执行其<code>callback</code>。</p>
<p>介绍完了上面的两个依赖，我们来看一下实际DAG的实现，folly实现了一个简单的DAG class <code>FutureDAG</code>。</p>
<h3 id="FutureDAG"><a href="#FutureDAG" class="headerlink" title="FutureDAG"></a><code>FutureDAG</code></h3><p><code>FutureDAG</code>使用future&amp;promise异步框架和上面介绍的两个工具实现了通用的DAG。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureDAG</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;FutureDAG&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FutureDAG&gt; create(</span><br><span class="line">      Executor::KeepAlive&lt;&gt; defaultExecutor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FutureDAG&gt;(</span><br><span class="line">        <span class="keyword">new</span> FutureDAG(<span class="built_in">std</span>::move(defaultExecutor)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> Handle;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;Future&lt;Unit&gt;()&gt; FutureFunc;</span><br><span class="line"></span><br><span class="line">  <span class="function">Handle <span class="title">add</span><span class="params">(FutureFunc func, Executor::KeepAlive&lt;&gt; executor)</span> </span>&#123;</span><br><span class="line">    nodes.emplace_back(<span class="built_in">std</span>::move(func), executor);</span><br><span class="line">    <span class="keyword">return</span> nodes.size() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Handle a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= nodes.size()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodes[a].hasDependents) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; node : nodes) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; deps = node.dependencies;</span><br><span class="line">        deps.erase(</span><br><span class="line">            <span class="built_in">std</span>::remove(<span class="built_in">std</span>::begin(deps), <span class="built_in">std</span>::end(deps), a), <span class="built_in">std</span>::end(deps));</span><br><span class="line">        <span class="keyword">for</span> (Handle&amp; handle : deps) &#123;</span><br><span class="line">          <span class="keyword">if</span> (handle &gt; a) &#123;</span><br><span class="line">            handle--;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodes.erase(nodes.begin() + a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Delete all but source node, and reset dependency properties</span></span><br><span class="line">    Handle source_node = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;Handle&gt; memo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; node : nodes) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Handle handle : node.dependencies) &#123;</span><br><span class="line">        memo.insert(handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Handle handle = <span class="number">0</span>; handle &lt; nodes.size(); handle++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (memo.find(handle) == memo.end()) &#123;</span><br><span class="line">        source_node = handle;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodes.erase(nodes.begin(), nodes.begin() + source_node);</span><br><span class="line">    nodes.erase(nodes.begin() + <span class="number">1</span>, nodes.end());</span><br><span class="line">    nodes[<span class="number">0</span>].hasDependents = <span class="literal">false</span>;</span><br><span class="line">    nodes[<span class="number">0</span>].dependencies.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dependency</span><span class="params">(Handle a, Handle b)</span> </span>&#123;</span><br><span class="line">    nodes[b].dependencies.push_back(a);</span><br><span class="line">    nodes[a].hasDependents = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clean_state</span><span class="params">(Handle source, Handle sink)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> handle : nodes[sink].dependencies) &#123;</span><br><span class="line">      nodes[handle].hasDependents = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes[<span class="number">0</span>].hasDependents = <span class="literal">false</span>;</span><br><span class="line">    remove(source);</span><br><span class="line">    remove(sink);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Unit&gt; go() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle()) &#123;</span><br><span class="line">      <span class="keyword">return</span> makeFuture&lt;Unit&gt;(<span class="built_in">std</span>::runtime_error(<span class="string">"Cycle in FutureDAG graph"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt; rootNodes;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt; leafNodes;</span><br><span class="line">    <span class="keyword">for</span> (Handle handle = <span class="number">0</span>; handle &lt; nodes.size(); handle++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nodes[handle].dependencies.empty()) &#123;</span><br><span class="line">        rootNodes.push_back(handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!nodes[handle].hasDependents) &#123;</span><br><span class="line">        leafNodes.push_back(handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sinkHandle = add([] &#123; <span class="keyword">return</span> Future&lt;Unit&gt;(); &#125;, defaultExecutor_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> handle : leafNodes) &#123;</span><br><span class="line">      dependency(handle, sinkHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sourceHandle = add(<span class="literal">nullptr</span>, defaultExecutor_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> handle : rootNodes) &#123;</span><br><span class="line">      dependency(sourceHandle, handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Handle handle = <span class="number">0</span>; handle &lt; nodes.size() - <span class="number">1</span>; handle++) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Future&lt;Unit&gt;&gt; dependencies;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> depHandle : nodes[handle].dependencies) &#123;</span><br><span class="line">        dependencies.push_back(nodes[depHandle].promise.getFuture());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      collect(dependencies)</span><br><span class="line">          .via(nodes[handle].executor)</span><br><span class="line">          .thenValue([<span class="keyword">this</span>, handle](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Unit&gt;&amp;&amp;) &#123;</span><br><span class="line">            nodes[handle].func().then([<span class="keyword">this</span>, handle](Try&lt;Unit&gt;&amp;&amp; t) &#123;</span><br><span class="line">              nodes[handle].promise.setTry(<span class="built_in">std</span>::move(t));</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;)</span><br><span class="line">          .thenError([<span class="keyword">this</span>, handle](exception_wrapper ew) &#123;</span><br><span class="line">            nodes[handle].promise.setException(<span class="built_in">std</span>::move(ew));</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodes[sourceHandle].promise.setValue();</span><br><span class="line">    <span class="keyword">return</span> nodes[sinkHandle].promise.getFuture().thenValue(</span><br><span class="line">        [that = shared_from_this(), sourceHandle, sinkHandle](Unit) &#123;</span><br><span class="line">          that-&gt;clean_state(sourceHandle, sinkHandle);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FutureDAG(Executor::KeepAlive&lt;&gt; defaultExecutor)</span><br><span class="line">      : defaultExecutor_&#123;<span class="built_in">std</span>::move(defaultExecutor)&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Perform a modified topological sort to detect cycles</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt;&gt; dependencies;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; node : nodes) &#123;</span><br><span class="line">      dependencies.push_back(node.dependencies);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; dependents(nodes.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dependencyEdges : dependencies) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> handle : dependencyEdges) &#123;</span><br><span class="line">        dependents[handle]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt; handles;</span><br><span class="line">    <span class="keyword">for</span> (Handle handle = <span class="number">0</span>; handle &lt; nodes.size(); handle++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!nodes[handle].hasDependents) &#123;</span><br><span class="line">        handles.push_back(handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!handles.empty()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> handle = handles.back();</span><br><span class="line">      handles.pop_back();</span><br><span class="line">      <span class="keyword">while</span> (!dependencies[handle].empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> dependency = dependencies[handle].back();</span><br><span class="line">        dependencies[handle].pop_back();</span><br><span class="line">        <span class="keyword">if</span> (--dependents[dependency] == <span class="number">0</span>) &#123;</span><br><span class="line">          handles.push_back(dependency);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dependencyEdges : dependencies) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dependencyEdges.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node(FutureFunc&amp;&amp; funcArg, Executor::KeepAlive&lt;&gt; executorArg)</span><br><span class="line">        : func(<span class="built_in">std</span>::move(funcArg)), executor(<span class="built_in">std</span>::move(executorArg)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    FutureFunc func&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    Executor::KeepAlive&lt;&gt; executor;</span><br><span class="line">    SharedPromise&lt;Unit&gt; promise;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Handle&gt; dependencies;</span><br><span class="line">    <span class="keyword">bool</span> hasDependents&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> visited&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">  Executor::KeepAlive&lt;&gt; defaultExecutor_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Node</code>是一个算子，其持有要执行的函数，要执行该任务的线程池，一个<code>SharedPromise</code>，<code>dependencies</code>节点自身依赖的节点列表，<code>hasDependents</code>表示是否有节点依赖自身，<code>visited</code>应该是旧版本判断是否有环的，目前没有用。</p>
<p><code>FutureDAG</code>使用逻辑是，创建一个空的<code>FutureDAG</code>实例，使用<code>add</code>向其中增加节点，同时返回节点对应下标，之后使用<code>dependency</code>构建节点间依赖关系，其中参数含义是：b依赖a。构建完成后调用<code>go</code>来执行DAG，在<code>go</code>中，首先判断节点间依赖是否成环，如果成环则不开执行，返回有异常的<code>future</code>，否则利用<code>collect</code>和<code>SharedPromise</code>构建执行的依赖关系。</p>
<p><code>hasCycle</code>函数判断是否成环，其逻辑较为简单。首先计算每个节点被依赖的次数存到<code>dependents</code>中，将不被别的节点依赖的节点放到<code>handles</code>中，从<code>handles</code>中取出一个节点，将该节点依赖的<code>depends</code>清空，并将所有该节点依赖的节点的计数减一，如果减一后结果为0，表示不再有别的节点依赖这个节点了，这时将该节点加到<code>handles</code>中，之后一直从<code>handles</code>中取数据，直到<code>handles</code>为空，此时判断是否还有未清空的<code>depends</code>，如果有则表示有环。</p>
<p>对有无环的DAG执行来说，首先区分叶节点和根节点，根节点是不依赖别的节点结果可以立即执行的节点，叶节点是哪些没有节点依赖该节点的节点。对应叶节点，增加一个<code>sink</code>节点，让该节点依赖所有的叶节点，作为执行结束标识。对应根节点，增加一个<code>source</code>节点，让所有根节点都依赖该节点，作为DAG启动标识。</p>
<p>遍历每个节点，通过其依赖的节点的<code>promise</code>获取到一个<code>future</code>list，通过<code>collect</code>该list构建一个新的<code>future</code>，设置一个<code>callback</code>，则该<code>collback</code>中执行节点对应的函数，并设置节点自生<code>SharedPromise</code>的<code>result</code>。同时设置异常处理函数。</p>
<p>之后设置<code>source</code>节点的<code>result</code>开始DAG执行，返回<code>sink</code>节点新增的一个调用链，用于清理<code>source</code>和<code>sink</code>节点。</p>
<p>对应返回的<code>future</code>，用户调用<code>std::move(f).get()</code>方法等待执行完成即可。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="C-高级方法"><a href="#C-高级方法" class="headerlink" title="C++高级方法"></a>C++高级方法</h2><h3 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h3><p>enable_if 的定义类似于下面的代码：（只有 Cond = true 时定义了 type）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> Cond, <span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">void</span>&gt; <span class="title">struct</span> <span class="title">enable_if</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">enable_if</span>&lt;true, T&gt; &#123;</span> <span class="keyword">typedef</span> T type; &#125;;</span><br></pre></td></tr></table></figure>
<p>这样的话，<code>enable_if&lt;true, T&gt;::type</code> 即为 <code>T</code>，而 <code>enable_if&lt;false, T&gt;::type</code> 会引发编译错误（在 SFINAE 下，即不将包含这一 enable_if 的函数 / 类作为候选）。</p>
<h3 id="类模板的偏特化"><a href="#类模板的偏特化" class="headerlink" title="类模板的偏特化"></a>类模板的偏特化</h3><p><a href="https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html" target="_blank" rel="noopener">https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html</a></p>
<h3 id="std-decay-t"><a href="#std-decay-t" class="headerlink" title="std::decay_t"></a>std::decay_t</h3><p>去除变量的所有引用属性，获取其原始class</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/folly/" rel="tag"># folly</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/12/11/LambdaMart原理及实现/" rel="next" title="LambdaMart算法原理与实现">
                <i class="fa fa-chevron-left"></i> LambdaMart算法原理与实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/09/24/Folly coro学习/" rel="prev" title="folly协程Task学习">
                folly协程Task学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chst</p>
              <p class="site-description motion-element" itemprop="description">人生苦酒,自酿自品</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#DAG设计"><span class="nav-number">1.</span> <span class="nav-text">DAG设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#需求"><span class="nav-number">1.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计"><span class="nav-number">1.2.</span> <span class="nav-text">设计</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用样例"><span class="nav-number">2.</span> <span class="nav-text">使用样例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码代码解析"><span class="nav-number">3.</span> <span class="nav-text">源码代码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#core"><span class="nav-number">3.1.</span> <span class="nav-text">core</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#State"><span class="nav-number">3.1.1.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpinLock"><span class="nav-number">3.1.2.</span> <span class="nav-text">SpinLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeferredExecutor"><span class="nav-number">3.1.3.</span> <span class="nav-text">DeferredExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeepAliveOrDeferred"><span class="nav-number">3.1.4.</span> <span class="nav-text">KeepAliveOrDeferred</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InterruptHandler-amp-InterruptHandlerImpl"><span class="nav-number">3.1.5.</span> <span class="nav-text">InterruptHandler&amp;InterruptHandlerImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoreBase"><span class="nav-number">3.1.6.</span> <span class="nav-text">CoreBase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResultHolder"><span class="nav-number">3.1.7.</span> <span class="nav-text">ResultHolder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-1"><span class="nav-number">3.1.8.</span> <span class="nav-text">core</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">3.1.9.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#future-amp-promise"><span class="nav-number">3.2.</span> <span class="nav-text">future&amp;promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正常异步执行流程为"><span class="nav-number">3.2.1.</span> <span class="nav-text">正常异步执行流程为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建promise"><span class="nav-number">3.2.2.</span> <span class="nav-text">创建promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从promise中获取future"><span class="nav-number">3.2.3.</span> <span class="nav-text">从promise中获取future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加callback"><span class="nav-number">3.2.4.</span> <span class="nav-text">添加callback</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#callback返回try"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">callback返回try</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#callback返回future"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">callback返回future</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#callback设置线程池"><span class="nav-number">3.2.5.</span> <span class="nav-text">callback设置线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待执行结束"><span class="nav-number">3.2.6.</span> <span class="nav-text">等待执行结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理"><span class="nav-number">3.2.7.</span> <span class="nav-text">异常处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DAG"><span class="nav-number">3.3.</span> <span class="nav-text">DAG</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#collect"><span class="nav-number">3.3.1.</span> <span class="nav-text">collect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SharedPromise类"><span class="nav-number">3.3.2.</span> <span class="nav-text">SharedPromise类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureDAG"><span class="nav-number">3.3.3.</span> <span class="nav-text">FutureDAG</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-高级方法"><span class="nav-number">4.1.</span> <span class="nav-text">C++高级方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-enable-if"><span class="nav-number">4.1.1.</span> <span class="nav-text">std::enable_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类模板的偏特化"><span class="nav-number">4.1.2.</span> <span class="nav-text">类模板的偏特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-decay-t"><span class="nav-number">4.1.3.</span> <span class="nav-text">std::decay_t</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chst</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="/js/src/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '0j9TGrGA2Aq8e4SO1sUkgQCv-gzGzoHsz',
        appKey: 'Q6jotQjlp43pwpkFCJhQ9s95',
        placeholder: '请留下联系方式，我会尽快回复',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
