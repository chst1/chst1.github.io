<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="chst&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="chst&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chst&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>chst's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chst's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人网站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/git学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/git学习/" itemprop="url">git学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-20T17:57:13+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>git 是互联网公司必备工具, 更是it工作者必备技能, 这里主要讲解涉及如下内容.创建版本库, 版本回退, 工作区与暂存区, github使用, 分支管理, 远程仓库, 冲突合并.</p>
<p>&lt; !– more –&gt;</p>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a><center>git</center></h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>找实习两个月, 终于有公司肯要我这个菜鸡了. 似乎对于互联网公司来说第一个要学的就是git的版本控制了, 当然进去肯定会被要求赶快看一下,知道基本使用. leader发了份<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的git</a>. 于是在了解基本指令后又自己按照网站学习了一下,包含一部分自己的理解.</p>
<h2 id="创建版本库-repository"><a href="#创建版本库-repository" class="headerlink" title="创建版本库(repository)"></a>创建版本库(<strong>repository</strong>)</h2><ol>
<li>创建一个空目录 mkdir dir_name</li>
<li>通过get init命令将目录变成git可管理的仓库.</li>
</ol>
<p>此时会将目录变成空的版本库, 其中存在一个.git的隐藏目录, 用于跟踪管理版本库.</p>
<h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><ol>
<li>首先将要添加的文件放到版本库目录下.</li>
<li>使用<code>git add filename1 filename2 ...</code>添加文件到仓库.</li>
<li>使用<code>git commit -m &quot;explain words&quot;</code>将文件提交到仓库.</li>
</ol>
<p><code>git commit</code>后面-m表示解释的参数, 指示出这次提交的内容.</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add test1.txt test2.txt test3.txt</span><br><span class="line">git commit -m &quot;test loads file&quot;</span><br></pre></td></tr></table></figure>

<h2 id="更新文件和查询当前版本库状态"><a href="#更新文件和查询当前版本库状态" class="headerlink" title="更新文件和查询当前版本库状态"></a>更新文件和查询当前版本库状态</h2><p><code>git status</code>用来查看版本库当前状态,  如果没有任何更改则显示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>当某个文件被更改而未add和commit时, 会显示文件发生变化通过add和commit进行更新:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>此时我们可以使用<code>git diff filename</code>来显示文件内容哪里发生了更改(只能在文件提交前查看):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index f7249b8..7a8a2b4 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> Git is a version control system</span><br><span class="line"> Git is free software</span><br><span class="line">+test change</span><br></pre></td></tr></table></figure>

<p>当文件更改且add添加而未commit时, 会提示我们使用commit进行提交:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>最后使用commit进行提交即完成更改, 提交后, status即恢复到初始状态.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><code>git log</code>用来显示历史记录. 其会从最新一次更改显示到最初的更改.</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">commit db0c719054994a2e6bab6367837077a628b1c4ee (HEAD -&gt; master)</span><br><span class="line">Author: chst1 &lt;2322253097@qq.com&gt;</span><br><span class="line">Date:   Tue Jul 2 23:50:38 2019 +0800</span><br><span class="line"></span><br><span class="line">    change 2</span><br><span class="line"></span><br><span class="line">commit 76411db8fb0c504d70d0ca8dd5a674f81dc5773c</span><br><span class="line">Author: chst1 &lt;2322253097@qq.com&gt;</span><br><span class="line">Date:   Mon Jul 1 23:40:41 2019 +0800</span><br><span class="line"></span><br><span class="line">    change readme</span><br><span class="line"></span><br><span class="line">commit bd8b25edc8c33a8e134f992d570b7b50bca6361e</span><br><span class="line">Author: chst1 &lt;2322253097@qq.com&gt;</span><br><span class="line">Date:   Mon Jul 1 23:19:50 2019 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>

<p>使用<code>git reset --hard HEAD^</code> 即可恢复到当前版本的上一个版本. 使用<code>--hard HEAD^^</code>恢复到上一个版本的上一个版本. 如果希望指定某个版本, 只需要在hard中指定版本号即可, 即<code>git log</code>输出的commit, 只需要输出其中部分位数即可. 当进行版本恢复时, 再次使用git log命令将会使得恢复版本后面的版本不存在记录了. 此时如果我们想要恢复到当前版本的下一个版本时, 我们就不知道–hard后边参数为何了, 此时我们可以使用<code>git reflog</code>命令来显示之前操作的每一个命令, 从中可以获得下一个版本的版本号, 之后使用<code>git reset --hard commit</code>恢复即可.</p>
<p>例:(git reflog)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">76411db (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^ // 当前版本</span><br><span class="line">db0c719 HEAD@&#123;1&#125;: commit: change 2 // 回退前最后版本</span><br><span class="line">76411db (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: change readme</span><br><span class="line">bd8b25e HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>

<p>git版本回退快是因为git内部有一个指向当前版本的HEAD指针, 当版本变换时只需要将指针指向对于版本即可.</p>
<h2 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h2><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>即为电脑中被git init初始化后的目录.</p>
<h3 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h3><p>工作区的一个隐藏目录.git, 为git版本库.  .git存放了很多东西, 最重要的是stage(或叫index)的暂存区, 还有git自动创建的分支master以及指向master的一个指针HEAD.</p>
<p><img src="https://s2.ax1x.com/2019/07/03/ZYKxYV.png" alt="图示"></p>
<p>git add是将文件修改添加到暂存区, <code>git commit</code>是将文件提交到当前分支. 当提交完成后, 暂存区不会被清理,(可能只是存在一个同步标志). 这就是为何git commit后使用git status显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On branch master //指示当前分支</span><br><span class="line">// 指示当前暂存区为空, 没有东西可以提交</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p><code>git diff</code>默认比较的是工作区与暂存区(最后一次add).</p>
<p><code>git diff --cached</code>比较暂存区与最新版本库(即最后一次commit的, 也就是分支中的)</p>
<p><code>git diff commit_id</code>比较工作区与指定版本号区别</p>
<p><code>git diff --cached commit_id</code>比较暂存区与指定版本号直接区别.</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h3 id="撤销工作区修改"><a href="#撤销工作区修改" class="headerlink" title="撤销工作区修改"></a>撤销工作区修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>

<p>该命令用于丢弃工作区的修改. 如果工作区更改还未放到暂存区, 则将文件恢复为和版本库一致. 如果已经add到暂存区了, 则将文件恢复到与当前暂存区的状态.</p>
<h3 id="撤销暂存区修改"><a href="#撤销暂存区修改" class="headerlink" title="撤销暂存区修改"></a>撤销暂存区修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>

<p>该命令用于更改已经add到暂存区, 使用此命令可以将暂存区内file恢复到与版本库一致. 如果想要接着恢复工作区,则使用上面的撤销工作区的命令.</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>首先在工作区中将要删除的文件删除, 而后使用git rm file_name删除文件, 而后git commit提交即可.</p>
<p>即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm file_name</span><br><span class="line"></span><br><span class="line">git rm file_name</span><br><span class="line"></span><br><span class="line">git commit -m &quot;info&quot;</span><br></pre></td></tr></table></figure>

<p>还有一种情况是工作区中的文件被误删(<code>rm file_name</code>), 此时我们可以使用版本库中的文件对其进行恢复操作. 即使用<code>git checkout -- file_name</code>  即使用版本库中的文件(暂存区或版本库)对工作区文件恢复.</p>
<p>如果是使用<code>git rm file_name</code> 对文件删除, 则是先删除工作区文件, 在进行了一次add, 即将暂存区的文件也删除了, 此时如果想要恢复则应该先恢复暂存区的文件<code>git reset HEAD file_name</code>, 在恢复工作区文件 <code>git checkout -- file_name</code></p>
<p>这里删除文件而后上传到远程仓库, 远程仓库中文件也会被删除.</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>这里主要介绍github的使用, 毕竟对个人来说, 主要使用场景就是github了.</p>
<h3 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h3><p>在用户目录下(命令行中cd后ls -a)查看有没有.ssh目录, 如果有则查看是否存在id_rsa和id_rsa.pub文件. 已经存在则跳过下面步骤, 如果不存在, 则创建ssh key,在命令行中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>youremail为自己的邮件地址.</p>
<h2 id="在github上添加ssh"><a href="#在github上添加ssh" class="headerlink" title="在github上添加ssh"></a>在github上添加ssh</h2><p>登录github, 在打开Account setting, SSH Keys页面, 点击Add SSH Key, 填写任意Title, 在Key中粘贴id_rsa.pub文件内容. 点击Add key即将当前电脑与个人github网站建立连接了.</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>登录github后点击<code>Start a project</code>,自己填写命名和描述. 点击创建, 默认会指导你如何操作. 如果本地已经存在仓库了, 只需要将本地仓库与github的仓库关联即可, 也就是运行如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>

<h3 id="将代码上传到github"><a href="#将代码上传到github" class="headerlink" title="将代码上传到github"></a>将代码上传到github</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>

<p>第一次需要-u, Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>之后希望提交更改时, 先在本地完成add和commit, 即将本地的版本库更新, 再push到github即可.</p>
<h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p>cd到自己想要放置的目录, 使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>

<p>即可.</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>创建版本库时会自动创建一个master分支, HEAD指向master, master才指向提交, 一开始的分支如下所示:</p>
<p><img src="https://s2.ax1x.com/2019/07/16/ZqSlvV.png" alt="1"></p>
<p>当创建分支时, git新建一个指针, 指向与当前master所指向的相同提交, 当我们切换分支时, HEAD就会更改指向位置, 下图为切换到dev分支:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev // 创建分支</span><br><span class="line">$ git checkout dev // 切换分支</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/07/16/ZqSM3q.png" alt="2"></p>
<p>可以使用<code>git branch</code>显示工作目录下存在的分支以及当前所处分支</p>
<p>当我们切换到哪个分支时, 提交就会在那个分支进行, 即对于分支指向的提交前进, 而与别的分支无关, 下面为在创建的分支下提交的结果:</p>
<p><img src="https://s2.ax1x.com/2019/07/16/ZqSKCn.png" alt="3"></p>
<p>即别的分支不变, 当前工作分支前移.</p>
<p>我们在dev中工作完成就可以将dev合并到master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/07/16/ZqSn4s.png" alt="4"></p>
<p>这里的合并是快速合并, 直接将master指向dev指向的地方. </p>
<p>而后可以删除dev</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line"></span><br><span class="line">$ git branch -D dev 强行删除</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/07/16/ZqSQg0.png" alt="5"></p>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>在创建分支后, 在分支中对工作区的文件更改而不提交时在切换到主分支时更改也能看到, 而如果在分支中更改了并且以及提交到版本库中, 此时回到主分支时是看不到工作区发生更改的.</p>
<p>个人理解, 由于工作区与暂存区对于各个分支来说是共有的, 同时在工作区应该存在一个各个分支共享指针表示当前工作区的更改是否提交, 如果提交了, 则每次打开工作区文件显示的都是当前所在分支的版本库中文件, 而如果没有提交, 则显示工作区元素文件. 这时当将主分支与另外的分支合并时, 由于工作区已经提交, 此时打开主分支显示的也是版本库中文件.(这里显示可能存在问题, 显示表示未变只是展示出来发生问题,这是不合理的, 更可能的应该是在每次操作之后按照上述规则对工作区文件进行更改). 这样可以解释的通,但却不知道对不对, 希望知道原因的大佬指正. </p>
<h3 id="合并时存储分支信息"><a href="#合并时存储分支信息" class="headerlink" title="合并时存储分支信息"></a>合并时存储分支信息</h3><p>当我们在合并后, 常常会将分支删除, 此时我们就不知道了分支合并前的信息, 为了保留合并前信息, 我们在合并时要关闭<code>Fast forward</code> 使用如下命令合并即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>

<p>后面的-m是该命令调用了commit命令, 生成了一个存储合并前的文件.</p>
<p>如下展示区别:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*   bc742c3 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * 1eb71b9 (dev) dev change2 // 此处是使用--no--ff模式下存储的分支信息</span><br><span class="line">|/  </span><br><span class="line">* 1f9002e dev change // 此处为直接合并, 无法看到合并前分支内容</span><br><span class="line">*   0e9a735 merge info</span><br><span class="line">|\  </span><br><span class="line">| * 8fb45d3 dev change</span><br><span class="line">* | 42bbb6d master change</span><br><span class="line">|/  </span><br><span class="line">*   d951ea7 conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * fd94b5f dev change</span><br><span class="line">* | ca2dbf7 master change</span><br><span class="line">|/  </span><br><span class="line">* 3613205 kk</span><br><span class="line">* 2360153 change del</span><br><span class="line">* de50b7a dev change</span><br><span class="line">* 00eb99a dev change</span><br></pre></td></tr></table></figure>

<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>之前的合并均是在一个分支上没有变换, 另一个分支上发生了变换, 此时的合并规则较为简单, 当两个文件均发生了改变时, 会引起合并冲突.</p>
<p>此时在主分支合并时, git会告诉我们存在冲突, 而对应的工作区文件也会被git更改, 显示出冲突的位置, Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>(当前工作区冲突内容)，<code>=======</code>(分割)，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>(要合并的部分冲突内容)标记出不同分支的内容. 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>

<p>此时我们需要对该文件进行手动修复, 然后再提交一遍即可. 提交就相当于告诉git修复完成, 对当前分支进行更新, 但修复主分支不会影响另一个分支, 切换会另一个分支, 其内容依旧是其更改之后的样子.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>

<p>上述代表可以显示合并过程, 像下面一样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*   d951ea7 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * fd94b5f (dev) dev change</span><br><span class="line">* | ca2dbf7 master change</span><br><span class="line">|/  </span><br><span class="line">* 3613205 kk</span><br><span class="line">* 2360153 change del</span><br><span class="line">* de50b7a dev change</span><br><span class="line">* 00eb99a dev change</span><br><span class="line">* f47bb03 (origin/master) change readme</span><br><span class="line">* 7fe03d1 add del</span><br><span class="line">* e2c8fff del del</span><br><span class="line">* a8a2b06 test rm</span><br><span class="line">* db0c719 change 2</span><br><span class="line">* 76411db change readme</span><br><span class="line">* bd8b25e wrote a readme file</span><br></pre></td></tr></table></figure>

<h3 id="存储当前工作区更改"><a href="#存储当前工作区更改" class="headerlink" title="存储当前工作区更改"></a>存储当前工作区更改</h3><p>当我们在进行一个任务进行到一半时, 接到另一个更加紧急的任务,此时我们需要先去处理第二个任务, 而第一个任务未完成,此时我们就要存储当前工作区状态, 而后去处理第二个任务. 因为工作区是共享的, 如果不存储并隐藏工作区更改, 在处理完第二个任务提交时会将第一个未完成的任务一起提交, 这就将导致严重的错误. 在完成第二个任务后可以进行恢复操作, 但恢复操作可能会涉及合并, 这是由于在隐藏时, 文件已经发生了变化, 就会出现合并冲突. 由于git存储的都是每次更改的变化, 因此十分适合该场景, 只需要将当前记录变化的文件隐藏,再打开一个新的即可.</p>
<h4 id="存储工作区"><a href="#存储工作区" class="headerlink" title="存储工作区"></a>存储工作区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure>

<p>存储后使用<code>git status</code>查看工作区，就是干净的. 可能有多个优先级不同的任务进入, 此时我们可能会存储多次.</p>
<h4 id="恢复工作区"><a href="#恢复工作区" class="headerlink" title="恢复工作区"></a>恢复工作区</h4><p>首先使用下属命令查看当前隐藏的状态列表.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>

<p>使用下述命令恢复指定隐藏状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;n&#125;</span><br></pre></td></tr></table></figure>

<p>其中stash@{n}为<code>$ git stash list</code>输出的.</p>
<p>完成后可以将该id对应的隐藏状态删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;n&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用<code>git stash pop</code>，恢复的同时把stash内容也删了.(一个按照栈弹出).</p>
<p>恢复工作区不一定会发生冲突,这取决于隐藏的工作区与恢复前工作区之间是否存在冲突. 如果隐藏后直接在当前分支继续更改操作提交而后恢复极有可能出现冲突, 这是由于在隐藏时文件发生了更改, 与隐藏的更改不一致. 而如果是隐藏后在另一个工作区更改提交再切换回来恢复,则不会发生冲突, 这是由于在另一个工作区更改提交不会影响当前工作区内的内容,相当于当前工作区未发生变话,可以直接恢复.</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>远程仓库默认名字是<code>origin</code>, 使用如下命令查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br></pre></td></tr></table></figure>

<p>查看详细详细使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>如果没有推送权限就看不到<code>push</code> ．</p>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p><code>origin</code>指远程仓库名字, <code>master</code>表示要推送的分支名字.</p>
<h4 id="在本地根据远程仓库创建分支"><a href="#在本地根据远程仓库创建分支" class="headerlink" title="在本地根据远程仓库创建分支"></a>在本地根据远程仓库创建分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone ...</span><br></pre></td></tr></table></figure>

<p>只能是克隆<code>master</code>分支到本地, 要想克隆别的分支到本地需要使用如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>

<p><code>dev</code>为克隆下来分支名称, <code>origin/dev</code>表示从远程克隆哪个分支.</p>
<h4 id="抓取最新更改"><a href="#抓取最新更改" class="headerlink" title="抓取最新更改"></a>抓取最新更改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p>默认抓取<code>origin/master</code>的更改, 当在本地不同非<code>master</code>工作区时, 应该首先建立指定分支之间连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure>

<p>而后在使用 <code>git pull</code>. 此时可能会发生合并冲突,在本地进行更改,而后提交即可.</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>在本地更改代码.</li>
<li>使用<code>git pull</code>合并其他人提交导致的冲突.</li>
<li>使用<code>git push origin dev</code>提交. 如果出现错误则转到第二步.</li>
</ol>
<h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4><p>在分支合并时, 使用<code>git merge</code>时, 会在最终的log中出现一个类似于环的图形(不是环, 有起点和终点), 但使用rebase进行合并时则不会出现, 具体参看[rebase][<a href="http://gitbook.liuhui998.com/4_2.html]" target="_blank" rel="noopener">http://gitbook.liuhui998.com/4_2.html]</a>.</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>直接创建标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag tag_name</span><br></pre></td></tr></table></figure>

<p>表示将当前<code>commit_id</code>的提交打上<code>v1.0</code>的标签.</p>
<p>指定<code>commit</code>创建标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag tag_name commt-id</span><br></pre></td></tr></table></figure>

<p>在创建时添加说明文字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a tag_name -m &quot;info&quot; commit_id</span><br></pre></td></tr></table></figure>

<p>其中用<code>-a</code>指定标签名，<code>-m</code>指定说明文字.</p>
<p>查看所以标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure>

<p>输出的标签排序不是按照时间而是按名称.</p>
<p>查看标签信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show tag_name</span><br></pre></td></tr></table></figure>

<p>会展示对应提交的相关信息.</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>删除:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d tag_name</span><br></pre></td></tr></table></figure>

<p>推送标签到远程库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin tag_name</span><br></pre></td></tr></table></figure>

<p>一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>

<p>删除远程标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先在本地删除.</span><br><span class="line">$ git tag -d tag_name</span><br><span class="line">再删除远程仓库</span><br><span class="line">$ git push origin :refs/tags/tag_name</span><br></pre></td></tr></table></figure>

<h2 id="自定义git"><a href="#自定义git" class="headerlink" title="自定义git"></a>自定义git</h2><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>当我们在提交时, 有些文件是无关紧要但变换很多的(如编译产生的中间文件或者服务器生成的log文件)文件, 显然版本控制不应该在意这些文件的话,此时我们就可以选择忽略特殊文件文件. 只用创建一个特殊的.gitignore文件, 将要忽略的文件写进去(按行), 再提交,git就会自动忽略这些文件. 对于不同编程需求官方提供了[忽略文件][<a href="https://github.com/github/gitignore]" target="_blank" rel="noopener">https://github.com/github/gitignore]</a>, 我们只用在这个上面进行适合自己的修改即可.</p>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>在输入命令时, 总会由于名字太长而不方便, 这时我们可以为命令配置一个简单的别名,此时我们只用输入简单的指令就能够实现一长串指令的操作岂不美滋滋. 语法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.your_command origin_command</span><br></pre></td></tr></table></figure>

<p><code>--gloable</code>表示对当前试用.(否则只在当前版本库中能够使用.)</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>

<p>试用<code>git lg</code>命令实现<code>git log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit</code></p>
<p>每个仓库的git配置文件就在<code>.git/config</code>文件中.  而对当前用户的git配置则在用户目录下.gitconfig文件中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">	name = yourname</span><br><span class="line">	email = youremail</span><br><span class="line">[color]</span><br><span class="line">	ui = true</span><br><span class="line">[alias]</span><br><span class="line">	lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/计算几何学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/计算几何学/" itemprop="url">计算几何学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-17T09:31:18+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算几何学"><a href="#计算几何学" class="headerlink" title="计算几何学"></a><center><font size="12">计算几何学</font></center></h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/16/KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/16/KMP/" itemprop="url">KMP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-16T16:31:59+08:00">
                2019-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><center><font size="12">KMP算法</font></center></h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a><center><font size="10">序</font></center></h2><p>字符串匹配是个十分经典而又十分有意义的一个问题, 在搜索信息时被广泛使用, 例如浏览器筛选信息, 编辑文本时的全局查找, DNA序列搜索等等. 对于应用如此广泛的问题当然要有十分快速的解决方法才好, 这里介绍的是复杂度最低的算法(应该没有比这个更好了吧.). 即KMP算法(Knuth-Morris-Pratt算法, 由此三人发明). 其时间复杂度为线性复杂度即O(n+m).(n和m分别为文本长度和匹配模式长度).</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a><center><font size="10">思想</font></center></h2><p>与最简单的字符串匹配算法(每次比较完成后平移一个位置)相比, KMP主要利用了匹配过程中模式串本身的信息, 使得每次平移不是一个而是与之前匹配结果有关的一个值. 为了实现上述目的, 我们要对模式串进行分析处理, 生成一个前缀函数, 用以记录模式串内心信息与联系. 下图可以形象解释这一问题:</p>
<p><img src="https://s2.ax1x.com/2019/06/16/V7EjV1.png" alt="例"></p>
<p>对于上图中, 当匹配到模式中第六个元素与文本中不对应时, 简单方法是平移1后继续从第一个开始匹配, 而KMP借助于前主函数, 知道平移一个接着匹配是一定不会匹配成功的, 因此可以直接平移两个并且再接着匹配时也不用从第一个开始匹配, 直接从第四个进行匹配即可.</p>
<h2 id="前缀函数"><a href="#前缀函数" class="headerlink" title="前缀函数"></a><center><font size="10">前缀函数</font></center></h2><p>模式的前缀函数包含模式与其子身的偏移进行匹配的信息. 简单来说, 前缀函数就是一个数组, 用来对应模式对于位置可以与模式本身前缀匹配长度. 例如: p为模式串, a[7] = 2, a是前缀函数, a[7]表示对应于模式的第8个元素, 前匹配函数为2表示, p[7] == p[2], 并且p[0-2]与p[5-7]是一致的. 一般的, 对于a[i] = n表示, p[0-n]=p[(i-n) - i], 即在第i个节点(对于模式串来说)匹配失败时将模式串索引为a[i-1]对应的元素与当前匹配到的文本前一个位置对齐即可以继续接着匹配. 以上图为例, a[4]=2; 在匹配第5个元素是(c)时出错, 此时只需要将模式串索引为a[4] = 2与文本中当前匹配到的元素(a)前一个(a)对齐, 然后接着从原来匹配出错的位置继续匹配即可.</p>
<p><img src="https://s2.ax1x.com/2019/06/16/V7EvUx.png" alt="前缀函数"></p>
<p>前缀函数的获取其实本身就是一个字符串匹配问题, 是自己的后面的部分与前面进行匹配. 也就是对于任意的一个索引i, 我们要找到最大的n使得p[0-n] =p[(i-n) - i], 这其实与文本与模式串匹配是一样的, 不过文本与模式串匹配时是要找到满足p[0-n] = T[(i-n) - i](此处n与前面不一样, 前面n是一个变量,这里n指代模式串长度)的所有的i.  需要注意一点, 空字符串与所有字符串都可以匹配. 此时的操作有点类似与DP, 但又不一样. 其思想为: 始终存在一个数值k用于记录当前匹配到的最长前缀, 即满足p[0-n] = p[(i-n)-i]的最大的n. 随后考察索引i+1位置的情况. 此时, 如果p[k+1] = p[i+1], 则k应该增加1, 并且索引i+1的前缀函数为增加后的k值. 因为此时满足p[0-(k+1)] = p[(i-k)-(i+1)]; 当p[k+1] != p[i+1]时, 我们应该注意到, p[k] = p[a[k]], 这是由于当考察到第i+1时, 其前i个的前缀函数已经获得了. 此时对于前i个元素, 即有p[0-n] = p[(m-n)-m],(m=0,1,…i). n即为a[m].所以p[a[m]] = p[m]. 而在这里k = a[i](由前面所述k的定义可知). 所以, 我们可以令k = a[k]来获得索引i所对应的前缀串的最后一个元素的前缀函数.此时利用前缀的传递性, 即p[i] = p[a[i]] = p[a[a[i]]] = … 可以得到, 此时新获得的k依然满足k的定义, 即满足p[0-k] = p[(i-k), i]. 于是我们可以以该k值继续进行判断p[k+1] = p[i+1]?, 对应于出现的不同情况处理与先前所述一致. 令k = a[k]可以看成一个回溯, 其终止条件为要么查找到头依然没有找到满足条件的p[k+1] = p[i+1], 此时应该将模式串前一个位置(假想的空字符)平移到第i的位置, 即对应的a[i+1] = -1, 或者出现p[k+1] = p[i+1]. 这里前面突然出现的-1可能有写不好理解, 其实就是我们假想模式串前面有一个空字符, 这是为了方便我们处理而进行的一个假想的构造, 其索引就应该是-1, 空字符串与所以字符均匹配. 当a[i] = -1时表示, 将模式串空字符与当前i对齐, 即将模式串第一个元素与i+1对齐.</p>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a><center><font size="10">匹配</font></center></h2><p>就像之前所述, 前缀函数相当与一个字符串匹配, 此时进行匹配的操作与计算前缀函数基本一致, 不过前缀函数匹配的是同一字符串进行匹配, 文本与模式串的匹配则是两个不同串进行匹配, 且此时前缀函数已经获得可以直接使用. 整体操作与前缀串差不多, 就增加了一个判断是否查找到完整子串这一步. 具体看代码即可.</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a><center><font size="10">code</font></center></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前缀函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">COMPUTE_PREFIX_FUNCTION</span><span class="params">(<span class="keyword">char</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">int</span> *w = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">    w[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; a[k+<span class="number">1</span>] != a[i])</span><br><span class="line">            k = a[k];</span><br><span class="line">        <span class="keyword">if</span>(a[k+<span class="number">1</span>] == a[i])</span><br><span class="line">            k++;</span><br><span class="line">        w[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP_MATCHER</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">char</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T_NUM = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="keyword">int</span> p_NUM = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">int</span> *PREFIX_FUNCTION = COMPUTE_PREFIX_FUNCTION(p);</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; p[k+<span class="number">1</span>] != T[i])</span><br><span class="line">        &#123;</span><br><span class="line">            k = PREFIX_FUNCTION[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[k+<span class="number">1</span>] == T[i])</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">if</span>(k == p_NUM<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i-p_NUM+<span class="number">2</span>&lt;&lt;<span class="string">" pattern occurs!!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            k = PREFIX_FUNCTION[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/13/红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/13/红黑树/" itemprop="url">红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-13T23:39:35+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><center><font size="12">红黑树</font></center></h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a><center><font size="10">序</font></center></h2><p>红黑树作为一种自平衡二叉树, 其难度与实用性令人不得不重视, 也是面试中常问的问题. 如果说&lt;&lt;平凡的世界&gt;&gt;是茅盾文学奖桂冠上的明珠, 那红黑树就是树型数据结构桂冠上的明珠(逃~). 如果能实现红黑树, 那基本树这种数据结构就算懂得差不多了. 其实用性也是相当高. C++中STL里的set与map均是由红黑树作为底层实现.</p>
<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a><center><font size="10">红黑树的性质</font></center></h2><p>红黑树中每个节点中增加了一个存储位来表示节点的颜色, 是RED或BLACK. 每个节点包含五个属性, color, key, left, right, p. 通过对任意一条路径上各个节点的颜色进行约束, 确保没有一条路径会比其他路径长两倍, 因此是近似与平衡的. 红黑树满足的性质:</p>
<ol>
<li>每个节点或红色或黑色.</li>
<li>根节点是黑色</li>
<li>每个页节点(NIL)是黑色. 叶节点均为NIL.</li>
<li>如果一个节点是红色, 则它的两个子节点是黑色的.</li>
<li>对于每个节点, 从该节点到其所以后代叶节点的简单路径上, 均包含相同数目的黑色节点.</li>
</ol>
<p>为了便于处理红黑树边界问题, 使用一个哨兵来代表NIL.</p>
<p>黑高: 从某个节点出发(不包含该节点), 到达一个叶节点的任意一条路径上黑色节点数量叫做该节点的黑高. 记为bh(x).</p>
<p><img src="https://s2.ax1x.com/2019/06/16/VojyuD.png" alt="红黑树"></p>
<p>红黑树还有一个重要性质为: 一个有n个节点内部节点的红黑树的高度至多为2log(n+1).</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a><center><font size="10">旋转</font></center></h2><p>旋转是红黑树中最基本的操作, 这在插入删除中时常会用到.  旋转操作不会破坏红黑树性质, 旋转完成不用考虑维护红黑树性质的问题. 旋转分为左旋和右旋, 其效果如下图:</p>
<p>旋转分为左旋和右旋, 其效果如下图:</p>
<p><img src="https://s2.ax1x.com/2019/06/16/Voj09x.png" alt="旋转"></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a><center><font size="10">插入</font></center></h2><p>无论是构建一棵红黑树还是在后续的使用中, 插入操作都发挥了至关重要的角色, 插入一个新节点时, 我们将新节点置为红色, 以右节点&gt;父节点&gt;左节点的性质进行插入. 插入后将会破坏红黑树的性质, 因此我们需要添加操作来维护其性质. 插入可能违反的性质是第四条, 即红色节点的子节点必须是黑色的. 因此我们需要不断旋转以并从下向上调整以维持其性质. 并且在调整的过程中, 一次调整之后保证子树的第四条原则成立的同时还可能破坏其父节点的第四条性质. 调整的终止条件即为, 调整后其父节点为黑色. 下图展示了插入节点破坏性质4的情况.</p>
<p><img src="https://s2.ax1x.com/2019/06/16/Voj6De.png" alt="破坏性质4"></p>
<p>当前节点Z与其父节点由于不满足第四条性质而需要进行调整时, 可能出现六种情况, 其中前三种与后三种对称, 这取决于z的父节点是z的祖父节点的左孩子还是又孩子. 这里只讨论前三种情况.</p>
<h3 id="情况一-z的叔父节点为红色"><a href="#情况一-z的叔父节点为红色" class="headerlink" title="情况一: z的叔父节点为红色"></a>情况一: z的叔父节点为红色</h3><p>此时的处理相对简单, 由于z的叔父节点是红色, z的父节点也是红色, z本身也是红色, 只有z的祖父节点是黑色, 则只用将z的父节点与叔节点变换成黑色, 祖父节点变成红色(将祖父节点变红是为了维持第无条性质不变, 即路径中多了一个黑色节点, 就要将原来的一个黑色节点变红.). 这时, z和z的父节点和叔节点都满足性质, 于是将z上移两层, 使z指向原来z的祖父节点, 继续进行判断. 图示如下:</p>
<p><img src="https://s2.ax1x.com/2019/06/16/VojB36.png" alt="情况一"></p>
<h3 id="情况二-z的叔节点y为黑色-且z是一个右孩子"><a href="#情况二-z的叔节点y为黑色-且z是一个右孩子" class="headerlink" title="情况二: z的叔节点y为黑色, 且z是一个右孩子"></a>情况二: z的叔节点y为黑色, 且z是一个右孩子</h3><p>对z进行一次左旋即变成情况三.</p>
<h3 id="情况三-z的叔节点y为黑色-且z是一个左孩子"><a href="#情况三-z的叔节点y为黑色-且z是一个左孩子" class="headerlink" title="情况三: z的叔节点y为黑色, 且z是一个左孩子"></a>情况三: z的叔节点y为黑色, 且z是一个左孩子</h3><p>此时, z和z的父节点为红色, z的叔节点为黑色. 我们只需要将z的父节点变成黑色, z的祖父节点变成黑色, 而后以祖父节点作为旋转点进行一次右旋即可. (右旋的目的是保持性质五不变, 将父节点变成黑色将导致祖父节点左子树的黑高比右子树的大, 进行一次旋转后则保证原来祖父位置的左右子树的黑高均不变.) 图示如下:</p>
<p><img src="https://s2.ax1x.com/2019/06/16/VojDgK.png" alt="情况二, 三"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a><center><font size="10">删除</font></center></h2><p>删除操作应该是红黑树中最难的部分了,  应该是面试的重灾区. 其中处理的操作也是相当窒息, 不得不佩服先人的智慧. 下面进行详细介绍. </p>
<p>从红黑树中删除某个节点, 被删除节点状态有两种.</p>
<h3 id="被删除节点状态一-被删节点左右子节点至少有一个没有"><a href="#被删除节点状态一-被删节点左右子节点至少有一个没有" class="headerlink" title="被删除节点状态一: 被删节点左右子节点至少有一个没有"></a>被删除节点状态一: 被删节点左右子节点至少有一个没有</h3><p>此时比较简单, 只需要将存在子节点的那个子节点移到原来节点位置, 并将原来节点删除即可.</p>
<h3 id="被删节点状态二-被删节点左右均存在子节点"><a href="#被删节点状态二-被删节点左右均存在子节点" class="headerlink" title="被删节点状态二: 被删节点左右均存在子节点"></a>被删节点状态二: 被删节点左右均存在子节点</h3><p>此时为了维护红黑树排序顺序, 应该将当前节点后继取出替换原来节点. 当前节点的后继一定满足左节点为空.此时需要将后继的右子树替换为后继原来的位置, 并将后继取出替换被删节点的位置. </p>
<p>删除节点后很有可能会破坏红黑树前述的五条性质, 此时为了能够统计进行修复, 我们应该合理设计上述的删除过程. 我们可以发现, 无论是情况一还是情况二, 在操作时均会有一步由子节点替换当前节点的操作. 即在情况一中, 被删节点存在的子节点替换当前节点, 在情况二中, 后继的右节点替换后继. 应该为了方便统一处理. 我们在情况二中, 在用后继替换被删节点时应该保证节点颜色同时替换, 此时可以看做应该删除位置实际没有变化, 变化只发生在后继节点的位置(从颜色上看, 可以简单的认为其实被删除节点是后继节点), 这将方便我们后续的修复红黑树性质的操作.</p>
<p>而后我们分析进行上述操作后将会破坏哪些性质. 当被删除节点为红色时, 所以性质均不会被破坏. 只有当被删节点为黑色时性质会被破坏, 且必然被破坏. 由于被删除节点可能是根节点, 因此子节点上移可能是一个红色节点上移, 因此性质二(根节点为黑色)可能被破坏. 当在子节点上移时, 如果子节点本身是红色的, 并且被删节点的父节点也是红色的, 则性质四(红色节点的子节点均为黑色)会被破坏, 由于删除了一个黑色节点, 其父代节点的黑高均会减少一, 此时性质五将会被破坏. 因此总共有三条性质可能被破坏.</p>
<p>当上移节点为红色时处理相对简单. 上移的节点均为红色, 此时我们只需要将上移的节点变成黑色即可维护红黑树性质.(此时根节点为黑色, 红色节点下也不会出现红色节点, 黑高减一也会由于上移的节点由红色变为黑色而恢复).  当上移节点为黑色时, 实际只有性质吴被破坏了, 但处理相对复杂. </p>
<p>下面就是最秀的操作了. 为了解决父辈黑高少一的问题, 我们在原本就是黑色节点上在加一层黑色(并不是要再在节点上添加一个元素, 而是以双重黑色看待这个节点), 并且这层黑色是可以传递的, 当我们将这个节点的黑心消去时, 对对应的就应该有一个组节点应该增加一个黑色. 如果对应的只有一个红色节点增加黑色, 则将该节点变成红色即可使红黑树性质得以恢复. 此时的处理又分为八种种情况(前四种与后四中对称). x为当前节点, w为兄弟节点. 注意, x为双重黑色节点.</p>
<h3 id="情况一-x的兄弟节点w是红色的"><a href="#情况一-x的兄弟节点w是红色的" class="headerlink" title="情况一: x的兄弟节点w是红色的"></a>情况一: x的兄弟节点w是红色的</h3><p>此时, 我们将兄弟节点变成黑色的, 将父节点变成红色并绕着父节点右旋, 此时即将情况一转化为情况二,三,四中的一个.</p>
<h3 id="情况二-x的兄弟节点w为黑色-且w的两个子节点均为黑色"><a href="#情况二-x的兄弟节点w为黑色-且w的两个子节点均为黑色" class="headerlink" title="情况二: x的兄弟节点w为黑色, 且w的两个子节点均为黑色"></a>情况二: x的兄弟节点w为黑色, 且w的两个子节点均为黑色</h3><p>此时我们直接从当前节点和兄弟节点中退去一层黑色, 此时当前节点依然是黑色, 其兄弟节点变换成红色. 与之对应的, 父节点一个加一层黑色. 将当前节点指向父节点, 考察父节点情况.</p>
<h3 id="情况三-x的兄弟节点w是黑色的-w的左孩子为红色的-w的左孩子为红色的-w的右孩子为黑色的"><a href="#情况三-x的兄弟节点w是黑色的-w的左孩子为红色的-w的左孩子为红色的-w的右孩子为黑色的" class="headerlink" title="情况三: x的兄弟节点w是黑色的, w的左孩子为红色的, w的左孩子为红色的, w的右孩子为黑色的."></a>情况三: x的兄弟节点w是黑色的, w的左孩子为红色的, w的左孩子为红色的, w的右孩子为黑色的.</h3><p>我们可以交换w和其左孩子的颜色, 而后对w进行右旋而不违背红黑树任何性质. 此时我们就将情况三转变到情况四.</p>
<h3 id="情况四-x的兄弟节w点是黑色的-且w的右孩子为红色的"><a href="#情况四-x的兄弟节w点是黑色的-且w的右孩子为红色的" class="headerlink" title="情况四: x的兄弟节w点是黑色的, 且w的右孩子为红色的."></a>情况四: x的兄弟节w点是黑色的, 且w的右孩子为红色的.</h3><p>此时, 我们将当前节点和其兄弟节点中去掉一层黑色, 此时我们让兄弟节点的右孩子变成黑色, 互换兄弟节点和父节点的颜色, 而后绕父节点左旋, 随后我们就可以去掉当前节点的一层黑色并且不违反任一性质. 此时变换即结束. 让当前节点指向根节点,在下一次循环即退出.</p>
<p>图示:</p>
<p><img src="https://s2.ax1x.com/2019/06/16/VojcHH.png" alt="插入情况"></p>
<h2 id="获取指定元素的左右边界"><a href="#获取指定元素的左右边界" class="headerlink" title="获取指定元素的左右边界"></a>获取指定元素的左右边界</h2><p>在set中, 我们可以查找指定元素的做哟边界, 这里我们也尝试实现这一功能. 这里我设计里两个函数, 分别是Right_side_min以及Left_side_max分别表示获取右边最小值(后继)以及左边最大值(前驱).</p>
<p>在查找边界时, 对于Right_side_min是寻找第一个大于指定元素的节点, Left_side_max是小于指定元素的最后一个. 此时我们可以使用两个指针进行操作, 对于Right_side_min, 第一个指针记录搜索到当前遇到的大于指定节点的最后一个, 第二个指针表示当前搜索到达位置, 对于Left_side_max来说, 第一个表示搜索到当前遇到的小于指定元素的最后一个, 第二个指针表示当前搜索到达位置. 搜索终止条件为遇到与指定元素值相同的元素或者搜索到哨兵节点(即最终也未找到对应元素). 对应于这两个结果, 处理策略也不同.</p>
<h3 id="树中存在节点与指定值一致"><a href="#树中存在节点与指定值一致" class="headerlink" title="树中存在节点与指定值一致"></a>树中存在节点与指定值一致</h3><p>此时, 我们应该考虑其是否存在子节点, 对于Right_side_min来说, 如果存在右子树, 则应该是右子树中最小值.如果没有右子树则一个返回第一个指定记录的大于当前节点的最后一个. 对于Left_side_max来说, 如果存在左子树, 则应该是左子树中最小的一个, 如果不存在左子树, 应该是第一个指针中记录的小于当前节点的最后一个.</p>
<h3 id="树中不存在节点与指定值一致"><a href="#树中不存在节点与指定值一致" class="headerlink" title="树中不存在节点与指定值一致"></a>树中不存在节点与指定值一致</h3><p>此时, 不用考虑子树问题了, 因为搜索的终止条件为到达树的末端, 此时对于两个来说都是直接返回第一个指针即可.</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a><center><font size="10">code</font></center></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> color;</span><br><span class="line">    T key;</span><br><span class="line">    node *Right;</span><br><span class="line">    node *Left;</span><br><span class="line">    node *Parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树模板, 将类内函数调用的函数分装成private类型, 只开放接口函数. 实现了接近set的功能, 不能输入key值是非法的. 会在某些地方出现错误</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RB_TREE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node&lt;T&gt; *Root;</span><br><span class="line">    node&lt;T&gt; *Sentry;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Left_Rotate</span><span class="params">(node&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Right_Rotate</span><span class="params">(node&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RB_INSERT_FIX</span><span class="params">(node&lt;T&gt; *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RB_DELETE_FIX</span><span class="params">(node&lt;T&gt; *)</span></span>;</span><br><span class="line">    node&lt;T&gt;* min(node&lt;T&gt; *);</span><br><span class="line">    node&lt;T&gt;* max(node&lt;T&gt;* );</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RB_TRANSPLANT</span><span class="params">(node&lt;T&gt;*, node&lt;T&gt; *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RB_TREE();</span><br><span class="line">    node&lt;T&gt;* insert(T);</span><br><span class="line">    node&lt;T&gt;* to_delete(T);</span><br><span class="line">    node&lt;T&gt;* find(T);</span><br><span class="line">    node&lt;T&gt;* Right_side_min(T);</span><br><span class="line">    node&lt;T&gt;* Left_side_max(T);</span><br><span class="line">    node&lt;T&gt;* get_max();</span><br><span class="line">    node&lt;T&gt;* get_min();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化, 哨兵节点Sentry为黑色</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">RB_TREE</span>&lt;T&gt;:</span>:RB_TREE()</span><br><span class="line">&#123;</span><br><span class="line">    Sentry = <span class="keyword">new</span> node&lt;T&gt;;</span><br><span class="line">    Sentry-&gt;Parent = Sentry;</span><br><span class="line">    Sentry-&gt;color = BLACK;</span><br><span class="line">    Root = Sentry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RB_TREE</span>&lt;T&gt;:</span>:Left_Rotate(node&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;T&gt; *y = x-&gt;Right;</span><br><span class="line">    x-&gt;Right = y-&gt;Left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;Left != Sentry)</span><br><span class="line">        y-&gt;Left-&gt;Parent = x;</span><br><span class="line">    y-&gt;Parent = x-&gt;Parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Parent == Sentry)</span><br><span class="line">        Root = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;Parent-&gt;Left == x)</span><br><span class="line">            x-&gt;Parent-&gt;Left = y;</span><br><span class="line">        <span class="keyword">else</span> x-&gt;Parent-&gt;Right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;Left = x;</span><br><span class="line">    x-&gt;Parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RB_TREE</span>&lt;T&gt;:</span>:Right_Rotate(node&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;T&gt; *y = x-&gt;Left;</span><br><span class="line">    x-&gt;Left = y-&gt;Right;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;Right!=Sentry)</span><br><span class="line">        y-&gt;Right-&gt;Parent = x;</span><br><span class="line">    y-&gt;Parent = x-&gt;Parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Parent == Sentry)</span><br><span class="line">        Root = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;Parent-&gt;Left == x)</span><br><span class="line">            x-&gt;Parent-&gt;Left = y;</span><br><span class="line">        <span class="keyword">else</span> x-&gt;Parent-&gt;Right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;Right = x;</span><br><span class="line">    x-&gt;Parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:insert(T a)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;T&gt; *z = <span class="keyword">new</span> node&lt;T&gt;;</span><br><span class="line">    z-&gt;key = a;</span><br><span class="line">    node&lt;T&gt; *y = Sentry;</span><br><span class="line">    node&lt;T&gt; *x = Root;</span><br><span class="line">    <span class="keyword">while</span>(x!=Sentry)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;x-&gt;key)</span><br><span class="line">            x = x-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;Parent = y;</span><br><span class="line">    <span class="keyword">if</span>(y == Sentry)</span><br><span class="line">    &#123;</span><br><span class="line">        Root = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;y-&gt;key)</span><br><span class="line">            y-&gt;Right = z;</span><br><span class="line">        <span class="keyword">else</span> y-&gt;Left = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;Left = Sentry;</span><br><span class="line">    z-&gt;Right = Sentry;</span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    RB_INSERT_FIX(z);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复由于插入导致的性质破坏</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RB_TREE</span>&lt;T&gt;:</span>:RB_INSERT_FIX(node&lt;T&gt; *z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;Parent-&gt;color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;Parent == z-&gt;Parent-&gt;Parent-&gt;Left)</span><br><span class="line">        &#123;</span><br><span class="line">            node&lt;T&gt; *y = z-&gt;Parent-&gt;Parent-&gt;Right;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;Parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;Parent-&gt;Parent-&gt;color = RED;</span><br><span class="line">                z = z-&gt;Parent-&gt;Parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(z == z-&gt;Parent-&gt;Right)</span><br><span class="line">                &#123;</span><br><span class="line">                    z = z-&gt;Parent;</span><br><span class="line">                    Left_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;Parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;Parent-&gt;Parent-&gt;color = RED;</span><br><span class="line">                Right_Rotate(z-&gt;Parent-&gt;Parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node&lt;T&gt; *y = z-&gt;Parent-&gt;Parent-&gt;Left;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;Parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;Parent-&gt;Parent-&gt;color = RED;</span><br><span class="line">                z = z-&gt;Parent-&gt;Parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(z == z-&gt;Parent-&gt;Left)</span><br><span class="line">                &#123;</span><br><span class="line">                    z =z-&gt;Parent;</span><br><span class="line">                    Right_Rotate(z);</span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;Parent-&gt;color = BLACK;</span><br><span class="line">                z-&gt;Parent-&gt;Parent-&gt;color = RED;</span><br><span class="line">                Left_Rotate(z-&gt;Parent-&gt;Parent);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找指定key对应元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:find(T a)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;T&gt;* x = Root;</span><br><span class="line">    <span class="keyword">while</span>(x!=Sentry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;key == a)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x-&gt;key &gt; a)</span><br><span class="line">            &#123;</span><br><span class="line">                x = x-&gt;Left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x = x-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找指定子树中最大值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:max(node&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(x-&gt;Right!=Sentry)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x-&gt;Right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找指定子树中最小值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:min(node&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(x-&gt;Left!=Sentry)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x-&gt;Left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找整个树最大值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:get_max()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> max(Root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找整个树的最小值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:get_min()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> min(Root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现节点间转移</span></span><br><span class="line"><span class="comment">// 此处转移中, dst为目标位置的节点,src为原来位置的节点,dst是随后要被销毁或者后续处理的对象,</span></span><br><span class="line"><span class="comment">// 因此不用考虑dst的问题, 只需建立src与dst-&gt;Parent的关系即可.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RB_TREE</span>&lt;T&gt;:</span>:RB_TRANSPLANT(node&lt;T&gt;*dst, node&lt;T&gt;*src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(dst == Root)</span><br><span class="line">    &#123;</span><br><span class="line">        Root = src;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dst == dst-&gt;Parent-&gt;Left)</span><br><span class="line">        &#123;</span><br><span class="line">            dst-&gt;Parent-&gt;Left = src;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> dst-&gt;Parent-&gt;Right = src;</span><br><span class="line">    &#125;</span><br><span class="line">    src-&gt;Parent = dst-&gt;Parent;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除key值指定的节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:to_delete(T a)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;T&gt; *x = find(a);</span><br><span class="line">    <span class="keyword">if</span>(x == Sentry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    node&lt;T&gt; *y = x;</span><br><span class="line">    node&lt;T&gt; *z;</span><br><span class="line">    <span class="keyword">int</span> save_color = x-&gt;color;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;Left == Sentry)</span><br><span class="line">    &#123;</span><br><span class="line">        z = x-&gt;Right;</span><br><span class="line">        RB_TRANSPLANT(x, x-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;Right == Sentry)</span><br><span class="line">        &#123;</span><br><span class="line">            z = x-&gt;Left;</span><br><span class="line">            RB_TRANSPLANT(x, x-&gt;Left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = min(x-&gt;Right);</span><br><span class="line">            save_color = y-&gt;color;</span><br><span class="line">            z = y-&gt;Right;</span><br><span class="line">            <span class="comment">//如果后继不是被删节点的右孩子,则构建出被删节点更新后的右子树, 即将后继的右孩子上移, 并将后继连接到被删节点的右孩子上.</span></span><br><span class="line">            <span class="keyword">if</span>(y!=x)</span><br><span class="line">            &#123;</span><br><span class="line">                RB_TRANSPLANT(y, y-&gt;Right);</span><br><span class="line">                y-&gt;Right = x-&gt;Right;</span><br><span class="line">                y-&gt;Right-&gt;Parent = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新的右子树绑定到被删节点原来的位置.</span></span><br><span class="line">            RB_TRANSPLANT(x, y);</span><br><span class="line">            y-&gt;Left = x-&gt;Left;</span><br><span class="line">            y-&gt;Left-&gt;Parent = y;</span><br><span class="line">            y-&gt;color = x-&gt;color; <span class="comment">// 使被删节点的颜色在替换后不变, 方便维护红黑树性质.</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(save_color == BLACK)</span><br><span class="line">    &#123;</span><br><span class="line">        RB_DELETE_FIX(z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复由于删除导致的性质破坏</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RB_TREE</span>&lt;T&gt;:</span>:RB_DELETE_FIX(node&lt;T&gt; *x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=Root &amp;&amp; x-&gt;color == BLACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == x-&gt;Parent-&gt;Left)</span><br><span class="line">        &#123;</span><br><span class="line">            node&lt;T&gt; *w = x-&gt;Parent-&gt;Right;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;Parent-&gt;color = RED;</span><br><span class="line">                Left_Rotate(x-&gt;Parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;Left-&gt;color == BLACK &amp;&amp; w-&gt;Right-&gt;color == BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    x = x-&gt;Parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(w-&gt;Left-&gt;color == RED &amp;&amp; w-&gt;Right-&gt;color == BLACK)</span><br><span class="line">                    &#123;</span><br><span class="line">                        swap(w-&gt;color, w-&gt;Left-&gt;color);</span><br><span class="line">                        Right_Rotate(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        w-&gt;Right-&gt;color = BLACK;</span><br><span class="line">                        swap(w-&gt;color, x-&gt;Parent-&gt;color);</span><br><span class="line">                        Left_Rotate(x-&gt;Parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node&lt;T&gt; *w = x-&gt;Parent-&gt;Left;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;Parent-&gt;color = RED;</span><br><span class="line">                Right_Rotate(x-&gt;Parent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;Left-&gt;color == BLACK &amp;&amp; w-&gt;Right-&gt;color == BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    x = x-&gt;Parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(w-&gt;Left-&gt;color == BLACK &amp;&amp; w-&gt;Right-&gt;color == RED)</span><br><span class="line">                    &#123;</span><br><span class="line">                        w-&gt;color = RED;</span><br><span class="line">                        w-&gt;Right-&gt;color = BLACK;</span><br><span class="line">                        Left_Rotate(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        w-&gt;Left-&gt;color = BLACK;</span><br><span class="line">                        swap(x-&gt;Parent-&gt;color, w-&gt;color);</span><br><span class="line">                        Right_Rotate(x-&gt;Parent);</span><br><span class="line">                        x = Root;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按先序遍历输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">RB_TREE</span>&lt;T&gt;:</span>:print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root == Sentry)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt; node&lt;T&gt;* &gt; w;</span><br><span class="line">    node&lt;T&gt; *t;</span><br><span class="line">    w.push(Root);</span><br><span class="line">    <span class="keyword">while</span> (!w.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t = w.top();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t-&gt;key&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        w.pop();</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Left != Sentry)</span><br><span class="line">            w.push(t-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;Right != Sentry)</span><br><span class="line">            w.push(t-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找指定key值有右边界, 即后继</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:Right_side_min(T a)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;T&gt;*y = Sentry;</span><br><span class="line">    node&lt;T&gt;*x = Root;</span><br><span class="line">    <span class="keyword">while</span>(x!=Sentry&amp;&amp;x-&gt;key!=a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;key&gt;a)</span><br><span class="line">        &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            x = x-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> x = x-&gt;Right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == Sentry || x-&gt;Right == Sentry)</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">   <span class="keyword">return</span> min(x-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找指定key的左边界, 即前驱</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">node</span>&lt;T&gt;* <span class="title">RB_TREE</span>&lt;T&gt;:</span>:Left_side_max(T a)</span><br><span class="line">&#123;</span><br><span class="line">    node&lt;T&gt;*y = Sentry;</span><br><span class="line">    node&lt;T&gt;*x = Root;</span><br><span class="line">    <span class="keyword">while</span>(x!=Sentry&amp;&amp;x-&gt;key!=a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;key&lt;a)</span><br><span class="line">        &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            x = x-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> x = x-&gt;Left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == Sentry || x-&gt;Left == Sentry)</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">   <span class="keyword">return</span> max(x-&gt;Left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/sort/" itemprop="url">sort</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-12T23:33:18+08:00">
                2019-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序"><a href="#序" class="headerlink" title="序"></a><center><font size="10">序</font></center></h1><p>排序作为最基础的算法, 应用更是十分广泛, 从刚开始接触编程开始一直到学习算法始终伴随着我们, 把排序完全理解, 常规的算法与数据结构基本理解了一半了吧(有吗?, 差不多吧). 这里对排序算法进行一次整理, 从最简单的冒泡排序到高端的快排和堆排. 均以从小到大的顺序举例.</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title=" 冒泡排序"></a><center><font size="10"> 冒泡排序</font></center></h1><p>原理十分简单, 对于一个长度为$ n$数组, 遍历$n-1$次, 每次遍历时判断相邻两个值大小, 如果不满足顺序则进行交换, 这样, 第$i$次遍历数组中第$i$大的元素就会被排序到导数第$i$的位置. 这样遍历$n-1$次后即完成排序. 时间复杂度为$O(n^2)$</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">bubbling_sort</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title=" 插入排序"></a><center><font size="10"> 插入排序</font></center></h1><p>插入排序原理也十分简单, 与冒泡类似, 对与一个长度为$n$的数组, 进行$n-1$次遍历, 每次选取对大的未排序完成的部分中最大的与最后一个未完成排序的元素交换, 这样未完成排序的元素将减少一个. 复杂度为$O(n^2)$.</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert_sort</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[index]&lt;a[j])</span><br><span class="line">                index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[index], a[n-i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title=" 归并排序"></a><center><font size="10"> 归并排序</font></center></h1><p>归并排序使用到了分治的思想, 将一个数组分为两部分, 并分别将两部分排序完成, 而后只用对两个排序好的子序列进行合并即可. 对两个子序列的合并操作也使用相同的策略, 递归的进行. 在进行合并的时候, 需要将原来的数组排序结果保存到另一个数组中, 空间复杂度为$O(n)$.  归并排序时间复杂度为$O(nlog(n))$. 典型应用为求逆序对数.</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge_sort</span>(<span class="title">T</span> <span class="title">dst</span>[], <span class="title">T</span> <span class="title">src</span>[], <span class="title">int</span> <span class="title">start</span>, <span class="title">int</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(end - start &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(end - start == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(src[start] &gt; src[end])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(src[end], src[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        dst[end] = src[end];</span><br><span class="line">        dst[start] = src[end];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mod = (start+end)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(dst, src, start, mod);</span><br><span class="line">    merge_sort(dst, src, mod+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">int</span> p=start, q=mod+<span class="number">1</span>, k=start;</span><br><span class="line">    <span class="keyword">while</span>(p!=mod+<span class="number">1</span> &amp;&amp; q!=end+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(src[p]&lt;src[q])</span><br><span class="line">            dst[k++] = src[p++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dst[k++] = src[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==mod+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k; k&lt;end+<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            dst[k] = src[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k; k&lt;end+<span class="number">1</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            dst[k] = src[p++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;end+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        src[i] = dst[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a><center><font size="10">快排</font></center></h1><p>快排也使用的是分治的策略, 不过与归并不同的是, 归并指定了每次分割的位置(中间). 快排并不指定中间位置而是根据当前子序列的第一(最后一个)个元素的大小进行划分, 分成大于它的和小于它的两部分, 而后对这两部分再进行分类.  对这两部分分类也是采取递归的策略.  快排最差情况下时间复杂度为$O(n^2)$, 期望时间复杂度为$O(nlog(n))$. 典型应用为线性时间求取数组中第K大数.</p>
<p>code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void quite_sort(T a[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(end-start &lt; 1)</span><br><span class="line">        return;</span><br><span class="line">    if(end-start == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[start]&gt;a[end])</span><br><span class="line">            swap(a[start], a[end]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int key = a[start], i=start, j=end;</span><br><span class="line">    while (i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        while(i&lt;j &amp;&amp;  key &lt; a[j])</span><br><span class="line">            j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        while(i&lt;j &amp;&amp; key &gt; a[i])</span><br><span class="line">            i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    quite_sort(a, start, i-1);</span><br><span class="line">    quite_sort(a, i+1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a><center><font size="10">堆排</font></center></h1><p>堆排使用了二叉树, 在二叉树中维护一个性质, 即大顶堆或者小顶堆. 首先我们要将一个数组构建成为一个满足大顶堆或者小顶堆的一个完全二叉树. 而后我们每一次将大顶堆中的堆顶元素与未排序完成的堆的最后一个元素交换位置, 同时从堆中删除堆最后一个元素(即之前的最大值). 同时要保证交换完成之后的堆保持原来大顶堆的性质. 逐步进行, 直到将整个堆完全删除, 即得到排序完成的数组.</p>
<h2 id="从数组构建满足要求的完全二叉树"><a href="#从数组构建满足要求的完全二叉树" class="headerlink" title="从数组构建满足要求的完全二叉树:"></a><font size="6">从数组构建满足要求的完全二叉树:</font></h2><p>对于长度为$n$的元素, 只有索引小于等于int(n/2)的位置有叶节点. 对于非叶节点来说, 其自然满足大顶堆性质, 对于存在页节点的元素来说, 我们要使其满足大顶堆性质则要进行判断是否满足父节点大于两个子节点. 如果满足, 则该节点满足条件, 不用有任何操作(注意: 我们在访问某个节点使其满足大顶堆性质时, 即子树必然已经满足该性质, 这是因为我们的操作是自底向上进行的, 越底部越先被满足). 如果不满足条件则要进行调整. 但调整后我们可能会破坏子树的大顶堆性质, 此时我们应该顺着可能被破坏大顶堆性质的子数进行搜索, 维持大顶堆性质. 时间复杂度为$O(nloh(n))$.</p>
<h2 id="堆顶与最后一个值进行交换"><a href="#堆顶与最后一个值进行交换" class="headerlink" title="堆顶与最后一个值进行交换:"></a><font size="6">堆顶与最后一个值进行交换:</font></h2><p>当交换完成后, 大顶堆的性质很有可能被破坏, 此时我们也要进行操作以维护大顶堆性质. 从堆顶自顶向下进行搜索, 将不满足大顶堆性质的节点进行交换. </p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护大顶堆性质</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">remain_max_heap</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">index</span>, <span class="title">int</span> <span class="title">length</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(index*<span class="number">2</span>&lt;=length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index*<span class="number">2</span> +<span class="number">1</span> &lt;=length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[index]&lt;a[index*<span class="number">2</span>] &amp;&amp; a[index*<span class="number">2</span>+<span class="number">1</span>]&lt;a[index*<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(a[index], a[index*<span class="number">2</span>]);</span><br><span class="line">                index = index*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[index]&lt;a[index*<span class="number">2</span>+<span class="number">1</span>] &amp;&amp; a[index*<span class="number">2</span>]&lt;a[index*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(a[index], a[index*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                    index = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[index]&lt;a[index*<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(a[index], a[index*<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">heap_sort</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">length</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 将数组转化为满足大顶堆性质的完全二叉树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=length/<span class="number">2</span>; i&gt;<span class="number">-1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        remain_max_heap(a, i, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序, 取堆顶元素进行交换.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[<span class="number">0</span>], a[length-i]);</span><br><span class="line">        remain_max_heap(a, <span class="number">0</span>, length-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/09/c-复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/c-复习/" itemprop="url">c++复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T23:19:51+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/语言/" itemprop="url" rel="index">
                    <span itemprop="name">语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <center><font size="12"> C++复习</font></center>


<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="变量申明与定义"><a href="#变量申明与定义" class="headerlink" title="变量申明与定义"></a>变量申明与定义</h2><p>申明: 使得名字为程序所知． extern int i;  //申明(前面有extern)</p>
<p>定义: 创建与名字关联实体.    int  j;  //申明并定义j</p>
<p>重点: 多个文件之间使用同一个变量, 只能在一个文件下对变量定义, 在其他文件下要申明.(extern: 外部的).</p>
<h2 id="引用-amp"><a href="#引用-amp" class="headerlink" title="引用(&amp;)"></a>引用(&amp;)</h2><p>引用是一个别名, 引用类型引用另一种类型. 使用&amp;d的形式定义. d为申明的变量名. <strong>引用不可重新绑定到另一个对象上, 同时引用必须初始化</strong>. 这时对引用和对原来对象的操作一样. 引用类型初始必须是一个对象, 不能是常量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line"></span><br><span class="line">int &amp;d = a;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针(*)"></a>指针(*)</h2><p>指针本身是一个对象(引用不是), 允许对指针赋值和拷贝, 在生命周期内可以指向不同对象.</p>
<p>指针无需定义时赋值.</p>
<p><strong>引用不是对象(别名), 没有实际地址, 不能定义指向引用的指针.</strong></p>
<p><strong>所以指针类型都要与其指向对象类型严格匹配(不存在默认类型转化)</strong></p>
<p>void* 用来存放任意对象地址(只能存放地址, 不能直接操作所指对象, 由于不知道所指对象类型).</p>
<p>指向指针的指针(**)</p>
<p>指向指针的引用(*&amp;): 指针本身的引用, 与对象无关.</p>
<p>指针也是迭代器. 可以进行相减以及和整数加减操作.</p>
<h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><p>字符串指针比较特殊, 不能使用string对字符串指针进行初始化, 但可以使用.c_str()进行.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"uiguy"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *a = s.c_str();</span><br></pre></td></tr></table></figure>

<p>对字符串指针输出会是字符串本身, 响要输出原始地址则要求进行void*的转化.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"jdgdtyvds"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>&lt;&lt;(<span class="keyword">void</span> *)a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line">jdgdtyvds</span><br><span class="line"><span class="number">0x7ffc5ce91d22</span></span><br></pre></td></tr></table></figure>

<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><h3 id="const类型可以使用一个普通对象进行初始化-不要求是常量"><a href="#const类型可以使用一个普通对象进行初始化-不要求是常量" class="headerlink" title="const类型可以使用一个普通对象进行初始化(不要求是常量)."></a>const类型可以使用一个普通对象进行初始化(不要求是常量).</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n=20;</span><br><span class="line"></span><br><span class="line">const int w = n;</span><br></pre></td></tr></table></figure>

<h3 id="由于const要求定义时赋常量值当要求几个文件之间共享同一个const值时对申明和定义都采用extern表示-这样只需用定义一次"><a href="#由于const要求定义时赋常量值当要求几个文件之间共享同一个const值时对申明和定义都采用extern表示-这样只需用定义一次" class="headerlink" title="由于const要求定义时赋常量值当要求几个文件之间共享同一个const值时对申明和定义都采用extern表示,这样只需用定义一次."></a>由于const要求定义时赋常量值当要求几个文件之间共享同一个const值时对申明和定义都采用extern表示,这样只需用定义一次.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// a.cpp</span><br><span class="line"></span><br><span class="line">extern int bufsize = 128;</span><br><span class="line"></span><br><span class="line">//b.cpp</span><br><span class="line"></span><br><span class="line">extern int bufsze;</span><br></pre></td></tr></table></figure>

<h3 id="const引用-对常量的引用"><a href="#const引用-对常量的引用" class="headerlink" title="const引用(对常量的引用)"></a>const引用(对常量的引用)</h3><p>常量的引用必须是常量引用, 普通变量可以使用常量引用, 不过不能通过常量引用改变变量的值, 只能对变量进行更改.常量引用可以之间引用数组常量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line"></span><br><span class="line">const int &amp;r1 = ci; //对常量的引用</span><br><span class="line"></span><br><span class="line">const int &amp;r2 = 42; // 对数值常量的引用.</span><br><span class="line"></span><br><span class="line">int c1 = 12;</span><br><span class="line"></span><br><span class="line">const int &amp;r3 = c1; //对普通变量的引用.</span><br><span class="line"></span><br><span class="line">int &amp;r4 = ci; //错误, ci为常量, 必须使用常量引用.</span><br></pre></td></tr></table></figure>

<p>普通引用要求引用与原始对象类型完全一致, 而const引用不必如此. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double a = 3.14;</span><br><span class="line"></span><br><span class="line">int &amp; b = a; //错误, 非法操作</span><br><span class="line"></span><br><span class="line">const int &amp;b = a; //正确, 合法.</span><br></pre></td></tr></table></figure>

<p>这是由于定义一个引用肯定是希望该引用与原始对象完全一致, 要求两个中有一个更改另一个也会更改, 但是当类型不一致时, 正常操作是会定义一个临时变量来保证引用匹配,这将导致引用与原对象不一致, 无法做到同步更改, 也不符合引用的目的, 因此是非法的. 而对于常量引用来说就不存在这个问题, 常量引用本来就不希望通过引用对原始对象进行更改, 但需注意, 这里同样是存在临时变量, 因此改变原始值时, 常量引用不会改变.</p>
<p>即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double a=3.14; const int &amp; b = a;</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">double a=3.14; const int temp = a; const int &amp;b = temp;</span><br></pre></td></tr></table></figure>

<p>此时更改a不会影响b的值.</p>
<h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><p>指针(的)常量: 是一个常量, 并且属于指针, 即指针本身是常量, int * const</p>
<p>常量(的)指针: 是一个指针, 并且指向的对象是常量, 即指针本身不是常量, 指向的对象是常量: const int *.</p>
<p><strong>记忆方式, 从右向左度表达式,</strong></p>
<p>指针常量:　int * const:  最左边为const表示,该对象本身是一个常量, 其次才属于指针.</p>
<p>常量指针: const int <em>: 可以理解为\</em>是一个取指针元素的含义, 即*表示指向的对象, 外面在加上connst, 表示指向对象是常量.</p>
<p><strong>常量指针与常量引用类似, 可以使用非常量对象对常量指针初始化, 其目的是为了防止指针对原来对象进行更改.</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;c;</span><br><span class="line"></span><br><span class="line">c =<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<h3 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h3><p>顶层const表示任意对象本身是常量, 对任意数据类型都试用.</p>
<p>底层const表示指针或引用等复合类型所指对象是常量.</p>
<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>decltype(f()) sum = x;</p>
<p>decltype(f()) 返回表达式f()结果的类型. 用此类型对sum定义;</p>
<p>int *p;</p>
<p>decltype(*p) = int &amp; 而不是int 这是由于解引用可以访问对象还能够对对象赋值.</p>
<p>对变量加上一层或多层括号, 编译器会将其当为一个表达式, 变量是一中可以作为赋值语句左值的特殊表达式, 所以这时decltype会将其当做引用. 即 int i; decltype((i)) = int &amp;;</p>
<h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><p>形式: cast_name&lt;type&gt;(expression);</p>
<p>cast_name为 static_cast, dynamic_cast, const_cast, reinterpret_cast中的一种.</p>
<p>static_cast:</p>
<p>任何具有明确定义的类型转换, 只要不包含底层const, 都可以使用static_cast.</p>
<p>const_cast:</p>
<p>只能改变底层const.</p>
<p>ex:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *pc;</span><br><span class="line">char *p = const_cast&lt;char *&gt;(pc); //正确</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组下标[]比解指针优先级高.</p>
<p>因此  </p>
<p>指针数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">10</span>]; <span class="comment">//表示的是指针的数组(是数组, 元素是指针)</span></span><br></pre></td></tr></table></figure>

<p>不存在引用的数组.</p>
<p>数组之间不能直接赋值.</p>
<p>数组(的)指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">10</span>] = &amp;arr;<span class="comment">//指向元素为10个整数数组的指针.</span></span><br></pre></td></tr></table></figure>

<p>数组的指针相当于构建了一个二维指针,其中第一维始终是0,  (*p)可以看做p[] (但是却不能直接写p[0][10], 这对应的是一个二维数组元素). 其中arr本来就是数组首地址, 再对其取址其实是没有用的(或许有?), 返回依然是原来地址. 下个例子说明:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w[] = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>&lt;&lt;&amp;w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> (*q)[<span class="number">3</span>] = &amp;w;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(*q)[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q[<span class="number">0</span>][i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;q[<span class="number">0</span>][i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line"><span class="number">0x7ffd5cd9ca88</span></span><br><span class="line"><span class="number">0x7ffd5cd9ca88</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0x7ffd5cd9ca88</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0x7ffd5cd9ca94</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">0x7ffd5cd9caa0</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>可以看到w和&amp;w输出一致, (*q)[i]与q[0][i]输出一致.</p>
<p>数组与指针类似. 当一个指针指向数组中某个元素是, 在拿这个指针使用索引访问数组元素等价于将该地址按照索引进行移动后解地址.</p>
<p>begin()与end()函数: 分别返回数组中第一个元素与最后一个元素下一个位置的地址.</p>
<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"ajjh0"</span>; <span class="comment">//长度为6, 因为后面默认存在一个空字符'\0'作为结尾.</span></span><br></pre></td></tr></table></figure>

<p>对于char型数组来说, 输出某个位置的地址时并不是直接输出地址, 而是输出该地址及之后位置的字符串, 同时对于字符串数组赋值来说, 可以使用在cin时赋值, 但不能使用string对其赋值.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="string">"digusgy0"</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> w = <span class="string">"ugyu"</span>;</span><br><span class="line"></span><br><span class="line">a = w; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>不存在多维数组, 实质是数组的数组.</p>
<h2 id="C分格字符串"><a href="#C分格字符串" class="headerlink" title="C分格字符串"></a>C分格字符串</h2><p>cstring文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(p); <span class="comment">//计算长度, 不计算最后的空字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(p1, p2); <span class="comment">//比较两个字符串大小, &gt; 取1, &lt;取0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(p1, p2);<span class="comment">// 拼接两个字符串, 返回p1.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(p1, p2);<span class="comment">// 拷贝字符串从p2到p1, 返回p1.</span></span><br></pre></td></tr></table></figure>

<p>上述操作传入的参数必须是以空字符’\0’作为结尾的数组.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="built_in">strlen</span>(a); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"></span><br><span class="line">stlen(a); <span class="comment">//true. 输出3</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>sizeof 运算符: 计算表达式结果类型的大小. 满足右结合率. 对于数组, sizeof返回数组大小, 而不是指针,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span> expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span> *p;</span><br><span class="line">==</span><br><span class="line"><span class="keyword">sizeof</span> (*p);<span class="comment">//由于sizeof不会计算实际表达式, 使用p指向空地址也是合法的, 依然会返回对应类型大小(字节)</span></span><br></pre></td></tr></table></figure>

<p>一些重要的运算符优先级:</p>
<p>{::}(作用域) &gt; {‘,’, ‘-&gt;’, ‘[]’} &gt; {‘++’, ‘–’}(后置) &gt; {‘++’, ‘–’(后置), ‘*’(接地址), ‘&amp;’(取地址)}</p>
<h2 id="try语块与异常处理"><a href="#try语块与异常处理" class="headerlink" title="try语块与异常处理"></a>try语块与异常处理</h2><p>throw 表达式,引发异常. 即当检测到异常使用throw触发(抛出)异常.这时将终止当前函数, 并将控制权交给能够处理该错误的代码.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">throw</span> runtime_error(<span class="string">"number over the length"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>try语句块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (exception-declaration)&#123;.....&#125;</span><br><span class="line"></span><br><span class="line">catch (exception-declaration)&#123;.....&#125;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>catch捕获异常类型并相应做出处理.</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h2><p>在某个函数内定义一个变量,希望其生命周期为整个程序执行时间, 这时可以在前面添加static, 表示是一个局部静态对象. 此时每次调用该函数时, 均共享该参数, 不会重复初始化.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> num++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">cout</span>&lt;&lt;get_num()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>与类类似, 一般期望函数申明在头文件(.h), 定义在源文件(.cpp).</p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>传值参数:初始化非引用类型变量时，是将初始值拷贝给变量．此时对变量改动不会影响原来变量．</p>
<p>传引用参数：传引用参数是定义一个别名，对引用的更改会作用到原来对象上．</p>
<p>当定义参数为引用时应该尽量定义为常量引用，这是由于当传递参数为一个常数是，不能使用普通的引用来作用于常量．例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int add(int &amp;a, int &amp;b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(5, 6) //错误，５，６均为常值，这等于：int &amp;a = 5; int &amp;b = 6.</span><br><span class="line"></span><br><span class="line">int add(const int &amp;a, const int &amp;b)&#123;....&#125;　//这样就不会出错．</span><br></pre></td></tr></table></figure>

<p>但有时就是要使用引用来更改源对象值时则另当别论，但要注意使用条件．</p>
<h2 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main: 处理命令行选项"></a>main: 处理命令行选项</h2><p>main函数包含于可执行文件prog之内, 可以向程序传递下面的可选项.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *agry[])</span> </span>&#123;.....&#125;</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrc) &#123;......&#125;</span><br></pre></td></tr></table></figure>

<p>argc表示数组中字符串数量, argc是一个数组, 元素是指向C风格字符串的指针, 第一个元素指向程序的名字或者一个空字符串, 接下来的元素依次传递命令行的实参.</p>
<p>对于上面第一行, argv为5.</p>
<p>例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;argc;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input:</span><br><span class="line"></span><br><span class="line">./main hhj jkh jkj jkjnj</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line">./main</span><br><span class="line">hhj</span><br><span class="line">jkh</span><br><span class="line">jkj</span><br><span class="line">jkjnj</span><br></pre></td></tr></table></figure>

<h2 id="不应该返回局部对象的引用或指针"><a href="#不应该返回局部对象的引用或指针" class="headerlink" title="不应该返回局部对象的引用或指针"></a>不应该返回局部对象的引用或指针</h2><p>局部对象会在函数调用完成后被注销, 这是其引用与指针将会失效(不再有效).</p>
<h2 id="引用返回左值-即可当做变量被赋值"><a href="#引用返回左值-即可当做变量被赋值" class="headerlink" title="引用返回左值(即可当做变量被赋值)"></a>引用返回左值(即可当做变量被赋值)</h2><p>调用一个返回引用的函数将得到左值, 其他返回类型将得到右值.我们可以为返回结果为非常量引用的函数的结果赋值.</p>
<p>ex:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">char &amp;get_str(string &amp;str, int index)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return str[index];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    string a = &quot;hellow world&quot;;</span><br><span class="line"></span><br><span class="line">​    get_str(a, 0) = &apos;H&apos;;</span><br><span class="line"></span><br><span class="line">​    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">​    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line">Hellow world</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>要保证不同的函数之间存在差异, 存在默认类型转换的参数会被认为是一样的, 形参一致(或存在默认转换)返回类型不同一样会被认为重复定义.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会被认为重复定义了add.</p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分出来. 由于顶层const可以使用非const进行赋值,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span><span class="comment">//重复定义add</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> *w)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> w)</span><span class="comment">//重复定义process</span></span></span><br></pre></td></tr></table></figure>

<p>对于底层const来说是可以区分的(虽然const引用可以指向普通常量, 编译器会更具实参是否为常量进行选择)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="comment">//均不会被认为是重复定义</span></span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 成员函数该函数希望通过引用对成员变量赋值, 隐含的参数为<span class="keyword">this</span>指针</span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">isbn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bookId;</span><br><span class="line">&#125;</span><br><span class="line"># 该函数只是希望读取类中对于数据, 隐含的参数是 <span class="keyword">const</span> <span class="keyword">this</span>, 这两个类内成员函数并不会被认为重复定义.</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bookId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认实参的默认参数放到后面-且要避免函数重复定义"><a href="#默认实参的默认参数放到后面-且要避免函数重复定义" class="headerlink" title="默认实参的默认参数放到后面, 且要避免函数重复定义"></a>默认实参的默认参数放到后面, 且要避免函数重复定义</h2><h2 id="内联函数-online-通常定义在头文件中"><a href="#内联函数-online-通常定义在头文件中" class="headerlink" title="内联函数(online)(通常定义在头文件中)"></a>内联函数(online)(通常定义在头文件中)</h2><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而不是对象.函数类型由其返回类型和形参共同决定而与函数名无关.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br></pre></td></tr></table></figure>

<p>其中(*pf)表示是一个指针, 右侧是形参列表, 表示其是指向的函数, 因此是函数指针.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">pf = &amp;lengthCompare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> b1 = pf(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>)</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> b3 = lenthCompare(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>)</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_first</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span>* (*w)(<span class="keyword">int</span> *);</span><br><span class="line"></span><br><span class="line">​    w = get_first;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">cout</span>&lt;&lt;*w(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="返回函数的指针"><a href="#返回函数的指针" class="headerlink" title="返回函数的指针"></a>返回函数的指针</h2><p>虽然函数不能直接返回函数, 但是能够返回指向函数的指针.(花里胡哨,有点难理解)</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类定义完成后一定要加分号, 这是由于类体后面可以紧跟着变量名(实例名).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Sales_item &#123; /*........*/&#125; accum, trans *salesptr;</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">struct Sales_item &#123; /*........ */&#125; ;</span><br><span class="line"></span><br><span class="line">Scales_item accum, trans *salesptr;</span><br></pre></td></tr></table></figure>

<p>编译器会先处理完全部申明再去处理成员函数定义, 因此数据成员定义的位置并不要求在成员函数之前.</p>
<h2 id="类别名"><a href="#类别名" class="headerlink" title="类别名"></a>类别名</h2><ol>
<li>typedef double wages, *p; wages表示double, *p表示double *.</li>
<li>using SI = Sales_item;</li>
</ol>
<p>类还可以自己定义某种类型在类中的别名, 并且具有访问权限的属性.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type pos;</span><br></pre></td></tr></table></figure>

<p>对此定义要放在使用pos之前.</p>
<p>类的成员必须是完全类型.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">​    ........</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">​    static Bar meml; // 正确, static不收必须是完整成员的限制.</span><br><span class="line"></span><br><span class="line">​    Bar *mem2; // 正确, 指针成员可以是不完整的(指针本身就是一个成员, 与指向无关)</span><br><span class="line"></span><br><span class="line">​    Bar mem3;//错误, 数据成员必须是完整类型.(Bar本身就在定义整体, 不完整)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>成员函数申明必须在类内, 定义可以在类内也可以在类外.</p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数通过名为this的隐式参数来访问调用它的那个对象. 当调用成员函数时, 用请求该函数的对象的地址初始化this. 例如: total.isbn(), 编译器首先会把total的地址传递给isbn的隐式形参this, 可以认为调用该函数的实际过程为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 原始函数, 类是sales_data</span><br><span class="line"></span><br><span class="line">string  Sales_data::isbn() const</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return bookNO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用代码, 实例为total:</span><br><span class="line"></span><br><span class="line">total.isbn();</span><br><span class="line"></span><br><span class="line">// 实际执行过程理解代码(伪代码):</span><br><span class="line"></span><br><span class="line">Sales_data::isbn(&amp;total)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    return this-&gt;bookNO</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们只需要对对象内元素进行访问而不进行更改时, 应该将this变换为一个常量指针. 这就是函数参数后const的含义.</p>
<h3 id="const-常量-成员函数"><a href="#const-常量-成员函数" class="headerlink" title="const(常量)成员函数"></a>const(常量)成员函数</h3><p>在上述代码中, 我们看到isbn的参数列表后紧跟着一个const关键字, 这是由于isbn成员函数只是为了进行访问对象元素, 而我们不希望对其内容进行更改, 因此对this指针进行赋值是我们希望其是常量指针.  然而默认情况下, this的类型是指针常量(即this本身不会变, 详见const与指针)而非常量指针. 以上述代码来看, this 类型是 .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data * const</span><br></pre></td></tr></table></figure>

<p>而我们希望的类型是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Sales_data * const</span><br></pre></td></tr></table></figure>

<p>因此C++对这一步的转化方式是在成员函数参数列表后面完成转化. 此时该成员函数只能访问对象, 无法更改对象.</p>
<p>特别的, 常量对象或者常量对象的引用和指针都只能调用常量成员函数.</p>
<h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><p>在上述const成员函数, 我们不允许对类内成员进行更改, 但有时我们又希望能够对类内部分元素进行更改, 此时我们可以设置可变数据成员, 只需要在普通的变量申明中加上mutable关键字.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutable int print_num = 0;</span><br></pre></td></tr></table></figure>

<p>这时, 即使是const成员函数也可以对其进行更改.</p>
<h3 id="返回this指针"><a href="#返回this指针" class="headerlink" title="返回this指针"></a><font color="red">返回this指针</font></h3><p>当我们定义的成员函数类似于每个内置运算符时, 我们应该尽可能的去模仿这个运算符.(为了使得当我们在使用时像内置运算符一样便捷高效, 对于之后的运算符重载是一样的).  内置的赋值运算符将左侧运算对象当做左值返回, 因此为了与其保持一致, 当定义的函数类似于内置运算符并且将对类中某个元素进行修改时我们应该返回引用类型(引用类型可以作为左值, 同时可以利用返回的引用对对应元素直接赋值). 这是由于当对类内元素进行变更时, 必然存在语句value = exper;(其中vale为类内元素). 而利用上文提到的this指针,我们知道, 实际等于this-&gt;value = expr; 这就等于a.value = expre; 因此对于更改类中对象的操作等于赋值语句(高端赋值). 因此要返回引用类型, 而对于类似内置运算符的函数一般返回应该就是其本身, 因此应该返回的是*this;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::combine(<span class="keyword">const</span> Sales_data &amp;a)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    units_sold += a.units_sold;</span><br><span class="line"></span><br><span class="line">​    revenue += a.revenue;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了说明这个操作类似内置运算符, 我们考虑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.combine(b.combine(c));</span><br></pre></td></tr></table></figure>

<p>操作, 这可以实现a+b+c, 而仅仅只是为了实现元素相加时, 我们可能往往让其返回void, 这时就不能完全上述操作.</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数名字与类名一致, 没有返回类型, 其他与成员函数没有不同,</p>
<p>当未手动定义构造函数是, 编译器会自动生成默认构造函数, 当自己定义了构造函数后依然希望存在默认构造函数时只需要在加上一个=default的构造函数即可.</p>
<p>构造函数初始化列表: 在构造函数参数之后使用类内成员(参数值)可以直接对类成员赋值. 且可以选择部分赋值不要求全部对象.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="keyword">unsigned</span> &amp;num, <span class="keyword">const</span> <span class="keyword">double</span> &amp;p): </span><br><span class="line"></span><br><span class="line">bookNO(s), units_sold(num),price(p), revenue(p*num)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>成员变量初始化的顺序取决于其定义的顺序, 因此有时要格外小心, 不能使用未初始的变量对另外的变量初始化</strong>.</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class a</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int j;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">​    a(int val) j(val), i(j) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这应该是有问题的代码, 正常初始化顺序是先i, 后j, 与构造函数后的初始化列表无关, 则这时我们会用未定义的j对i进行初始化, 这显然不是我们所期望的.</p>
<p>使用默认构造函数实例化时应该是classname instancename; 不能有括号, 不然会被认为是函数申明.</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数使用所属类的其他构造函数, 执行它自己的初始化过程, 把自己一些或全部责任委托给其他构造函数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非委托</span></span><br><span class="line">Screen(pos a, pos b, <span class="keyword">char</span> c): cursor(c),height(a), width(b) &#123;&#125; ;</span><br><span class="line"><span class="comment">// 委托上面的</span></span><br><span class="line">Screen(pos a):Screen(a, <span class="number">0</span>, <span class="string">' '</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝初始化通常由拷贝构造函数完成</p>
<p>无返回值, 名字与类名一致, 参数为常量类的引用:</p>
<p>参数由引用完成是因为如果传递一般的参数, 就会调用拷贝构造函数, 即调用直接, 这样就会一直调用下去直到溢出.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data(const Sales_data &amp;w)</span><br><span class="line">&#123;</span><br><span class="line">    bookNO = w.bookNO;</span><br><span class="line">    units_sold = w.units_sold;</span><br><span class="line">    revenue = w.revenue;</span><br><span class="line">    price = w.price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝初始化发生条件:</p>
<ol>
<li>使用”=”或使用s(s1)进行定义变量时发生.</li>
<li>将一个对象作为非引用参数时.</li>
<li>从一个函数返回非引用类型时</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类的成员时.</li>
</ol>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>用来对已存在对象赋值.</p>
<p>使用重载赋值运算符. 返回为类型引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; operator=(const Sales_data &amp;w)</span><br><span class="line">&#123;</span><br><span class="line">    bookNO = w.bookNO;</span><br><span class="line">    units_sold = w.units_sold;</span><br><span class="line">    revenue = w.revenue;</span><br><span class="line">    price = w.price;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝赋值运算符与拷贝构造函数区别为:<strong>调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sales_data s(&quot;dsjdbs&quot;, 20, 3.14); </span><br><span class="line">Sales_data s2 = s;//调用拷贝构造函数</span><br><span class="line">Sales_data s3; </span><br><span class="line">s3 = s;//调用拷贝赋值函数</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作, 释放对象使用资源, 销毁对象的非static成员.使用~classname();构成, 无参数和返回值.</p>
<h3 id="使用-default和-delete"><a href="#使用-default和-delete" class="headerlink" title="使用=default和=delete"></a>使用=default和=delete</h3><p>在上述的构造,赋值, 析构函数中, 定义函数是使用=default表示使用编译器自定义的函数, 使用=delete表示组织编译器自定义的默认函数.(析构函数不能使用=delete)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data() = default;</span><br><span class="line">Sale_data() = delete;</span><br><span class="line">Sales_data(const Sales_data&amp;) = defaule(delete);//使用默认拷贝,或阻止拷贝</span><br><span class="line">Sales_data&amp; operate=(const Sales_data&amp;) = default(delete);//使用默认赋值, 或阻止赋值</span><br><span class="line">~Sales_data() = default();</span><br></pre></td></tr></table></figure>

<h3 id="类数据成员初始化"><a href="#类数据成员初始化" class="headerlink" title="类数据成员初始化"></a>类数据成员初始化</h3><p>可以使用类名加上构造函数的参数实现对类的初始化.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sales_data w = Sales_data(<span class="string">"jygu"</span>, <span class="number">20</span>, <span class="number">25</span>);<span class="comment">// 初始化+赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// window_mgr类中数据成员</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Screen(<span class="number">24</span>, <span class="number">80</span>, <span class="string">' '</span>)&#125;; <span class="comment">// 使用上述方式进行初始化并对vector进行赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>成员与类本身无太大关系而与类的各个对象保持关联(例如统计类实例化的次数). 为此引入静态成员变量.</p>
<p>申明静态成员变量: 静态成员变量可以是public或private, 可以是常量, 引用. 指针, 类类型等等.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">​    <span class="string">'''</span><span class="string">'''</span>'</span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">​    ......</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用静态变量: 利用作用域运算符直接访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line">r = Account::rate();</span><br></pre></td></tr></table></figure>

<p>同时, 我们也可以使用类的实例来进行访问.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Account a;</span><br><span class="line"></span><br><span class="line">a.rate()</span><br></pre></td></tr></table></figure>

<p>成员函数可以直接对其进行修改, 任何实例均可.</p>
<p>静态成员初始化;</p>
<p>由于静态成员不属于任何一个对象, 因此定义应该在类外, 同时成员的static关键字只能出现在类内. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double Account::interestRate = expre;//初始化static</span><br></pre></td></tr></table></figure>

<p>对于静态成员属于常量表达式来说, 可以在类内进行定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static constexpr int period = 30;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝控制与资源管理"><a href="#拷贝控制与资源管理" class="headerlink" title="拷贝控制与资源管理"></a>拷贝控制与资源管理</h2><h3 id="类的行为像一个值"><a href="#类的行为像一个值" class="headerlink" title="类的行为像一个值"></a>类的行为像一个值</h3><p>类的行为像一个值意味着它有自己的状态. 当我们拷贝一个像值的对象时, 副本和原来的对象完全独立. 改变副本不会改变原对象. <strong>标准库容器与string类的行为均像一个值.</strong></p>
<h3 id="类的行为像一个指针"><a href="#类的行为像一个指针" class="headerlink" title="类的行为像一个指针"></a>类的行为像一个指针</h3><p>像指针的类共享状态, 拷贝一个这种类型时, 副本与原对象使用相同的底层数据. 改变其中一个另一个也会改变. 这种情况比较常见于shared_ptr与new. 这时应该注意析构函数的使用. 应该使用一个整型指针指向一个区域来记录有多少个对象正在共享当前区域, 当为0时才能将对应的底层空间释放. </p>
<h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><h4 id="右值引用-amp-amp"><a href="#右值引用-amp-amp" class="headerlink" title="右值引用(&amp;&amp;)"></a>右值引用(&amp;&amp;)</h4><p>右值引用只能绑定到将要销毁的对象上. 一个左值表达式表示的是一个对象的身份, 而一个右值表达式表示的是对象的值. 我们不能将左值引用绑定到要求转换的表达式. 字面值常量或者返回右值的表达式上. <strong>左值持久, 右值短暂.</strong> 左值有持久的状态, 而右值要么是字面值常量, 要么是在表达式求值过程中创建的临时对象.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i; <span class="comment">//true </span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i; <span class="comment">//false. 右值引用不能绑定到左值上.</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i*<span class="number">42</span>; <span class="comment">//false. 左值引用不能绑定到右值上.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i*<span class="number">42</span>;<span class="comment">//true; </span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i*<span class="number">42</span>;<span class="comment">//true. 右值引用绑定到右值上.</span></span><br></pre></td></tr></table></figure>

<p>变量表达式都是左值(即变量就是左值. 右值引用也是一个变量). 因此我们不能将右值引用绑定到右值引用上. 即:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> %%r1 = <span class="number">42</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = r1; <span class="comment">//false. r1是一个左值</span></span><br></pre></td></tr></table></figure>

<h4 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h4><p>我们可以显示的将一个左值转换为对应的右值引用类型. move可以获得绑定到左值上的右值的引用.(即将一个左值转换为右值).定义在utility中.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;r3 = <span class="built_in">std</span>::move(rr1);</span><br></pre></td></tr></table></figure>

<h4 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="移动构造函数与移动赋值运算符"></a>移动构造函数与移动赋值运算符</h4><p>移动构造函数的第一个参数是该类型的右值引用. 与构造函数不同, 移动构造函数不分配新内存, 而是接管原对象的内存. 在移动拷贝构造函数和移动赋值运算符运行结束之后, 会调用原来对象的析构函数, 此时如果存在动态内存时应该注意, 不能将动态内存delete, 由于新生成的类(或是新更改的类)与原来的对象使用的是同一个动态内存空间. 如果delete了, 新生成的类将失效. ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : elements(s.elements), first_free(s.first_free), cap(s.cap) &#123;s.elements = s.firet_free = s.cap = <span class="literal">nullptr</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">StrVec <span class="title">w1</span><span class="params">(<span class="comment">/* args*/</span>)</span></span>;</span><br><span class="line"><span class="function">StrVec <span class="title">w2</span><span class="params">(<span class="built_in">std</span>::move(w1))</span></span>;</span><br></pre></td></tr></table></figure>

<p>上例中, elements与first_free以及cap均是指向动态内存的指针. 对于非动态内存, 我们一样使用原始的方式进行赋值. 随后将指向动态内存的指针全部置位空指针. 使得在结束拷贝后执行w1的析构函数是保证动态内存不会被delete. 这就保证了w2的正常使用. </p>
<h4 id="右值引用与成员函数"><a href="#右值引用与成员函数" class="headerlink" title="右值引用与成员函数"></a>右值引用与成员函数</h4><p>类的成员函数也可定义移动版本. 一般是正常版本接受参数为const的左引用, 移动版本接受的是非const的右引用.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w.push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">string</span> &amp;&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w.push_back(<span class="built_in">std</span>::move(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"dddd"</span>;</span><br><span class="line">push_back(s1); <span class="comment">//调用正常版本.</span></span><br><span class="line">push_back(<span class="built_in">std</span>::move(s1)); <span class="comment">//调用移动版本.</span></span><br></pre></td></tr></table></figure>

<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><h3 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h3><p>public: 程序内均可访问, 是类接口.</p>
<p>private: 只能被类内成员函数访问. 隐藏了类的实现细节.</p>
<p>一般构造函数和部分成员函数在public之后, 数据成员在private之后.</p>
<p>class与struct的区别只在默认的访问权限上, class是private, struct是public,  还有就是在继承关系上的不同, 如果为指明继承关系, 则class定义派生类为private继承, struct定义的派生类为public继承.</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>由于一般将数据类型设置为private的权限, 因此,对于非成员函数来说则无法直接访问, 为了可以使得非成员函数可以对类进行访问, 我们可以设置其为友元函数. 只需在类内添加一条以friend为开头的函数申明语句即可.(不要求其权限, 在public和private均可)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> istream&amp; <span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意: 类内申明的友元并非通常意义下对函数的申明, 只是定义了访问权限,要想进行函数使用, 类外依然要再次申明.</strong></p>
<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>当类A中有数据成员为类B, 而类B中包含私有成员, 这将使得类A对其访问十分不便, 为了解决这个问题. 引入友元类概念. 在类B中添加类A为其友元类: friend class A;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend class window_mgr;</span><br></pre></td></tr></table></figure>

<p><strong>注意: 友元关系不具有传递性, 即A是B的友元类, B是C的友元类, C也不能够直接访问A的私有变量, 对于友元函数来说同样试用.</strong></p>
<p><strong>每个类负责控制自己的友元类和友元函数</strong></p>
<p>有时我们并不希望类B完全拥有对类A所以的访问权, 只希望个别成员函数可以访问A, 此时我们可以令<strong>成员函数作为友元</strong>. friend void B::function();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend void window_mgr::clear();</span><br></pre></td></tr></table></figure>

<h2 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h2><p>核心思想为: 数据抽象, 继承和动态绑定. 多态</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>派生类: 使用派生类列表, 在类后面使用冒号, 后面跟着以逗号分割的基类列表, 其中每个基类前面添加访问说明符.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bulk_quoto</span>:</span> <span class="keyword">public</span> quoto&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>基类将与类型相关的函数(不同派生类对应函数不同)与派生类不做改变直接继承的函数(各个派生类函数一致,均试用基类中定义的)区分对待.当基类希望它的派生类各自定义适合自己版本的函数, 此时基类可以将函数申明为虚函数. 只需要在函数名前加上virtual关键字即可. 继承类重新定义的虚函数会将基类的虚函数覆盖.  继承中使用虚函数时, 一定要进行申明.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">quoto</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">quoto</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>; <span class="comment">//一定要申明才能使用.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对虚函数的调用可能会在运行时才被解析.(当且仅当调用虚函数的是指针与引用才会在运行时被解析)</p>
<p>当我们使用基类的引用或指针调用虚函数时会执行动态绑定. 因为直到运行时才能知道到底调用了那个版本的虚函数, 因此所以虚函数都必须有定义. <strong>虚函数调用的选择为动态类型相匹配的那个.</strong>(动态类型详见下文动态类型与静态类型)</p>
<h3 id="动态绑定-运行时绑定"><a href="#动态绑定-运行时绑定" class="headerlink" title="动态绑定(运行时绑定)"></a>动态绑定(运行时绑定)</h3><p>使用动态绑定我们可以使用同一段代码处理基类与派生类.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">printf</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> quoto &amp;w, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = w.net_price(n);</span><br><span class="line">    os&lt;&lt;<span class="string">"ISBN: "</span>&lt;&lt;w.isbn()&lt;&lt;<span class="string">" # sold:"</span>&lt;&lt;n&lt;&lt;<span class="string">" total due: "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们即可以使用quote也可以使用bulk_quote执行上述代码.</p>
<p><font color="red">动态绑定只有在我们通过指针或引用调用虚函数时才会发生</font></p>
<h3 id="protected访问运算符"><a href="#protected访问运算符" class="headerlink" title="protected访问运算符"></a>protected访问运算符</h3><p>protected表示受保护的类型, 意思是该类型只希望该类本身和其友元以及派生类可以访问, 而其他不允许访问. 注意: <strong>private类型即使是派生类也没有权限访问</strong>, 这一点比较难以理解, 虽然类拥有该数据成员但却无权限访问. 具体解释将在之后的部分解释.</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>使用<strong>派生类列表</strong>指出该派生类继承于那个类或那些基类, 同时可以指出希望继承的方式(public, protected, private).其中继承方式说明符只是用来说明派生类原本具有访问权限的基类部分成员(即public和protected)继承到派生类后其访问权限.其中protected最低权限也是protected, 不可能成为public.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span>:</span> <span class="keyword">public</span> graphy</span><br></pre></td></tr></table></figure>

<p>派生类必须将继承而来的成员函数中需要覆盖(虚函数)的那些部分重新定义. 负责在动态绑定时将找不到该要调用哪个函数了.</p>
<h3 id="派生类向基类的类型转换"><a href="#派生类向基类的类型转换" class="headerlink" title="派生类向基类的类型转换"></a><font color="red">派生类向基类的类型转换</font></h3><p>派生类含义基类的对应组成部分, 所以我们能够把派生类当做基类使用. 在这个过程中我们将基类的指针或引用绑定到派生类对象中基类部分. </p>
<p><strong>只能通过基类的指针或者指针实现.</strong> </p>
<p>个人理解: 使用基类指针或引用时并未执行拷贝操作, 只是相当与将相对与基类中多加的部分添加一个限制(类似于删除). 此时我们访问派生类中基类部分时访问的其实还是派生类的元素, 只是看起来似乎我们在使用基类. </p>
<p>注意: 不存在对象之间的类型转换.(基类与派生类之间转换要通过基类指针或引用, 也不能是对象之间直接转换)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sphere w1;</span><br><span class="line">graphy w2 = w1;</span><br><span class="line">graphy &amp;w3 = w1;</span><br></pre></td></tr></table></figure>

<p>按照上述所述第二行按道理应该是错误的. 但实际往往不会如此, 这是由于无论拷贝构造函数还是重载的拷贝赋值运算符参数都是对于常量的引用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graphy(<span class="keyword">const</span> graphy&amp;);</span><br><span class="line">graphy&amp; operate = (<span class="keyword">const</span> graphy&amp;);</span><br></pre></td></tr></table></figure>

<p>此时执行w2 = w1;操作时首先执行上述的两个函数中的一个(具体是哪个参考拷贝赋值运算符节),此时已经完成了类似于第三行的基类引用到派生类的绑定, 传入函数中的已经是基类了, 因此可以完成. 当拷贝赋值运算符参数不是引用时, 依然是正确的, 这是由于如果不是引用作为参数时就会首先运行拷贝构造函数, 依然完成了转化. 而拷贝构造函数参数必须是引用, 因此在代码中我们会发现: <strong>基类 = 派生类总是不会报错, 但我们应该看到其实际是不合理的, 之所以不报错是因为在执行这一步过程中包含一步基类的引用 = 派生类的操作, 这将造成额外的花销, 因此应该尽量避免这个操作, 尽量使用基类的引用或指针 = 派生类.</strong> 想要证明这一点很简单,只需要单步调试即可, 就能发现.</p>
<p>同时应该注意, 不存在从基类向派生类的隐式类型转换.</p>
<h3 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h3><p>派生类构造函数应该使用基类的构造函数对基类部分进行初始化. 这能够避免考虑访问权限问题.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sphere(<span class="built_in">string</span> s, <span class="keyword">double</span> r): graphy(s), rito(r)&#123;&#125; <span class="comment">// 其中graphy使用了基类的构造函数</span></span><br></pre></td></tr></table></figure>

<p><font color="red">继承体系中默认初始化顺序</font></p>
<p>在派生类的构造函数中一般会使用构造函数初始化列表, 初始化的顺序是哪个数据成员定义在前先初始化哪个, 因此对于派生类来说, 基类的成员被最先定义, 因此会先初始化基类部分的成员数据, 同样, 在初始化基类部分的成员时又会先初始化基类的基类部分, 因此顺序是<strong>从基类到派生类的顺序</strong>.</p>
<p>派生类构造函数还可以简单的使用基类的构造函数, 只需要使用using语句即可. 此时具有特殊性, 此时使用using语句不会改变构造函数的访问级别, 在基类中的访问级别和派生类的一致.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A是基类, B是派生类:</span><br><span class="line">using A:A;</span><br><span class="line">等价于:</span><br><span class="line">B(rps):A(rps)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h3><p>派生类赋值运算符与拷贝构造函数一样, 必须显示的为其基类部分赋值.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D &amp; D::operate=(<span class="keyword">const</span> D&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::operate=(rhs); <span class="comment">//显示的调用基类的赋值运算符为基类部分成员赋值.</span></span><br><span class="line">    /<span class="string">'''</span><span class="string">'/</span></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员的继承"><a href="#静态成员的继承" class="headerlink" title="静态成员的继承"></a>静态成员的继承</h3><p>基类中定义了一个静态成员, 则整个继承体系中只存在改成员的唯一定义, 对派生类来说共享一个静态成员.</p>
<h3 id="派生类申明"><a href="#派生类申明" class="headerlink" title="派生类申明"></a>派生类申明</h3><p>派生类申明包含类名但不包含派生列表.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span>;</span> <span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span>:</span> <span class="keyword">public</span> graphy; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h3 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h3><p>当我们不希望某个类成为基类时, 我们只需要在类名后加上final就表示该类不能作为别的类的基类:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> <span class="title">final</span>&#123;</span>&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sphere</span> <span class="title">final</span> :</span> <span class="keyword">public</span> graphy&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><p>对于继承体系来说, 静态类型与动态类型应该区分开. 静态类型表示我们定义的类型, 而动态类型是指, 实际给我们的类型. </p>
<p><font color="red">动态类型与静态类型是相对于继承体系中派生类向基类的转换而言的, 对于非指针与引用类型来说动态类型与静态类型一致.</font></p>
<p>例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sphere w1;</span><br><span class="line">graphy &amp;w2 = w1; <span class="comment">// 对w1来说, 静态类型是graphy, 动态类型是sphere</span></span><br><span class="line">graphy w3 = w2; <span class="comment">// w3的静态类型与动态类型均是graphy</span></span><br><span class="line">graphy w4 = w1; <span class="comment">// w4的静态类型与动态类型也是一样的. 其实w4 = w1;这个操作等于上面两个操作之和.</span></span><br></pre></td></tr></table></figure>

<h3 id="派生类的虚函数"><a href="#派生类的虚函数" class="headerlink" title="派生类的虚函数"></a>派生类的虚函数</h3><p>派生类覆盖了某个虚函数时, 可以再次使用virtual关键字指出该函数的性质(为了以次派生类作为基类进行继承时使用). 然而这是非必须的. 一个函数被申明为虚函数, 则在所以派生类中均是虚函数(包括派生类的派生类).</p>
<p>派生类覆盖虚函数要求参数必须与基类中一致, 否则被认为是隐藏了虚函数并重新定义了一个函数.</p>
<p>派生类中虚函数的返回值也应该与基类中一致. 唯一的例外是当返回值为类本身的指针或引用时, 允许返回类型不同. 但这要求从派生类到基类的类型转换是可访问的.(派生类到基类可访问性详见下文)</p>
<h3 id="final与override说明符"><a href="#final与override说明符" class="headerlink" title="final与override说明符"></a>final与override说明符</h3><p>在派生类中, 如果没有指明是对虚函数的覆盖而定义了一个错误的虚函数的覆盖(实际希望覆盖虚函数但只达到了隐藏的效果), 这种情况会在参数列表不一致或者返回值不一致时发生, 编译器并不会报错, 但实际是严重的错误. 为了避免这种情况, 我们在派生类中对虚函数的定义后(参数列表后)加上override, 此时如果没有真正实现对虚函数的覆盖则编译器报错. override只对虚函数有用.</p>
<p>有时我们希望定义的虚函数在接下来的派生类中不要再被覆盖了, 保持使用当前类中的, 此时我们可以在虚函数的参数后加上final, 表示以此类为基类的派生类不能覆盖当前的虚函数.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> override final</span>; <span class="comment">//正确, override检验也正确, 且申明为final</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> override</span>; <span class="comment">// 错误, override使用正确, 但是并为真正实现覆盖, 报错</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> override</span>; <span class="comment">// 错误, f3不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> override</span>; <span class="comment">// 错误, 不存在f4函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>; <span class="comment">//错误, D1中已经定义f1为final ,这里不能覆盖.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h3><p>使用指针或引用调用虚函数, 如果含义默认实参则实参值由静态类型决定.</p>
<h3 id="回避虚函数机制"><a href="#回避虚函数机制" class="headerlink" title="回避虚函数机制"></a>回避虚函数机制</h3><p>当我们使用指针或引用调用虚函数时, 我们可以回避动态绑定, 使用域运算符即可:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> count = baseP-&gt;quoto::net_price(<span class="number">42</span>); <span class="comment">//其中baseP为quoto的派生类实例的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>当我们定义一个虚函数成员函数, 其没有实际意义, 只是为了以此为基类的成员能够使用动态绑定统一使用该虚函数接口, 各个派生类都重新定义自己的虚函数时. 我们可以将这个函数定义为<strong>纯虚函数</strong>, 该类成为抽象基类. 对于纯虚函数定义, 我们只需要在一般成员函数定义中加上=0;同样需要用关键字virtual. </p>
<p><strong>我们不能创建一个抽象基类的对象, 只能创建引用或指针.</strong></p>
<p>为了方便理解, 我们可以举个例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">graphy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_area</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sphere</span> :</span> graphy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">square</span>:</span> graphy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个抽象基类图像, 由于图像的面积不好计算, 因此我们只希望能够计算规则的图像, 所以我们将图片类作为一个抽象基类, 只是提供一个统一的接口. 而后我们对各个图像定义对应的面积计算函数. 而当我们使用时, 我们可以将任意类赋值到基类的指针或引用上, 此时利用动态绑定, 无论是那个图像, 我们都能够使用get_area函数获得图像的面积.</p>
<h3 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h3><p>派生类的作用域嵌套在基类的作用域里, 如果一个名字在派生类中找不到, 就会在外层作用域查找, 也就是其基类中查找.</p>
<p><font color="red">名字查找优先于类型检查:</font></p>
<p>即申明在内层作用域的函数并不会重载申明在外层作用域的函数, 即使参数和返回值不同. 编译器只会优先查找函数名, 当在内层作用域查到函数名就会终止查找了, 如果参数和返回值不匹配则会报错.</p>
<h3 id="名字查找与继承"><a href="#名字查找与继承" class="headerlink" title="名字查找与继承"></a><font color="red">名字查找与继承</font></h3><p>理解成员调用时的解析过程对于理解C++继承至关重要, 总共分为四步:</p>
<ol>
<li>首先确定静态类型.</li>
<li>在静态类型的类中查找对应成员, 如果找不到, 就在其基类中查找(只能查找派生类运行访问的成员, 即public和protected), 如果找不到就继续往下找, 终止条件是找到成员名字一致(只要求名字一致, 参数可以不一致, 原因: 名字查找优先于类型检测)或者找到最终的基类也没找到(报错).</li>
<li>找到对应成员后再进行类型检测(对于函数而已), 判断调用是否合法.</li>
<li>调用合法时, 编译器会根据是否为虚函数进而产生不同代码, 如果不是虚函数, 生成常规函数调用, 如果是虚函数且是通过引用或指针调用的, 则将在运行时选择执行哪段代码.</li>
</ol>
<h3 id="隐藏与覆盖的区别"><a href="#隐藏与覆盖的区别" class="headerlink" title="隐藏与覆盖的区别"></a><font color="red">隐藏与覆盖的区别</font></h3><p>覆盖是单对于虚函数而言的, 当我们在派生类中对虚函数重新定义时, 基类中的虚函数就会被隐藏. 需要注意, 当派生类中存在与基类中虚函数名字一致但参数列表不一致时, 并不会覆盖基类中的虚函数, 这相当于重新定义了另一个函数, 实际会将基类中的虚函数隐藏.</p>
<p>对于一般的成员函数, 在派生类中只有出现与基类中名字一样的普通成员函数, 测根据名字查找优先于与类型检查, 当调用该函数时, 由于派生类中存在一个该名字的函数, 就不会再向基类中查找了, 这时基类中的同名函数就会被隐藏. </p>
<p>个人理解: <font color="red">隐藏阻止了查找时向基类的查找, 覆盖允许调用时从基类向派生类中的调用.</font></p>
<h3 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h3><p>当基类中存在成员函数, 我们希望也被派生类使用, 但我们又希望定义一个或多个对其重载, 此时, 由于名字查找优先级大于参数匹配, 我们一旦定义同名函数, 基类中的就会被隐藏.  所以, 一个策略是将基类中的函数在派生类中在写一遍, 再添加新的重载, 但是这显然比较麻烦, 还有一个方式则是使用using申明语句. 申明我们希望使用基类中的成员函数, 而后我们只需定义派生类中特有的重载即可. 而且此时如果存在派生类的函数参数与基类的一致, 基类的将会被隐藏, 依然使用派生类中自定义的函数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_m</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_m</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_m</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> A::get_m; <span class="comment">//申明B要使用A内的get_m函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_m</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; <span class="comment">//自定义了一个get_m重载函数, 此时A中get_m(int, int)将被隐藏.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><p>对于继承来说, 存在三种方式, 即public, protected, 以及private. 这只是说明其继承中将基类成员继承为何种成员. 某个类对其继承而来的成员访问权限受两个方面的影响, 一个是在基类中的访问说明符, 一个是派生列表中的访问说明符.具体如下:</p>
<p>基类中访问说明符          派生列表说明符          派生类中访问权限</p>
<p>public                                   public                           public</p>
<p>public                                   protected                      protected</p>
<p>public                                   private                          private</p>
<p>protected                              public                           protected</p>
<p>protected                              protected                     protected</p>
<p>protected                              private                         private</p>
<p>private                                  –                                  无访问权限</p>
<p>解释: 对于基类中是private的成员, 派生类访问权限完全取决于派生列表中希望其拥有的访问权限. 对于基类中protected, 基类本身就是希望其只能在基类与派生类对其进行访问, 因此至少其访问权限是protected, 如果继承列表使用private,则其访问权限会被加强为private. 对于基类中的private成员, 基类本身就不希望派生类能够访问, 因此, 无论如何其都没有对private的访问权限, 但派生类又确实存在该成员. 因此, 如果希望访问private的话只能通过基类中定义的接口函数.</p>
<p>对于派生类访问基类的private数据成员的解释:</p>
<p>当派生类想要调用基类的private数据成员时, 首先会在自己的作用域中查找, 当然是找不到的, 而后会在基类中查找, 但是, 在基类中查找时, 其并没有查找private的权限, 因此也是找不到的,此时就会报错. 而当使用基类对于的接口函数时则是可以的. 同样先在派生类中查找, 找不到回去基类中查找, 找到后, 基类的接口还是有权限访问private数据成员, 此时就可以访问到派生类无法访问到的基类中private成员.</p>
<h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><p>派生类向基类的转换是否可访问(是否允许)由使用该转换的代码决定, 同时派生列表的访问说明符也有影响.</p>
<p>(1)只有派生类是public继承基类时, 用户代码才能使用派生类向基类的转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">c</span>:</span> <span class="keyword">private</span> A</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A w1;</span><br><span class="line">B &amp;w2 = w1; <span class="comment">//正确, public继承, 用户代码可访问从派生类到基类的转换</span></span><br><span class="line">C &amp;w3 = w1; <span class="comment">//错误, private和protected继承,用户代码不可访问从派生类到基类的转换</span></span><br></pre></td></tr></table></figure>

<p>(2)不论派生类以何种方式继承基类, 派生类的成员函数和友元均可以使用派生类到基类的转换.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> <span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">protected</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B w1;</span><br><span class="line">        A &amp;w2 = w1; <span class="comment">//正确, 作为B的成员函数, 从B到A的类型转换始终可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">ex_change</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex_change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B w1;</span><br><span class="line">    A &amp;w2 = w1; <span class="comment">//正确, 作为B的友元函数, 从B到A的类型转换始终可以访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)如果派生类继承基类的方式是public或protected的, 则派生类的派生类的成员函数或者友元可以使用从派生类向基类的转换, 而如果是private继承则不行.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span><span class="keyword">public</span>/<span class="keyword">protected</span> A;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span> <span class="keyword">private</span>/<span class="keyword">protected</span>/<span class="keyword">public</span>: B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B w1;</span><br><span class="line">        A &amp;w2 = w1;</span><br><span class="line">    &#125; <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h3><p>友元关系不能继承. 基类的友元可以访问基类的成员, 这种访问包括了派生类中内嵌的基类部分, 即<strong>派生类的基类部分对于基类的友元来说也是可以访问的</strong>. 友元与类本身对类中所以成员具有相同的访问权限.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(B b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.m; </span><br><span class="line">    &#125;<span class="comment">// 正确, B是A的派生类, C是A的友元, C可以访问B中A的成员部分.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改变个别成员可访问性"><a href="#改变个别成员可访问性" class="headerlink" title="改变个别成员可访问性"></a>改变个别成员可访问性</h3><p>有时我们需要改变基类中某个成员在派生类中的访问级别, 我们可以使用using申明(对于数据成员以及函数成员均有效).</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>由于我们在使用在使用动态绑定时需要使用派生类的引用或指针, 则当我们delete一个new出来的指针所指向区域时, 如果派生类没有一个虚析构函数则会产生未定义的行为. 因此,在继承体系中, 我们应该将析构函数定义成虚函数. </p>
<p>对于析构函数来说, 其销毁顺序是从派生类成员到基类成员. 与构造顺序相反.</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>在多重继承中, 有可能某个派生类继承两个基类, 并且这两个基类来自于同一个基类. 即A是B,C的基类, B,C又是D的基类, 此时D就存在两套A的成员, 显然这是不希望存在的. 此时可以使用虚继承. </p>
<p>虚继承virtual说明符表示了一种愿望, 即在后续的派生类中共享一份虚基类的实例.</p>
<p>上述A,B,C,D可以使用如下方式解决.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>此时D只存在A的一份成员. </p>
<p>虚继承中构造函数与析构函数比较特殊. </p>
<p>构造函数:</p>
<p>首先构造虚基类子部分, 而后按照直接继承中出现的顺序依次构造, 不过在构造直接继承时不会对虚基类子部分进行构造, 最后构造自己的部分. 即:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D::D(args): A(args_a), B(args_b), C(args_c)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在构造B, C时不会构造A的子部分, 虽然会传递A子部分的参数. 当没有显示调用虚基类A时, 会先执行A的默认构造函数.</p>
<p>析构函数与构造函数顺序相反.</p>
<h3 id="在构造函数与析构函数中调用虚函数"><a href="#在构造函数与析构函数中调用虚函数" class="headerlink" title="在构造函数与析构函数中调用虚函数"></a>在构造函数与析构函数中调用虚函数</h3><p>派生类构造函数被执行时, 先从基类部分构建, 当构造函数中要使用虚函数, 按照正常操作应该使用动态类型也就是说应该执行派生类中的虚函数, 但是派生类虚函数并未被构造, 处于未完成状态. 而派生类析构函数被执行时, 从派生类成员到基类成员被析构, 当执行到基类的析构函数时, 如果基类的析构函数调用虚函数, 同样根据动态绑定应该执行派生类的虚函数, 但不说了的虚函数已经被析构. 上述两个问题都会导致错误. C++处理方式是, 编译器认为对象在执行构造函数和析构函数时, 类型仿佛发生了变话. 即当执行基类部分的构造或析构函数时, 认为对象就是基类, 只调用基类的虚函数.</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>一元运算符有一个参数, 二元运算符有两个. 对于二元运算符来说, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数. 如果运算符是成员函数, 则左侧运算符对象隐式的绑定到this指针上.  对于一个重载的运算符来说, 其优先级和结合率不变.</p>
<h3 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h3><p>为了区分前置后置递增递减运算符, 在函数申明时在参数中添加一个未使用的形参int, 这个形参唯一作用就是区分前置后置, 而不是参与运算.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T&amp; operate++(); <span class="comment">//前置</span></span><br><span class="line">T&amp; operate--();</span><br><span class="line"></span><br><span class="line">T&amp; operate++(<span class="keyword">int</span>);<span class="comment">//后置</span></span><br><span class="line">T&amp; operate--(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<h3 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h3><p>类中可以重载函数调用运算符. 此时, 我们可以像使用函数一样使用该类. </p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;<span class="number">0</span>? val:-val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类定义了调用运算符, 则该类的对象称作函数对象. 行为像函数一样. <strong>函数对象也是可调用的</strong></p>
<p>除了重载函数调用运算符, 类中也可以存在数据成员和其余的函数成员. </p>
<h3 id="lambda是一个函数对象"><a href="#lambda是一个函数对象" class="headerlink" title="lambda是一个函数对象"></a>lambda是一个函数对象</h3><p>使用lambda表达式时, 编译器将该表达式翻译成一个未命名类的未命名对象. 类中包含一个重载的函数调用运算符. 对于捕获的参数, 会变成类中成员变量. (对于lambda的基本介绍看下面STL中泛型算法部分)</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> s.size()&gt;sz;&#125;;</span><br><span class="line">==</span><br><span class="line">class no_name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    no_name(<span class="keyword">int</span> n) sz(n);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.size()&gt;sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="STL标准库"><a href="#STL标准库" class="headerlink" title="STL标准库"></a>STL标准库</h1><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>IO对象无拷贝或赋值操作.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line"></span><br><span class="line">out1 = out2; <span class="comment">//错误, 不能进行拷贝.</span></span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span><span class="comment">//错误, 不能初始化IO类参数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">out2 </span>= print(out2); <span class="comment">// 错误, 不能拷贝流对象</span></span><br></pre></td></tr></table></figure>

<p>由于不能拷贝流对象, 因此不能将形参与返回值设置为流类型, 通常以引用类型进行传参与返回. 读写一个IO对象会改变其状态, 因此引用不能是const的.</p>
<h3 id="IO类型条件状态"><a href="#IO类型条件状态" class="headerlink" title="IO类型条件状态"></a>IO类型条件状态</h3><p>IO类最大的问题就是会发生错误, 因此,我们定义其条件状态来帮助我们访问和操作流. 下面是IO类定义的函数和标注.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strm::iostate <span class="comment">//strm是IO类型, iostate是机器相关类型, 表示条件状态</span></span><br><span class="line">strm::badbit;<span class="comment">//指出流已崩溃</span></span><br><span class="line">strm::failbit;<span class="comment">//指出IO操作失败</span></span><br><span class="line">strm::eofbit;<span class="comment">//指出流达到文件末尾</span></span><br><span class="line">strm::goodbit;<span class="comment">//流处于正常状态. 正常是为0</span></span><br><span class="line">s.eof();<span class="comment">//s处于eofbit状态返回true</span></span><br><span class="line">s.fail();<span class="comment">//s的failbit或badbit处于置位状态, 即为1, 返回true</span></span><br><span class="line">s.bad();<span class="comment">//s的badbit处于1返回true</span></span><br><span class="line">s.good();<span class="comment">//若s处于有效状态, 返回true</span></span><br><span class="line">s.clear();<span class="comment">//将流s中所有条件状态复位, 将流的状态设置为有效. 返回void</span></span><br><span class="line">s.clear(flags);<span class="comment">// 给定指定flag位置, 将流中对应条件状态位复位, flag为str::iostate类型, 返回void</span></span><br><span class="line">s.setstate(flags);<span class="comment">//给定指定flag位置, 将流中对应条件状态位置位, flag为str::iostate类型, 返回void</span></span><br><span class="line">s.rdstate();<span class="comment">// 返回s流当前状态, 返回类型为strm::iostate</span></span><br></pre></td></tr></table></figure>

<h3 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h3><p>标准输入((w)istream)输出((w)ostream), 由于不能拷贝流对象, 因此is&gt;&gt;和os&lt;&lt;返回值应该是对应的引用. 对于类内定义输入输出函数, 返回应该是对应引用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;read(istream &amp;is, Sales_data &amp;a)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    is&gt;&gt;a.bookNO&gt;&gt;a.units_sold&gt;&gt;a.price;</span><br><span class="line"></span><br><span class="line">​    a.revenue = a.price*a.units_sold;</span><br><span class="line"></span><br><span class="line">​    return is;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;print(ostream &amp;os, const Sales_data &amp;a)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​    os&lt;&lt;a.bookNO&lt;&lt;&quot; &quot;&lt;&lt;a.price&lt;&lt;&quot; &quot;&lt;&lt;a.units_sold&lt;&lt;&quot; &quot;&lt;&lt;a.revenue&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">​    return os;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fstream-文件输入输出"><a href="#fstream-文件输入输出" class="headerlink" title="fstream:文件输入输出"></a>fstream:文件输入输出</h3><p>操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fstream fstrm; <span class="comment">//创建fstream实例, 未绑定</span></span><br><span class="line"></span><br><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s)</span></span>; <span class="comment">//创建fstream实例,打开s并与fstrm绑定</span></span><br><span class="line"></span><br><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s, mode)</span></span>;<span class="comment">// 创建fstream实例, 以mode模式打开s并与fstrm绑定</span></span><br><span class="line"></span><br><span class="line">fstrm.open(s); <span class="comment">//打开文件s并与fstrm关联</span></span><br><span class="line"></span><br><span class="line">fstrm.close(); <span class="comment">//关闭fstrm关联的文件</span></span><br><span class="line"></span><br><span class="line">fstrm.is_open()<span class="comment">//指出fstrm关联的文件是否打开</span></span><br></pre></td></tr></table></figure>

<p>文件打开方式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in; <span class="comment">//读方式</span></span><br><span class="line">out; <span class="comment">// 写方式</span></span><br><span class="line">app;<span class="comment">//写操作前定义于文件末尾, 当使用app时默认添加out</span></span><br><span class="line">ate;<span class="comment">//打开文件后立即定位到文件末尾.</span></span><br><span class="line">trunc; <span class="comment">//截断文件, 只有在out被设置下才可以使用</span></span><br><span class="line">binary; <span class="comment">//以二进制进行IO</span></span><br></pre></td></tr></table></figure>

<p>注意: 对文件的操作我们要将文件看做正常程序的控制台, 要从文件中读取数据时应该是in(类比于从控制台输入), 要向文件中写东西时应该是out(类比于向控制台输出).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">s</span><span class="params">(<span class="string">"test.cpp"</span>, ifstream::in)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.is_open())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">while</span> (getline(s, line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;line&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"cant'n open file"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="sstring"><a href="#sstring" class="headerlink" title="sstring"></a>sstring</h3><p>sstring是将string当做一个IO对象来处理(上面一个是文件, 这个是string).</p>
<p>istringstream是向string中读数据, ostringstream是向string中写数据.</p>
<p>stringstream特有操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sstream strm;// 申明stringstream实例, 未绑定</span><br><span class="line"></span><br><span class="line">sstream strm(s);// 申明stringstream实例, 保存string的一个拷贝. 是explicit的(不存在默认转换)</span><br><span class="line"></span><br><span class="line">strm.str(); // 返回strm所保存的string的拷贝</span><br><span class="line"></span><br><span class="line">strm.str(s);// 将string s拷贝到strm中.</span><br></pre></td></tr></table></figure>

<h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h2><p>标准库容器均为迭代器.</p>
<p>迭代器类型不仅包含元素本身, 同时还包含返回迭代器的成员(即指向成员的迭代器), 这与指针不同, 指针需要取地址符, 而迭代器本身还有指向地址的元素.</p>
<p>迭代器包含的指向成员的迭代器包含 begin()和end(), 其返回的是指向指向第一个元素和最后一个元素的后一个位置的迭代器(类似于指向对应位置的指针).</p>
<p>由于成员选择”.”, “-&gt;”的优先级高于解引用”*”, 因此要获得对应元素要先获得迭代器再解引用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*a.begin()</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">*(a.begin())</span><br></pre></td></tr></table></figure>

<p>迭代器类型:</p>
<p>iterator和const_iterator表示迭代器类型.</p>
<p>迭代器运算:</p>
<p>迭代器加减常数表示迭代器前后移动. 两个迭代器相减表示两个迭代器距离.</p>
<p>比较, &gt;, &lt; ,==, … 均表示迭代器所指向元素位置的前后关系.</p>
<p><strong>迭代器类型不但支持++, –操作, 还能直接加常数.</strong></p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector; 可变大小数组, 随机访问, 除尾部以为位置插入很慢</span><br><span class="line">deque;  双端队列.</span><br><span class="line">list; 双向链表</span><br><span class="line">forward_list; 单向链表</span><br><span class="line">array: 固定大小数组. 不能添加删除元素</span><br><span class="line">string; 与vector类似, 不过专门用来存储字符.</span><br></pre></td></tr></table></figure>

<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">类型别名:</span><br><span class="line">iterator: 此容器类型的迭代器类型.</span><br><span class="line">const_iterator:可以读取元素，不能修改元素的迭代器类型(类比于常量指针.)</span><br><span class="line">size_type: 无符号整数类型, 足够保存此种容器类型的最大可能容器的大小.</span><br><span class="line">difference_type: 带符号整数类型, 表示两个迭代器距离</span><br><span class="line">value_type: 元素类型</span><br><span class="line">reference: 元素左值类型, 等价于value_type &amp;</span><br><span class="line">const_reference: 元素的const左值类型, 等价于const value_type &amp;</span><br><span class="line"></span><br><span class="line">构造函数:</span><br><span class="line">C c:</span><br><span class="line">C c1(c2):要求容器类型与元素类型均匹配</span><br><span class="line">C c(b, e): 构造c,使用迭代器b和e之间指定范围的拷贝到c, array不支持, 容器类型与元素类型均可不同, 只要求            元素类型可以实现转换即可.</span><br><span class="line">C c&#123;a, b, c, ....&#125;: 列表初始化</span><br><span class="line">C c(n, t); n个元素, 均使用t进行赋值.指定容器大小.</span><br><span class="line">// array具有固定大小.</span><br><span class="line">array&lt;int 10&gt; w; //正确</span><br><span class="line">array&lt;int&gt; w; //错误, 必须指明大小.</span><br><span class="line"></span><br><span class="line">赋值与swap: 要求c1, c2类型一致, 即容器和元素类型均一致</span><br><span class="line">c1 = c2;</span><br><span class="line">c1 = &#123;a, b, c, ...&#125;;</span><br><span class="line">a.swap(b); 交换</span><br><span class="line">swap(a, b);</span><br><span class="line"></span><br><span class="line">大小:</span><br><span class="line">c.size(); 不支持foreard_list</span><br><span class="line">c.max_size(); c中可保存的最大元素数量.</span><br><span class="line">c.empty();</span><br><span class="line"></span><br><span class="line">添加/删除元素(不适用array)(不同容器中不同):</span><br><span class="line">c.insert(args);</span><br><span class="line">c.emplace(args); 替换</span><br><span class="line">c.erase(args); 删除</span><br><span class="line">c.clear(); 删除所以元素.</span><br><span class="line"></span><br><span class="line">关系运算符:</span><br><span class="line">==, !=: 所以容器均支持</span><br><span class="line">&lt;, &gt;, &lt;=, &gt;=; 无序关联容器不支持.</span><br><span class="line"></span><br><span class="line">获取迭代器:</span><br><span class="line">c.begin(), c.end(); 返回收尾位置迭代器</span><br><span class="line">c.cbegin(), c.cend(); 返回首, 尾(之后)位置const 迭代器.</span><br><span class="line"></span><br><span class="line">反向容器的额外操作(不支持forward_list):</span><br><span class="line">reverse_iterator: 按逆序寻址元素的迭代器(即++往前走, --往后走)</span><br><span class="line">const_reverse_iterator: 不能修改元素的逆序迭代器</span><br><span class="line">c.rbegin(), c.rend(); 返回指向尾, 首(之前)的元素位置的迭代器.</span><br><span class="line">c.crbegin(), c.crend(); 返回const_reverse_iterator</span><br></pre></td></tr></table></figure>

<p>举例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; w(&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">auto</span> index = w.cbegin();</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;w.size();i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">cout</span>&lt;&lt;*index&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">​        index++;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">auto</span> index2 = w.crbegin();</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;w.size();i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">cout</span>&lt;&lt;*index2&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">​        index2++;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> </span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>assign函数(仅适用于顺序容器)</strong></p>
<p>assign允许我们使用迭代器对容器和元素(可以实现转化)均不同的的对象实现赋值操作. 类似于使用迭代器初始化对象, 不过这个操作是对已经存在的对象.(之前的内容将被丢弃)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; w(&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">float</span>&gt; w2;</span><br><span class="line"></span><br><span class="line">w2.assign(w.rbegin(), w.rend());</span><br></pre></td></tr></table></figure>

<p>第二个版本的assign还是与初始化时一样, 使用一个整数和一个元素表示对其赋值操作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w2.assign(10, 1);</span><br></pre></td></tr></table></figure>

<p><strong>swap交换操作</strong></p>
<p>swap操作除了对于array容器外, 均是元素本身未被交换, 只是交换了两个容器内部数据结构. 这意味着原本指向容器的迭代器, 引用, 指针均不会失效. 它们将指向交换之前的那些元素, 但是这些元素已经不属于原本的容器了.(string除外, 对string调用swap将导致上述内容失效, array也除外, 交换array会交换元素).  ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; w1(&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; w2 = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">auto</span> index = w1.begin()++;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">cout</span>&lt;&lt;*index&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">​    swap(w1, w2);</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">cout</span>&lt;&lt;<span class="string">" w1: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">auto</span> i = w1.begin(); i!=w1.end();i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"w2:"</span>&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">auto</span> i = w2.begin(); i!=w2.end();i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;*(++index)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">w1: </span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">10</span> </span><br><span class="line">w2:</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>关系运算符</strong></p>
<p>对于比较来说必须要求两边类型完全相等(容器元素均相等).</p>
<p>当两个容器大小不同, 且较小的与较大的对应元素一致, 则较小的容器小.(这里较大较小指元素数量)</p>
<p>当两个相互都不是对方的前缀子序列则比较第一个不同元素,</p>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">string a = &quot;asdfg&quot;;</span><br><span class="line"></span><br><span class="line">​    string b = &quot;asdfghjk&quot;;</span><br><span class="line"></span><br><span class="line">​    if(a&gt;b)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        cout&lt;&lt;a&lt;&lt;&quot;&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    else</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        cout&lt;&lt;b&lt;&lt;&quot;&gt;&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line">output:</span><br><span class="line">asdfghjk&gt;asdfg</span><br></pre></td></tr></table></figure>

<h4 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">forward_list有自己版本的insert和emplace;</span><br><span class="line">forward_list不支持push_back和emplace_back;</span><br><span class="line"><span class="built_in">vector</span>和<span class="built_in">string</span>不支持push_front和emplace_front;</span><br><span class="line"></span><br><span class="line">c.push_back(t):c的尾部创建值为t或由args创建的元素. <span class="keyword">void</span>返回.t为元素, args为可以转化成元素的参数</span><br><span class="line">c.emplace_back(args):</span><br><span class="line"></span><br><span class="line">c.push_front(t):c的头部添加元素 <span class="built_in">vector</span>和<span class="built_in">string</span>不支持.</span><br><span class="line">c.emplace_front(args):</span><br><span class="line"></span><br><span class="line">c.insert(p, t):在迭代器p之前添加元素, t为元素 , args为可以转化成元素的参数, n为常数, b,e为迭代器, il                为元素值列表. 返回均为p</span><br><span class="line">c.emplace(p, args):</span><br><span class="line">c.insert(p, n, t):</span><br><span class="line">c.insert(p, b, e):</span><br><span class="line">c.insert(p, il):</span><br></pre></td></tr></table></figure>

<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>front和back成员函数, 返回首元素和尾元素的引用.</p>
<p>访问元素的成员函数(front, back, at, 下标)返回均为引用.</p>
<p>string, vector, deque, array提供了下标操作进行快速访问. 使用下标可能会发生越界, 编译器不会检测是否越界, 这将导致程序错误.</p>
<p>at成员函数, 为了防止发生越界的错误, 可以使用at(index)成员函数访问元素, 此时当越界时将会报out_of_range异常.</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">forward_list有自己的erase</span><br><span class="line">froward_list不支持pop_back</span><br><span class="line"><span class="built_in">vector</span>, <span class="built_in">string</span>不支持pop_front</span><br><span class="line"></span><br><span class="line">c.pop_back() 删除尾元素, 返回<span class="keyword">void</span></span><br><span class="line">c.pop_front() 删除首元素, 返回<span class="keyword">void</span></span><br><span class="line">c.erase(p) p ,b, e均为迭代器, 返回均是删除元素的后一个元素</span><br><span class="line">c.erase(b, e)</span><br><span class="line">c.clear() <span class="comment">// 返回void</span></span><br></pre></td></tr></table></figure>

<h4 id="forward-list特殊操作"><a href="#forward-list特殊操作" class="headerlink" title="forward_list特殊操作"></a>forward_list特殊操作</h4><p>由于forward_list是单向链表, 无法访问当前元素前一个元素, 因此操作较为特殊</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lst.before_begin()返回首元素之前的不存在的元素迭代器(链表头结点, 无实际元素, 仅仅提供入口)</span><br><span class="line">lst.cbefore_begin() 与上面一样,不过返回const_iterator</span><br><span class="line"></span><br><span class="line">lst.insert_after(p, t) 在p之后插入元素,  返回插入的最后一个元素的迭代器</span><br><span class="line">lst.insert_after(p, n, t)</span><br><span class="line">lst.insert_after(p, b,e)</span><br><span class="line">lst.insert(p, b, e)</span><br><span class="line">lst.emplace_after(p, args)</span><br><span class="line"></span><br><span class="line">lst.erase_after(p)删除p之后的元素, 返回被删元素之后的迭代器</span><br><span class="line">lst.erase_after(b, e) 删除b(不包括)到e, 返回e之后的迭代器.</span><br></pre></td></tr></table></figure>

<h4 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.resize(n) 更改大小, 当n&lt;c.size(), 多余被删除, n&gt;size(), 新加入的部分被默认初始化</span><br><span class="line"></span><br><span class="line">c.resize(n, t) 更改大小, 当n&lt;c.size(), 多余被删除, n&gt;size(), 新加入的部分使用t初始化</span><br></pre></td></tr></table></figure>

<h4 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h4><p>这里主要涉及容器内部实现, 以及对应操作的实现, 当容器的存储空间是否被重新分配, 重新分配则会失效.</p>
<p>插入元素时:</p>
<p>当vector和string存储空间被重新分配时, 迭代器,指针, 引用失效.</p>
<p>deque除插入位置为收尾,其它均会失效.</p>
<p>list和forward_list均有效</p>
<p>删除元素时:</p>
<p>被删除的位置均会失效.</p>
<p>list和forward, 剩余部分均有效</p>
<p>deque如果删除位置处于收尾元素之外其它也均会失效, 如果是尾元素,尾后迭代器也会失效.</p>
<p>vector和string被删元素之后会失效.</p>
<h3 id="string额外的操作"><a href="#string额外的操作" class="headerlink" title="string额外的操作"></a>string额外的操作</h3><h4 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s(cp, n);拷贝cp中前n个作为s</span><br><span class="line"></span><br><span class="line">string s(s2, pos2); 从s2下标pos2开始到末尾的元素拷贝初始化s</span><br><span class="line"></span><br><span class="line">string s(s2, pos2, len2); 上一个再加上长度限制.</span><br></pre></td></tr></table></figure>

<p>其中接受的参数是string或char*(不必以空字符结尾).</p>
<p>s.substr()取子字符串操作, 两种形式</p>
<p>s.substr(pos); 取从pos到维的子字符串</p>
<p>s.substr(pos1, pos2); 取pos1, 到pos2的子字符串[pos1, pos2). pos均为整数, pos最小为0.</p>
<h4 id="改变string的其他方式"><a href="#改变string的其他方式" class="headerlink" title="改变string的其他方式"></a>改变string的其他方式</h4><p>在一般删除, 添加, assign, 等操作中使用的迭代器可以完全换成索引, 依然可以对string进行更改</p>
<p>s1.append(args), 在s1后面添加args</p>
<p>s1.replace(pos, length, args), 删除pos为起点长度为length的元素, 用args替换. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;l don&apos;t think so!!!&quot;;</span><br><span class="line">s.replace(2, 5, &quot;do&quot;);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">output:</span><br><span class="line">I do think so!!!</span><br></pre></td></tr></table></figure>

<h4 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s.find(args) 查找s中args第一次出现位置</span><br><span class="line"></span><br><span class="line">s.rfind(args) 查找s中最后一次出现args的位置</span><br><span class="line"></span><br><span class="line">s.find_first_of(args) 在s中查找args中任意一个字符第一次出现的位置</span><br><span class="line"></span><br><span class="line">s.find_last_of(args) 在s中查找args中任意一个字符最后一次出现的位置</span><br><span class="line"></span><br><span class="line">s.find_first_not_of(args) 在s中查找第一个不在args中的字符</span><br><span class="line"></span><br><span class="line">s.find_last_not_of(args) 在s中查找最后一个不在args中的字符</span><br><span class="line"></span><br><span class="line">args参数要求: c是字符, pos是起始搜索的位置(下标), 默认是0, s2为字符串, cp为字符串指针(以空字符结尾),</span><br><span class="line">c, pos </span><br><span class="line">s2, pos</span><br><span class="line">cp, pos</span><br><span class="line">cp, pos, n: 从s的pos位置查找cp指向的数组的前n个字符, pos和n无默认值.</span><br></pre></td></tr></table></figure>

<h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">to_string(val)</span><br><span class="line">stoi(s, p, b)</span><br><span class="line">stol(s, p, b)</span><br><span class="line">stoul(s, p, b)</span><br><span class="line">stoll(s, p, b)</span><br><span class="line">stouul(s, p, b)</span><br><span class="line">stof(s, p)</span><br><span class="line">stod(s, p)</span><br><span class="line">stold(s, p)</span><br></pre></td></tr></table></figure>

<p>sto表示string to 后面部分是要转换到的类型.</p>
<h3 id="vector如何增长"><a href="#vector如何增长" class="headerlink" title="vector如何增长"></a>vector如何增长</h3><p>vector和string会分配比需求大的空间作为备用, 当空间不够时再进行扩张, 此时就要移动所以元素了, 会导致迭代器,指针和引用失效. </p>
<p>容器大小操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shrink_to_fit只适用于<span class="built_in">vector</span>, <span class="built_in">string</span>,<span class="built_in">deque</span></span><br><span class="line">capacity和reserve只适用<span class="built_in">vector</span>和<span class="built_in">string</span></span><br><span class="line">c.shrink_to_fit() 将capacity减少至size大小</span><br><span class="line">c.capacity()不重新分配空间时, c能容纳多少元素</span><br><span class="line">c.reserve(n) 分配至少可以容纳n个元素的空间</span><br></pre></td></tr></table></figure>

<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>一个适配器是一种机制, 使得某些事物的行动看起来像另外一件事一样.</p>
<p>所有适配器均支持的操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">size_type: 足以保存当前类型最大对象的大小</span><br><span class="line"></span><br><span class="line">value_type: 元素类型</span><br><span class="line"></span><br><span class="line">container_type :实现适配器的底层容器类型</span><br><span class="line"></span><br><span class="line">A a; 创建空的适配器</span><br><span class="line"></span><br><span class="line">A a(c); 创建一个a的适配器, 带有容器c的一个拷贝</span><br><span class="line"></span><br><span class="line">关系运算符:</span><br><span class="line">==, !=, &gt;, &gt;=, &lt;, &lt;=</span><br><span class="line"></span><br><span class="line">a.empty()</span><br><span class="line"></span><br><span class="line">a.size()</span><br><span class="line"></span><br><span class="line">swap(a,b)</span><br><span class="line"></span><br><span class="line">a.swap(b)</span><br></pre></td></tr></table></figure>

<p>创建适配器是可以指定使用何种容器实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     vector&lt;int&gt; W = &#123;2, 5, 7, 5, 3, 10&#125;;</span><br><span class="line"></span><br><span class="line">​    priority_queue&lt;int, deque&lt;int&gt;&gt; p; // &lt;&gt;中第一个是元素类型, 第二个是容器类型</span><br><span class="line"></span><br><span class="line">​    for(int i=0;i&lt;W.size();i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        p.push(W[i]);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    cout&lt;&lt;p.top()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="栈适配器stack"><a href="#栈适配器stack" class="headerlink" title="栈适配器stack"></a>栈适配器stack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">栈默认基于deque, 也可以在list或vector上</span><br><span class="line">s.pop() 删除栈顶元素, 返回void</span><br><span class="line">s.push(item) 创建一个元素压入栈</span><br><span class="line">s.emplace(args)</span><br><span class="line">s.top() 返回栈顶元素但不弹出栈.</span><br></pre></td></tr></table></figure>

<h4 id="队列适配器-queue-priority-queue"><a href="#队列适配器-queue-priority-queue" class="headerlink" title="队列适配器(queue/priority_queue)"></a>队列适配器(queue/priority_queue)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue默认使用deque实现, 也可以使用list或vector实现, priority_queue默认使用vector, 也可以使用deque</span><br><span class="line">q.pop() 删除queue队首或priority_queue中拥有最高优先级的元素, 无返回</span><br><span class="line">q.front() 返回首元素或尾元素 只适用于queue</span><br><span class="line">q.back() 只适用于queue</span><br><span class="line">q,top() 返回最高优先级元素但不删除, 只适用于priority_queue</span><br><span class="line">q.push()</span><br><span class="line">q.emplace()</span><br></pre></td></tr></table></figure>

<h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><p>标准库为顺序容器定义了一组泛型算法, 泛型算法不止实验与标准库类型, 还适用于内置的数组类型. 一般这些算法不直接操作容器, 而是遍历两个迭代器指定的一个元素范围. 大多数泛型算法都定义在algorithm头文件中, numeric中也定义了一组数值泛型算法.</p>
<p>算法不会执行容器的操作, 只会运行与迭代器之上, 执行迭代器的操作. 算法永远不会改变底层容器大小, 可以改变容器中保存的元素, 或者移动元素, 不可直接添加删除元素. 个人理解: 泛函算法类似于批处理, 对指定区域元素进行某一相同操作(甚至可以将区域本身也当做一种操作).</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>寻找子元素. find(begin, end, val); 返回指向元素的迭代器.</p>
<h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><p>序列求和算法. 只能用于可以加和的元素, accumulate(begin, end, val), val为求和的初值, 范围是[begin, end).</p>
<h4 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h4><p>比较两个序列是否保存相同的值, equal(a1.begin(), a1.end(), a2.begin() ); 三个元素前两个与之前一样, 第三个表示第二个元素的首元素. 这个算法有一个假设, 即a2长度不小于a1.</p>
<h3 id="写容器算法"><a href="#写容器算法" class="headerlink" title="写容器算法"></a>写容器算法</h3><p>由于算法不能直接更改迭代器底层大小, 因此写操作要求写入的位置本身就具有元素.</p>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>填充, 语法 fill(a.begin(), a.end(), val); 将指定范围内元素使用val赋值.</p>
<h4 id="fill-n"><a href="#fill-n" class="headerlink" title="fill_n"></a>fill_n</h4><p>填充, 第二个参数指明长度. fill_n(a.begin, n, val). 以a.begin()为起点的n个元素使用val填充. 要求n为合法数值, 即begin()后有n个元素.</p>
<h4 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h4><p>向容器中添加插入迭代器. 定义在头文件iterator中.  iterator = back_inserter(a), 向a中尾部添加迭代器iterator. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(back_inserter(a), <span class="number">10</span>, <span class="number">0</span>);<span class="comment">// 向vec添加10个元素, 并用0赋值.</span></span><br></pre></td></tr></table></figure>

<p>其中fill_n语句执行类似一个批处理命令, 10表示执行10遍, 每次执行back_inserter操作添加迭代器, 而后使用0赋值.</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>拷贝. copy(a1.begin(), a1.end(), a2), 将指定区域元素拷贝到以a2为起点的序列中..</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(*a)];</span><br><span class="line">copy(begin(a), end(a), b);</span><br></pre></td></tr></table></figure>

<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>替换, replace(begin(a), end(a), val1, val2), 将指定区域中值为val1的变量赋值为val2.</p>
<h3 id="重排算法"><a href="#重排算法" class="headerlink" title="重排算法"></a>重排算法</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>重排, 默认使用”&lt;”, 即由大到小, 比较方式可以指定. sort(begin, end, compare); cmpare应该是一个二元谓词(下面详细介绍),</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">sort(begin(a), end(a), compare);</span><br></pre></td></tr></table></figure>

<h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><p>重排标准库, 使得不重复的元素出现在容器前面, 返回排序后重复的第一个位置. unique(begin, end); 其中要求重复元素是连续的, 即重复元素是在一起的, 并且, 对于后面的重复元素其值并不是重复元素,而只是站位而已, 其内的元素是不定的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">sort(begin(a), end(a));</span><br><span class="line">unique(begin(a), end(a));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">OUTPUT:</span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">11</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h3 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h3><h4 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h4><p>谓词是一个可调用的表达式, 返回结果是一个能用作条件的值. 标准库算法使用的谓词包含一元谓词有二元谓词, 代表接受的参数个数. </p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>我们可以向一个算法传递任意类别的可调用对象. lambda表达式也是可调用对象. 一个lambda表达式表示一个可调用的代码单元. 形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list)-&gt;return type &#123;function body&#125;;</span><br></pre></td></tr></table></figure>

<p>capture list(捕获列表)是一个lambda所在函数中定义的局部变量列表. 捕获列表可以为空, 其他与正常函数没有太大不同, 返回类型必须为尾置返回. 我们可以忽略参数列表和返回类型. 但必须包含捕获列表和函数体.</p>
<p>ex:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<p>lambda忽略括号和参数列表等价于指定一个空参数列表. 忽略返回值类型, lambda会根据函数体推断返回类型. 如果函数体只有一个返回语句, 返回类型通过return语句推断, 否则返回void.</p>
<p>向lambda传递参数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)&#123;<span class="keyword">return</span> s1.siez()&lt;s2.size();&#125;;<span class="comment">//compare function.</span></span><br><span class="line"></span><br><span class="line">stable_sort(a.begin(), a.end(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)&#123;<span class="keyword">return</span> s1.siez()&lt;s2.size();&#125;); <span class="comment">//sort vector of string</span></span><br></pre></td></tr></table></figure>

<p>使用捕获列表:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz = <span class="number">42</span>;</span><br><span class="line">[sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1)&#123;<span class="keyword">return</span> s1.size()&gt;=sz&#125;;</span><br></pre></td></tr></table></figure>

<p>值捕获:</p>
<p>值捕获是变量拷贝, 捕获发生在lambda创建时而非调用时. 因此, 之后变量的改变不会影响lambda函数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1]&#123;<span class="keyword">return</span> v1;&#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j=f(); <span class="comment">//j = 42;</span></span><br></pre></td></tr></table></figure>

<p>引用捕获</p>
<p>引用捕获变量的值是会随着变量本身变化而变化的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;v1]&#123;<span class="keyword">return</span> v1;&#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j=f(); <span class="comment">//j = 0;</span></span><br></pre></td></tr></table></figure>

<p>隐式捕获:</p>
<p>我们可以让编译器根据代码自动选择捕获变量. 这被称为隐式捕获. 隐式捕获要求注明捕获方式是值捕获还是引用捕获, 分别使用”=”, 和”&amp;”表示.  同时,我们可以混合使用隐式捕获与显示捕获.但这要求捕获列表第一个必须是”=”, 或者”&amp;”, 并且之后的显示捕获的方式要与隐式捕获的不同(不然就应该全部使用一种方式啊).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;, c](<span class="keyword">int</span> d)&#123;<span class="keyword">return</span> a+b+c+d;&#125;; <span class="comment">//对a,b调用引用的隐式捕获, 对c调用显示的值捕获.</span></span><br></pre></td></tr></table></figure>

<p>可变lambda</p>
<p>此前所述的值捕获是不能更改lambda中参数大小的, 如果想要更改大小, 则应该加上mutable关键字. 此时lambda中值捕获就可以更改大小了.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span>&#123;<span class="keyword">return</span> ++a;&#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = f() <span class="comment">// j=43, 更改了值捕获中拷贝的大小</span></span><br></pre></td></tr></table></figure>

<p>指定lambda返回类型:</p>
<p>对于只有一个return 的简单函数, 编译器会自己判断返回类型, 而对于较为复杂(多个return)的lambda表达式, 应该指明返回类型.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> i )-&gt;<span class="keyword">int</span> &#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h4><p>查找容器中满足条件的元素.find_if(begin, end, callabe), callabe表示可调用对象.  返回为第一个满足条件的元素的迭代器.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wn = find_if(a.begin(), a,end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;<span class="keyword">return</span> s.size()&gt;sz;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p>为容器中满足条件的运算执行操作. for_each(a.begin, a.end, callabe);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(a.begin(), a.end(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="参数绑定-bind"><a href="#参数绑定-bind" class="headerlink" title="参数绑定(bind)"></a>参数绑定(bind)</h3><p>bind函数可以看做一个通用函数适配器(类似于python中装饰器), 它接受一个可调用对象, 生成一个新的可调用对象来”适应”原对象的参数列表. bind被定义在functional中, 一般形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list);</span><br></pre></td></tr></table></figure>

<p>arg_list是一个逗号分割的参数列表, 对应于callable本身的参数. 当我们调用newCallable时, newCallable会调用callable并传递arg_list中的参数. arg_list参数可能包含_n的名字, n是一个整数, 作为占位符, 表示newCallable的参数. 它们占据了传递给newCallable的参数的位置. n表示原来的可调用函数的第n个位置的参数, _1表示原来的callable的第一个参数位置被占据. _n被定义在placeholder命名空间, 使用时要添加using namespace std::placeholder;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.size()&lt;sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> new_com = bind(com, _1, <span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<p>有时我们希望传递的参数是引用类型(比如io无法赋值), 然而bind拷贝其参数,此时我们需要ref或cref函数. 该函数返回一个对象, 包含给定的引用, 次对象可以拷贝.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;print(ostream &amp;os, const string &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    return os&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">auto new_print = bind(print, ref(os), _1);</span><br></pre></td></tr></table></figure>

<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p>关联容器支持高效的关键字查找与访问. 两个主要的关联容器是set和map(均使用红黑树实现). 关联容器支持一般容器的常规操作.  STL主要定义了八种关联容器. 为set, map, multimap, multiset, 以及对应与前四者的无序版本: unordered_(), map中的元素是关键字-值(key-value)对, pair类型. map被称为关联数组. set是关键字的集合.  关联容器必须定义关键字比较的方式. 为了使用自己定义的操作类型, 我们需要提供比较操作–一种函数指针类型.</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count[<span class="string">"ui"</span>] = <span class="number">1</span>; <span class="comment">//当"ui"存在时, 会对其value赋值, 当不存在时, 会先创建"ui"再赋值.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;. <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="keyword">bool</span> (*)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)&gt; word_count(compare); <span class="comment">//指定比较类型</span></span><br><span class="line">==</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>, <span class="keyword">decltype</span>(compare)*&gt; word_count(compare); <span class="comment">//指定比较类型</span></span><br></pre></td></tr></table></figure>

<p>map中存储元素为pair类型. 包含两个共有数据成员first和second分别对应key和value.</p>
<p>使用下标访问map是有一个问题的, 有时我们不知道是否存在要访问的元素, 如果不存在, 则使用下标时会完成创建. 使用at相对更好一些, 当不存在时, at会报错.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; w;</span><br><span class="line">w[<span class="string">"ann"</span>];</span><br><span class="line"><span class="keyword">int</span> j = w[<span class="string">"ann"</span>];<span class="comment">//j = 0;</span></span><br><span class="line">w.at(<span class="string">"annn"</span>); <span class="comment">//throw out of range</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; word;</span><br></pre></td></tr></table></figure>

<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>pair为一种标准库类型. 定义在utility中.</p>
<p>pair操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line">pair&lt;T1, T2&gt; p(v1, v2);</span><br><span class="line">pair&lt;T1, T2&gt; p = &#123;v1, v2&#125;;</span><br><span class="line">make_pair(v1,v2); <span class="comment">//返回一个pair.</span></span><br><span class="line">p.first;</span><br><span class="line">p.second;</span><br><span class="line">p1 relop p2;</span><br></pre></td></tr></table></figure>

<h3 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key_type    容器类型的关键字类型</span><br><span class="line">mapped_type 关键字关联的类型, 只适用于<span class="built_in">map</span></span><br><span class="line">value_type  对于<span class="built_in">set</span>, 与可以\_type相同, 对于<span class="built_in">map</span>为pait&lt;key_type, mapped_type&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::value_type v1; <span class="comment">//v1是一个string类型</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::key_type v2; <span class="comment">//v2是一个string类型</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type v3;<span class="comment">//v3是一个&lt;string, int&gt;的pair</span></span><br></pre></td></tr></table></figure>

<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解关联容器的迭代器时, 得到的是value_type, map中first保存的是const类型, set本身的value_type就是const类型. 即关键字都不能更改.</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.insert(v);<span class="comment">// v is value_type</span></span><br><span class="line">c.emplace(args);</span><br><span class="line">c.insert(b, e); <span class="comment">// b, e is iterator</span></span><br><span class="line">c.insert(il); <span class="comment">// il is a list of value_type</span></span><br><span class="line">c.insert(p, v); <span class="comment">// p is a iterator which identity the local of begining to search where to insert the v.</span></span><br><span class="line">c.emplace(p, v);</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(&#123;&quot;word&quot;, 1&#125;);</span><br><span class="line">word_count.insert(make_pair(&quot;ward&quot;, 1));</span><br><span class="line">set&lt;int&gt; set2;</span><br><span class="line">vector&lt;int&gt; ivec = &#123;1, 2, 3, 4, 8&#125;;</span><br><span class="line">set2.insert(ivec.begin(), ivec.end());</span><br><span class="line">set2.insert(&#123;5, 8, 7, 1,3&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="insert的返回值"><a href="#insert的返回值" class="headerlink" title="insert的返回值"></a>insert的返回值</h4><p>对于不能包含重复元素的容器, 插入<strong>单一元素</strong>返回为pair类型, 告诉我们是否插入成功. pair的first是迭代器, 指向具有给定关键字的元素, second是一个bool值, 表示是否插入成功.</p>
<h4 id="向multiset和multimap添加元素"><a href="#向multiset和multimap添加元素" class="headerlink" title="向multiset和multimap添加元素"></a>向multiset和multimap添加元素</h4><p>对于插入单一元素, 返回是指向插入后的新元素的迭代器.</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.erase(k);<span class="comment">//k is key</span></span><br><span class="line">c.erase(p);<span class="comment">//p, b, e is iterator </span></span><br><span class="line">c.erase(b, e);</span><br></pre></td></tr></table></figure>

<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.find(k); <span class="comment">// return a iterator which identify the element whose key is k, if k isn't exist, return c.end();</span></span><br><span class="line">c.count(k); <span class="comment">// return the number of element whose key is k;</span></span><br><span class="line">c.lower_bound(k); <span class="comment">//return a iterator whose key is the first key&gt;=k;</span></span><br><span class="line">c.upper_bound(k); <span class="comment">// return a iterator whose key is the first key&gt;k;</span></span><br><span class="line">c.equal_range(k); <span class="comment">// return a pair of iterator which identify the range of key = k, if k isn't exist, return (c.end(), c.end()).</span></span><br></pre></td></tr></table></figure>

<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>shared_ptr类一种智能指针, 允许多个指针指向同一对象. 智能指针均定义在memory头文件中. 智能指针也是模板, 当我们创建一个智能指针时,必须提供指向的类型. 智能指针能够自动释放内存不用用户自己手动释放. 智能指针可以看做对普通内置指针的封装.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p2; <span class="comment">//p1, p2均是智能指针, 访问成员需要-&gt;</span></span><br></pre></td></tr></table></figure>

<p>unique_ptr与shared_ptr均支持的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; sp;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; up;</span><br><span class="line">p;<span class="comment">// 将p作为一个条件判断, 若p指向一个对象则为true.</span></span><br><span class="line">*p;<span class="comment">// 解引用p, 获取指向元素</span></span><br><span class="line">p-&gt;mem; <span class="comment">// 等价于(*p).mem;</span></span><br><span class="line">p.get(); <span class="comment">// 返回p中保存指针.</span></span><br><span class="line">swap(p, q); <span class="comment">// 交换p, q指向的指针.</span></span><br><span class="line">p.swap(q);</span><br></pre></td></tr></table></figure>

<p>shared_ptr支持的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make_shared&lt;T&gt;(args);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q); <span class="comment">//递增q中计数器.</span></span><br><span class="line">p = q; <span class="comment">// 递减p中计数器, 递增q的计数器. 当p的引用计数变成0, 则将其原本管理的内存释放.</span></span><br><span class="line">p.unique(); <span class="comment">// 如果p.use_count() == 1 retuen true , else return false.</span></span><br><span class="line">p.use_count(); <span class="comment">// 返回与p共享对象的智能指针数量.</span></span><br><span class="line">ex:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; p = make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(&#123;<span class="string">"a"</span>, <span class="string">"the"</span>, <span class="string">"an"</span>&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr的拷贝与赋值"><a href="#shared-ptr的拷贝与赋值" class="headerlink" title="shared_ptr的拷贝与赋值"></a>shared_ptr的拷贝与赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = make_shared&lt;int&gt;(42);</span><br><span class="line">auto q(p);</span><br></pre></td></tr></table></figure>

<p>每个shared_ptr都有一个关联的计数器, 称为引用计数. 无论我们什么时候拷贝一个shared_ptr对象, 计数器就会增加. 包括, 使用一个shared_ptr初始另一个, 作为参数传递, 作为返回值. 我们给shanre_ptr对象赋予一个新值或者shared_ptr被销毁(离开作用域时), 计数器就会递减. 一旦引用计数对于0, 就会自动释放管理的内存.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q; <span class="comment">//r的引用计数达到0, 原本管理的地址被释放.</span></span><br></pre></td></tr></table></figure>

<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>new分配内存, delete释放new出来的内存. delete只是释放指针指向的内存区域, delete之后原本的指针依然存在, 此时相当于一个空指针.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">delete</span> pv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">使用<span class="keyword">new</span>动态分配<span class="keyword">const</span>对象:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">2014</span>);</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr-与-new结合使用"><a href="#shared-ptr-与-new结合使用" class="headerlink" title="shared_ptr 与 new结合使用"></a>shared_ptr 与 new结合使用</h3><p>我们可以使用new返回的指针来初始化智能指针. 必须使用直接初始化方式, 不能将内置指针转换为智能指针.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">14</span>)); <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; p2 = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">14</span>);<span class="comment">// false, 不能将内置指针转换为智能指针.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p)); <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>(p); <span class="comment">// false;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义和改变shared_ptr的方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q); <span class="comment">// p管理内置指针q所指对象. 要求q所指对象要是new分配的内存(即堆内存).</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(u); <span class="comment">// p从unique_ptr接管对象所有权, 将u置空.</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(q, d); <span class="comment">//  p管理内置指针q所指对象. 要求q所指对象要是new分配的内存(即堆内存).同时接受可调用对象(函数, 函数指针, lambda)类代替shared_ptr默认的delete.</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;T&gt; p(p2, d); <span class="comment">// p是p2的拷贝, d与上述d相同.</span></span><br><span class="line"><span class="comment">// p是唯一指向其对象的shared_ptr, reset将会释放此对象.如果传递了可选的参数内置指针q, 会令p指向q, 否则会将p置空. 其中d与上述d一致.</span></span><br><span class="line">p.reset();</span><br><span class="line">p.reset(q);</span><br><span class="line">p.reset(q,d);</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr拥有它所指的对象, 某个时刻只能有一个unique_ptr指向一个给定对象. unique_ptr不支持拷贝即p1(p2), p1 = p2均是非法的. unique_ptr支持的操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; u1;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T, D&gt; u2; <span class="comment">//D为可调用类型, 用来代替delete.</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T, D&gt; u(d); <span class="comment">// D与上面一样, d为D的实例对象</span></span><br><span class="line">u = <span class="literal">nullptr</span>; <span class="comment">// 释放u指向的对象, 将u置空.</span></span><br><span class="line">u.release(); <span class="comment">// u放弃对指针的控制权, 返回指针, 并将u置空.由于release并未将指向的空间释放,而是切断了u与对于空间的连续, 因此应该使用返回的指针去对另一个智能指针赋值.</span></span><br><span class="line"> <span class="comment">// 释放u指向的对象. 如果提供了内置指针q, 令u指向这个指针. </span></span><br><span class="line">u.reset();</span><br><span class="line">u.reset(q);</span><br><span class="line">u.reset(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unique&lt;<span class="built_in">string</span>&gt; p2(p1.release()); <span class="comment">//所有权从p1转换到p2;</span></span><br><span class="line"></span><br><span class="line">p2.release(); <span class="comment">//错误, p2不会释放内存, 而且我们丢失了指针.</span></span><br><span class="line"><span class="keyword">auto</span> p3 = p2.release(); <span class="comment">//正确.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>不能赋值, 但有一种情况例外, 就是编译器知道赋值后原来的<span class="built_in">unique_ptr</span>对象将被销毁:</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">向<span class="built_in">unique_ptr</span>传递销毁函数:</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;objectT, delT&gt; p(<span class="keyword">new</span> objetT, fcn);</span><br></pre></td></tr></table></figure>

<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象生命周期的智能指针, 由一个shared_ptr管理的对象. 将一个weak_ptr绑定到一个shared_ptr上不会增加shared_ptr的引用计数. 当shared_ptr被释放, weak_ptr就会被释放.</p>
<p>操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; w;</span><br><span class="line">weak_ptr&lt;T&gt; w(sp);</span><br><span class="line">w = p;</span><br><span class="line">w.reset(); <span class="comment">//w置空</span></span><br><span class="line">w.use_count(); <span class="comment">// 统计与shared_ptr共享空间的引用计数</span></span><br><span class="line">w.expired(); <span class="comment">// w.use_count == 0 return true, else return false;</span></span><br><span class="line">w.lock(); <span class="comment">// w.expired() = true 返回一个空的shared_ptr, 否则返回一个指向w的shared_ptr;</span></span><br></pre></td></tr></table></figure>

<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><h4 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *w = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] w;</span><br><span class="line"><span class="comment">// 多维数组.w[30][50][10];</span></span><br><span class="line"><span class="keyword">int</span> ***w = <span class="keyword">new</span> <span class="keyword">int</span> **[<span class="number">30</span>]; <span class="comment">//可以理解为*(w[][]) = [30][][];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    w[i] = <span class="keyword">new</span> <span class="keyword">int</span> *[<span class="number">50</span>]; <span class="comment">// w[i]为二维数组指针. 指向 [50][];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">50</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i][j] = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]; <span class="comment">//w[i][j]为一维数组指针, 指向[10];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">30</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">50</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] w;</span><br></pre></td></tr></table></figure>

<p>注意:当用new分配数组时, 我们并未得到一个数组类型对象, 而是得到了一个数组元素类型指针. 由于得到的不是数组类型, 因此不能使用begin和end函数. </p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>allocator将内存分配与对象构造分离开. 其分配的内存是原始的, 未构造的. 操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;T&gt; a; <span class="comment">// 定义一个名为a的allocator对象. 可以为类型为T的对象分配内存.</span></span><br><span class="line">a.allocate(n); <span class="comment">// 分配内存, 大小为n个T的大小.</span></span><br><span class="line">a.deallocate(p, n); <span class="comment">// 释放从T* 指针p开始的内存, 保存了n个对象. p是allocate返回的地址. n是创建时大小. 且在调用之前, 必须要对每一个对象调用destory</span></span><br><span class="line">a.construct(p, args); <span class="comment">// 使用args对p指向的内存构造一个T对象.</span></span><br><span class="line">a.destroy(p); <span class="comment">// 销毁p所指向的对象. 并不释放内存.</span></span><br></pre></td></tr></table></figure>

<h2 id="标准库特殊设施"><a href="#标准库特殊设施" class="headerlink" title="标准库特殊设施"></a>标准库特殊设施</h2><h3 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h3><p>tuple是特殊类型模板, tuple类型的成员可以不相同, 可以有任意数量的成员, 每个确定的tuple类型的成员数目是固定的. tuple支持的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;T1, T2, ..., Tn&gt; t;</span><br><span class="line">tuple&lt;T1, T2, ..., Tn&gt;t(v1, v2, ..., vn);</span><br><span class="line">make_tuple&lt;v1, v2, ..., vn&gt;;</span><br><span class="line">t1 == t2;</span><br><span class="line">t1!=t2;</span><br><span class="line">t1 relop t2;</span><br><span class="line">get&lt;i&gt;(t); <span class="comment">//返回t中第i个数据成员的引用.</span></span><br><span class="line">tuple_size&lt;tupletype&gt;::value; <span class="comment">// 类模板, 通过tuple类型初始化. 表示tuple类型中元素数量.</span></span><br><span class="line">tuple_element&lt;i, tupleType&gt;::type; <span class="comment">// tuple中第i个元素类型.</span></span><br></pre></td></tr></table></figure>

<p>tuple常被用来函数返回多个值.</p>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>模板是泛型编程的基础, 模板是一个创建类或函数的公式.</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>定义通用函数模板而不用为每个类型定义一个新函数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compre</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1&lt;v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1&gt;v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compare(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 正确, T为int</span></span><br><span class="line">compare(<span class="number">4</span>, <span class="number">0.5</span>);<span class="comment">//错误, T不能有两种类型.</span></span><br><span class="line">compare&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">0.5</span>); <span class="comment">//正确, 显示表明使用double类型实例, 4被认为为double</span></span><br></pre></td></tr></table></figure>

<p>在使用函数模板时, 编译器会根据输入参数进行选择相应的函数实例.  也可以显示的指明使用哪个模板实例.</p>
<p>类型参数前必须使用class或者typename:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">typename</span> <span class="title">U</span>&gt; //<span class="title">true</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">U</span>&gt; //<span class="title">false</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><p>一个非类型参数表示一个值而不是一个类型. 通过一个特定的类型名而非关键字class或typename来指定非类型参数. 当模板被实例化时, 非类型参数被一个用户提供的或者编译器推断的值代替.</p>
<p>ex1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n, <span class="keyword">int</span> m&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_length</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[n], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[m])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compare_length(<span class="string">"qwer"</span>, <span class="string">"qwert"</span>);<span class="comment">// n=5, m=6, 编译器会在字符串常量后添加空字符'\0'作为结尾.</span></span><br></pre></td></tr></table></figure>

<p>ex2:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> m, <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_lenth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[n])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compare_lenth&lt;<span class="number">8</span>&gt;(<span class="string">"hvgfcfg"</span>); <span class="comment">//对m赋值为8.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">8</span>;</span><br><span class="line">compare_lenth&lt;p&gt;(<span class="string">"hvgfcfg"</span>); <span class="comment">//错误, 非类型整型参数实参必须是一个常量.</span></span><br></pre></td></tr></table></figure>

<p>一个非类型参数可以是一个整型, 或者是一个对象或函数类型的指针或(左值)引用. 绑定到非类型整型参数实参必须是一个常量.</p>
<h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><p>一般我们将类定义和申明放在头文件中, 而普通函数和成员函数的定义放在源文件中. 但对于模板则不同, 为了生成一个实例化版本, 编译器需要掌握函数模板或类模板定义. 因此<font color="red"> 模板头文件即包含申明也包含定义</font></p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>编译器不能为类模板推断参数类型. 使用类模板, 我们必须在模板名后的尖括号中提供额外信息. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">class_name</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* .....*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class_name&lt;<span class="keyword">typename</span>&gt; args;</span><br></pre></td></tr></table></figure>

<h3 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h3><p>当在模板类中申明一个友元函数, 则该友元函数可以访问所以类模板的实例化类. </p>
<p>在类模板中申明友元类时有两种形式, 一种是将特定的模板实例申明为友元, 另一种是将通用模板类申明为友元.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class1</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class2</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt; <span class="title">class3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">class1</span>&lt;C&gt;;</span> <span class="comment">// 特定C实例化作为友元</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">friend</span> <span class="title">class</span> <span class="title">class2</span>;</span> <span class="comment">// 将所以class2的模板实例均作为友元类.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类模板的static成员"><a href="#类模板的static成员" class="headerlink" title="类模板的static成员"></a>类模板的static成员</h3><p>模板类的每一个实例均存在一套static成员.</p>
<h3 id="模板默认实参与类模板"><a href="#模板默认实参与类模板" class="headerlink" title="模板默认实参与类模板"></a>模板默认实参与类模板</h3><p>无论何时使用类模板都要使用&lt;&gt;, 但有时我们可以不用指定使用类型, 而是使用默认类型(如果有):</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; <span class="title">class_name</span>;</span></span><br><span class="line">class_name&lt;&gt; w; <span class="comment">// usw int</span></span><br></pre></td></tr></table></figure>

<h3 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h3><p>类模板的成员函数依然可以是模板函数.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">class_name</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; class_name(It b, It e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //类的类型参数</span></span><br><span class="line"><span class="class"><span class="title">template</span>&lt;class It&gt; // 成员函数的类型参数</span></span><br><span class="line"><span class="class"><span class="title">class_name</span>:</span>:class_name(It a, It, b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*'''''*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h2><p>当模板被使用时才会被实例化. 当多个独立编译的源文件都使用了相同的模板, 并提供了相同的模板参数时, 每个文件就会有该模板的实例. 这会导致花销的增加. 通过显示实例化来避免这种开销.</p>
<p>形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">//实例化申明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">//实例化定义</span></span><br></pre></td></tr></table></figure>

<p>当编译器遇到extern模板申明时, 它不会在本文件生成实例化代码. extern申明必须在使用次模板实例化之前. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span> <span class="comment">//使用string实例化Blob模板.</span></span><br></pre></td></tr></table></figure>

<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><p>顶层const无论是在形参中还是实参中都会被忽略. 这是由于&lt;class T&gt;中, 当使用const int作为参数时, T会被推断为const int, 当使用int作为参数时, T被推断为int. </p>
<p>参数调用时不会进行参数转换. 如算数转换, 派生类向基类的转换, 以及用户自定义的转换都不会在模板参数中出现.</p>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>在某些情况下, 编译器无法推断模板实参类型. 这时我们需要指定显式模板实参. </p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">sum</span>(<span class="title">T2</span>, <span class="title">T3</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line">sum&lt;<span class="keyword">int</span>&gt; sum(a, b); <span class="comment">//此时指定返回类型为int, T2, T3根据参数推断.</span></span><br></pre></td></tr></table></figure>

<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><p>在显式的实参中存在一个问题, 当我们知道返回类型时, 我们可以利用显式实参进行模板实例化, 但有时我们不知道要返回的类型时, 这就不好使了. 例如, 我们输入是class It, 返回值可能是&amp;It, 此时, 当It是int或double或者其他类型时, 返回值是不同的, 同时我们在调用该模板时可能不清楚真正使用的是哪个It, 此时, 就无法使用显式实参了. 为解决此问题, c++有两种策略, 尾置返回类型和类型转换.</p>
<p>使用尾置返回类型时, 可以使用decltype()进行返回类型的确定, 例如输入迭代器, 返回对应元素引用.</p>
<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">It</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">fcn</span>(<span class="title">It</span> <span class="title">beg</span>, <span class="title">It</span> <span class="title">end</span>)-&gt;<span class="title">decltype</span>(*<span class="title">beg</span>) // 返回元素引用, 具体参见<span class="title">decltype</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了获得元素类型, 我们可以使用标准库中的类型转换模板. 这些模板定义在type_traits头文件中.</p>
<p>常用类型模板为remove_reference</p>
<table>
    <tr>
        <th>对Mod &lt T &gt, 其中Mod为:</th>
        <th>若T为:</th>
        <th>则Mod&lt T &gt::type为:</th>
    </tr>
    <tr>
        <th>remove_reference</th>
        <th>X& or X&&</th>
        <th>X</th>
    </tr>
    <tr>
        <th>remove_reference</th>
        <th>否则</th>
        <th>T</th>
    </tr>
</table>

<p>使用实例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">It</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">fcn2</span>(<span class="title">It</span> <span class="title">beg</span>, <span class="title">It</span> <span class="title">end</span>)-&gt; <span class="title">typename</span> <span class="title">remove_reference</span>&lt;decltype(*beg)&gt;:</span>:type <span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中, 当使用迭代器进行实例化时, decltype(*beg)是对应参数的引用, 即X&amp;, 根据上述表格, remove_reference(X&amp;)::type为X, 因此该函数返回为对于元素.</p>
<h3 id="模板实参推断与引用"><a href="#模板实参推断与引用" class="headerlink" title="模板实参推断与引用"></a>模板实参推断与引用</h3><p>当模板参数为T&amp;&amp;即右值引用时, 比较特殊. 在此c++定义了两个例外, 其均是std::move()的基础.</p>
<h4 id="引用的引用-amp-amp"><a href="#引用的引用-amp-amp" class="headerlink" title="引用的引用(&amp; &amp;)"></a>引用的引用(&amp; &amp;)</h4><p>我们不能定义一个引用的引用, 但是, 通过类型别名或者模板类型参数间接定义是可以的.</p>
<p>类型别名使用引用的引用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_yy = <span class="keyword">int</span>&amp;;</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">5</span>;</span><br><span class="line">int_yy &amp;p1 = w; <span class="comment">//正确, 使用类型别名可以定义引用的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp; &amp;p2 = w; <span class="comment">// 错误, 不能直接定义引用的引用.</span></span><br></pre></td></tr></table></figure>

<p>这在模板引用中,  发生情况为, 当定义的模板为T&amp;&amp;时, 即右值引用时, 当我们传递参数为左值时, T就会被推断为对应类型的引用, 在加上之后的引用, 就变成了右值引用的引用. ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">It</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare</span>(<span class="title">It</span>&amp;&amp; <span class="title">a</span>, <span class="title">It</span>&amp;&amp; <span class="title">b</span>);</span></span><br><span class="line"><span class="keyword">double</span> w1 = <span class="number">15</span>, w2 = <span class="number">50</span>;</span><br><span class="line">compare(w1, w2); <span class="comment">// 此时, It被推断为double&amp;, 所以传递参数为double&amp; &amp;&amp;;</span></span><br></pre></td></tr></table></figure>

<h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><p>当出现引用的引用时, 为了解决这一问题, c++定义了引用折叠. 对于给定类型X;</p>
<p>X&amp;, X&amp; &amp;&amp;, X&amp;&amp; &amp;均被折叠成X&amp;,  X&amp;&amp; &amp;&amp;被折叠次X&amp;&amp;.</p>
<p>所以上述double&amp; &amp;&amp;被折叠成double&amp;.</p>
<p>由于引用折叠, 有时会出现比较严重的错误, 当使用T&amp;&amp;, 我们显然是希望使用临时变量, 但当我们传递左值时, 会被折叠错误引用, 此时就会对原本的左值进行更改, 但这往往是我们所不希望看到的. 为了解决这个问题, 我们应该定义const的重载函数.ex:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">It</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">T</span>&amp;&amp;);</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">It</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">const</span> <span class="title">T</span>&amp;);</span></span><br></pre></td></tr></table></figure>

<p>此时参数为左值时会调用下面的函数. 参数为右值引用时调用上面函数.</p>
<h3 id="理解std-move-的实现"><a href="#理解std-move-的实现" class="headerlink" title="理解std::move()的实现"></a>理解std::move()的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">remove_reference</span>&lt;T&gt;:</span>:<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以int为例解释, 当传入为右值时, T为int,  remove_reference<t>::type&amp;&amp;为int&amp;&amp;, 因此, 返回值return为int&amp;&amp;, 因此类型转换什么也不做.</t></p>
<p>当传入的是右值时, 根据第一条例外, T为int&amp;, remove_reference<t>::type&amp;&amp;为int&amp;&amp;, static_cast将t变为右值, 最终返回值依然是右值.</t></p>
<h1 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h1><p>编译:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cc project.cpp</span><br></pre></td></tr></table></figure>

<p>$为系统提示符, cc为编译器程序名字(g++), project.cpp为要编译的程序. unix下默认生成a.out可执行文件, windows下生成project.exe可执行文件. 也可以指定生成可执行文件名字. </p>
<p>unix下实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o demo project.cpp</span><br></pre></td></tr></table></figure>

<p>-o demo是编译器参数, 指定生成可执行文件名字.</p>
<h2 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h2><p>分离式编译允许将程序分割到几个文件中, 每个文件分别编译.</p>
<p>例如存在三个文件: funcation.h, funcation.cpp, main.cpp.分别包含函数申明, 函数定义, 函数使用.编译如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cc main.cpp funcation.cpp -o main</span><br><span class="line">==</span><br><span class="line">$ cc funcation.cpp main.cpp -o main</span><br></pre></td></tr></table></figure>

<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><p>程序可以包含一些用于调试的代码, 这些代码只在开发程序时使用, 当程序编写完成准备发布时, 要先屏蔽掉调试代码. 主要用到两项预处理功能: assert和NDEBUG.</p>
<h3 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h3><p>预处理宏: 预处理变量, 使用一个表达式作为条件: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(expr);</span><br></pre></td></tr></table></figure>

<p>首先对expr求值, 如果expr为, assert输出信息并终止程序, 否则assert什么也不做.</p>
<p>assert定义在cassert文件中.预处理名字由预处理而非编译器管理.</p>
<p>当assert的表达式expr为假时将执行#ifndef NDEBUG与#endif之间的代码.</p>
<h3 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h3><p>assert的行为依赖NDEBUG预处理变量的状态. 如果定义了NDEBUG则assrt什么也不做(等于没有), 默认没有定义NDEBUG, 此时assert将执行运行时检查.</p>
<p>我们使用一个#define语句定义NDEBUG, 从而关闭调试状态. 同时, 编译器都提供一个cmd选项使我们可以定义预处理变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cc -D NDEBUG main.cpp  #use /D with the windows</span><br></pre></td></tr></table></figure>

<p>这条指令表示在main.cpp文件的一开始写#define NDEBUG</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;argc;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;argv[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    assert(argc&gt;<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"未定义NDUBGET"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">编译: g++ main.cpp -o main</span><br><span class="line">运行:./main skjj suu ii</span><br><span class="line">输出:</span><br><span class="line">./main</span><br><span class="line">skjj</span><br><span class="line">suu</span><br><span class="line">ii</span><br><span class="line">未定义NDUBGET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编译:g++ -D NDEBUG main.cpp -o main</span><br><span class="line">运行:./main skjj suu ii</span><br><span class="line">输出:</span><br><span class="line">./main</span><br><span class="line">skjj</span><br><span class="line">suu</span><br><span class="line">ii</span><br></pre></td></tr></table></figure>

<h2 id="unix下使用g-编译过程及实例"><a href="#unix下使用g-编译过程及实例" class="headerlink" title="unix下使用g++编译过程及实例"></a>unix下使用g++编译过程及实例</h2><h3 id="g-编译器选项解读"><a href="#g-编译器选项解读" class="headerlink" title="g++编译器选项解读"></a>g++编译器选项解读</h3><ol>
<li>基本选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-E 是只进行预处理选项，不进行编译、汇编、以及连接</span><br><span class="line"></span><br><span class="line">-S 编译后停止，不进行汇编和连接</span><br><span class="line"></span><br><span class="line">-c 编译或会汇编文件，但不进行连接</span><br><span class="line"></span><br><span class="line">-o file 指定输出文件名</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>警告选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Wall 启用所有警告信息</span><br><span class="line"></span><br><span class="line">-Werror 在发生警告时取消编译操作，即将警报看作是错误</span><br><span class="line"></span><br><span class="line">-w 禁用所有警告信息</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>优化选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-O0：不进行优化处理</span><br><span class="line"></span><br><span class="line">-O或-O1：进行基本的优化，这些优化在大所属情况下都会使程序执行的更快</span><br><span class="line"></span><br><span class="line">-O2：除了完成-O1级别的优化外，还需要一些其他的调整工作，如处理器指令调度等，只是GNU发布软件的默认优化</span><br><span class="line"></span><br><span class="line">-O3：除了完成-O2级别的优化外，还进行循环的展开（这往往会提高执行速度）以及其他的一些预处理器相关的优化工作。</span><br><span class="line"></span><br><span class="line">-Os：生成最小的可执行文件，主要用在嵌入式领域。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>连接器选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Idirectory 向G++的头文件搜索路径中添加新的目录</span><br><span class="line"></span><br><span class="line">-Ldirectory 向G++的库文件搜索路径中添加一个行的目录</span><br><span class="line"></span><br><span class="line">-llibrary 提示连接程序在创建可执行文件时包含指定的库文件</span><br><span class="line"></span><br><span class="line">-static 强制使用静态库</span><br><span class="line"></span><br><span class="line">-shared 强制使用共享库</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>其他选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-xlanguage 指定输入文件的编程语言</span><br><span class="line"></span><br><span class="line">-v 显示编译器的版本号</span><br><span class="line"></span><br><span class="line">-g 获得有关调试程序的详细信息</span><br><span class="line"></span><br><span class="line">-ansi 支持符合ansi彼岸准的c程序</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<p>包含三个文件, add.h, add.cpp, test.cpp.</p>
<h3 id="第一步-预处理"><a href="#第一步-预处理" class="headerlink" title="第一步: 预处理"></a>第一步: 预处理</h3><p>预处理阶段是进行处理代码中的宏和include指令，并作语法检查。这一过程的命令为：g++ -E test.cpp -o test.i 执行这一步生成了一个test.i文件(预处理文件)</p>
<h3 id="第二步-汇编程序生成汇编码"><a href="#第二步-汇编程序生成汇编码" class="headerlink" title="第二步:汇编程序生成汇编码"></a>第二步:汇编程序生成汇编码</h3><p>将生成的预处理文件进行汇编. 命令为:　g++ -S test.i  -o test.s</p>
<p>生成汇编程序test.s</p>
<h3 id="第三步-由汇编程序转换为中间目标文件"><a href="#第三步-由汇编程序转换为中间目标文件" class="headerlink" title="第三步:由汇编程序转换为中间目标文件"></a>第三步:由汇编程序转换为中间目标文件</h3><p>这一步是将汇编的代码进一步进行处理，每一个源程序都会生成相应的目标文件，是以.o为扩展名的文件</p>
<p>命令为: g++ -c test.s -o test.o</p>
<p>​              g++ -c add.cpp -o add.o</p>
<h3 id="第四步-连接目标文件，生成最终目标文件-可执行文件或静态库或动态库"><a href="#第四步-连接目标文件，生成最终目标文件-可执行文件或静态库或动态库" class="headerlink" title="第四步: 连接目标文件，生成最终目标文件(可执行文件或静态库或动态库)"></a>第四步: 连接目标文件，生成最终目标文件(可执行文件或静态库或动态库)</h3><p>将上一步生成的中间文件进行链接, 生成最终的可执行文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ test.o add.o -o test</span><br><span class="line"></span><br><span class="line">==</span><br><span class="line"></span><br><span class="line">g++ add.o test.o -o test</span><br></pre></td></tr></table></figure>

<p>这里不要求先后顺序</p>
<p>上述四步可以简化为一步: g++ test.cpp add.cpp -o test 同样不强调先后.</p>
<p>连接opencv库 `pkg-config –cflags –libs opencv`</p>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>库就是一组已经写好了的函数和变量、是经过编译了的代码，为了提高开发的效率和运行的效率而设计的。库可以分为静态库和动态库（共享库）两类，在linux系统中静态库的扩展名为.a，动态库的扩展名是.so</p>
<p><strong>静态库</strong>是在每个程序进行链接的时候将库在目标程序中进行一次拷贝，当目标程序生成的时候，程序可以脱离库文件单独运行，换言之原来的文件即使删除程序还是会正常工作。</p>
<p><strong>共享库</strong>可以被多个应用程序共享，实在程序运行的时候进行动态的加载，因此对于每个应用程序来说，即使不再使用某个共享库，也不应该将其删除，因为其他的引用程序可能需要这个库。</p>
<p>生成静态库的过程是先将每个每个原文件进行编译生成中间目标文件，然后利用打包程序，将程序进行一次打包，最后生成静态库文件.</p>
<h2 id="CMake使用"><a href="#CMake使用" class="headerlink" title="CMake使用"></a>CMake使用</h2><p>使用流程:</p>
<ol>
<li>编写CMake配置文件CMakeLists.txt</li>
<li>执行CMake PATH. PATH为含有CMakeLists.txt文件的路径, 生成makefile</li>
<li>使用make进行编译</li>
</ol>
<h3 id="实例一-单文件"><a href="#实例一-单文件" class="headerlink" title="实例一: 单文件"></a>实例一: 单文件</h3><p>只含有一个test.cpp.</p>
<p>编写CMakeLists:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)`</span><br></pre></td></tr></table></figure>

<h3 id="实例二-同一目录-多个文件"><a href="#实例二-同一目录-多个文件" class="headerlink" title="实例二: 同一目录, 多个文件"></a>实例二: 同一目录, 多个文件</h3><p>test.cpp, add.h, add.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">./Demo2</span><br><span class="line"></span><br><span class="line">​    |</span><br><span class="line"></span><br><span class="line">​    +--- test.cpp</span><br><span class="line"></span><br><span class="line">​    |</span><br><span class="line"></span><br><span class="line">​    +--- add.cpp</span><br><span class="line"></span><br><span class="line">​    |</span><br><span class="line"></span><br><span class="line">​    +--- add.h</span><br></pre></td></tr></table></figure>

<p>CMakeList.txt:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="keyword">test</span>.cpp add.cpp)</span><br></pre></td></tr></table></figure>

<p>上述中add_executable(Demo test.cpp add.cpp)是将要编译的文件全部加入,但文件很多时将十分不便,因此使用aux_source_directory(&lt;dir&gt; &lt;variable&gt;)代替, 表示将目录dir下的所有源文件均添加进去.</p>
<p>于是更改为</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件,并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="实例三-多个目录-多个文件"><a href="#实例三-多个目录-多个文件" class="headerlink" title="实例三: 多个目录, 多个文件"></a>实例三: 多个目录, 多个文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./Demo3</span><br><span class="line"></span><br><span class="line">​    |</span><br><span class="line"></span><br><span class="line">​    +--- test.cpp</span><br><span class="line"></span><br><span class="line">​    |</span><br><span class="line"></span><br><span class="line">​    +--- add/</span><br><span class="line"></span><br><span class="line">​          |</span><br><span class="line"></span><br><span class="line">​          +--- add.h</span><br><span class="line"></span><br><span class="line">​          |</span><br><span class="line"></span><br><span class="line">​          +--- add.cpp</span><br></pre></td></tr></table></figure>

<p>需要分别在项目根目录 Demo3 和add目录里各编写一个 CMakeLists.txt 文件.为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>根目录中的 CMakeLists.txt:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo3)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(add)</span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo add)</span><br></pre></td></tr></table></figure>

<p>使用add_subdirectory(add)表明项目包含一个子目录 add, 这样 add 目录下的 CMakeLists.txt 文件和源代码也会被处理. target_link_libraries(Demo add)指明可执行文件 main 需要连接一个名为 add 的链接库.</p>
<p>子目录中的 CMakeLists.txt:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span> (add <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>add_library (add ${DIR_LIB_SRCS}) 将 add 目录中的源文件编译为静态链接库。</p>
<h2 id="使用VS-code进行C-编码"><a href="#使用VS-code进行C-编码" class="headerlink" title="使用VS code进行C++编码"></a>使用VS code进行C++编码</h2><ol>
<li>创建文件,并编写好代码.</li>
<li>编写CMakeLists.txt文件</li>
<li>调用命令台工具(Ctrl + Shift + P),选择Cmake Config. (每当文件结构发生变换就应当执行该步骤.)</li>
<li>运行build(点击build按钮)</li>
<li>测试成功 转到build目录.运行生成的目标可执行文件.</li>
<li>创建tasks.json(Ctrl + Shift + P 选择Tassk:configure tasks)更改”command”参数为”build/可执行文件” 如”build/example-app”</li>
<li>在Terminal中选择Run Task,选择tasks.json中”label”对应的参数, 再选择第一个</li>
<li>F5 创建launch.json, 将”program”参数改为”${command:cmake.launchTargetPath}” 即设置为Cmake插件的debug模式</li>
<li>再次点击build(Debug模式的Cmake)</li>
<li>点击debug按钮即可debug</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chst</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index-1.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index-1.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chst</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
