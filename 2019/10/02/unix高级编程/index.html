<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="-C/C++,">










<meta name="description" content="UNIX下高级编程，目前正在学习中，不断更新。">
<meta name="keywords" content="-C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="unix高级编程">
<meta property="og:url" content="http://yoursite.com/2019/10/02/unix高级编程/index.html">
<meta property="og:site_name" content="chst&#39;s Blog">
<meta property="og:description" content="UNIX下高级编程，目前正在学习中，不断更新。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/24/ZA0K9s.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/24/ZA0M3n.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/24/ZAOi2d.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/09/ntqGge.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/09/ntqJjH.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/09/ntLpxe.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/22/u9LVq1.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/22/u9Lma6.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/22/u9LAM9.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/22/u9LErR.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/22/u9LeVx.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/09/22/u9LnIK.png">
<meta property="og:image" content="https://s2.ax1x.com/2019/10/01/uUgGX4.png">
<meta property="og:updated_time" content="2019-10-01T16:49:12.071Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="unix高级编程">
<meta name="twitter:description" content="UNIX下高级编程，目前正在学习中，不断更新。">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/06/24/ZA0K9s.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/02/unix高级编程/">





  <title>unix高级编程 | chst's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chst's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人网站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/02/unix高级编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chst">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chst's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">unix高级编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-02T00:46:41+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">-Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  UNIX下高级编程，目前正在学习中，不断更新。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <center> <font size="15">UNIX环境高级编程</font></center>

<h1 id="第一章-UNIX基础知识"><a href="#第一章-UNIX基础知识" class="headerlink" title="第一章 UNIX基础知识"></a>第一章 UNIX基础知识</h1><h2 id="UNIX体系结构"><a href="#UNIX体系结构" class="headerlink" title="UNIX体系结构"></a>UNIX体系结构</h2><p>操作系统是一个软件, 控制计算机硬件资源, 提供程序运行环境. 也叫做内核.  内核接口是系统调用. 公共函数库构建在系统之上. 应用程序可以调用系统调用也可以调用公共函数. shell是一个特殊的应用程序, 为运行其他应用程序提供了一个接口. </p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>shell是一个命令行解释器, 读取用户输入, 然后执行命令. shell的输入通常来自终端(交互式shell), 有时来源于文件(shell脚本).</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>目录是一个包含目录项的文件. </p>
<p>创建新目录是会自动创建两个文件名: .(点) ..(点点) 点指向当前目录, 点点指向父目录.</p>
<p>ex: 将工作空间转到父目录的父目录.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../..</span><br></pre></td></tr></table></figure>

<h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>每个进程都有一个工作目录, 称为当前工作目录. 所有相对路径都是从当前目录开始解释. 可以通过chdir函数更改工作目录.</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符通常是一个小的非负整数, 内核用其来标识特定进程正在访问的文件. 当内核打开或者创建文件时都会返回一个文件描述符. 读写文件时使用文件描述符.</p>
<h3 id="标准输入-标准输出和标准错误"><a href="#标准输入-标准输出和标准错误" class="headerlink" title="标准输入, 标准输出和标准错误"></a>标准输入, 标准输出和标准错误</h3><p>当程序执行时, 所有shell都会打开三个文件描述符, 即标准输入, 标准输出和标准错误. 默认情况下三个描述符都指向终端(即输入输出和错误都通过终端进行交互). 同时可以将一个或者3个描述符重定向到指定文件. “&gt; file_name”: 将标准输出重定向到file_name文件中(如果没有就会创建). “&lt;file_name”: 将标准输入重定向到file_name中.</p>
<p>ex:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; files_list -a</span><br></pre></td></tr></table></figure>

<p> 将当前目录下的文件输出到files_list文件中.</p>
<p>对于一个可执行文件a.out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out &lt; input_file &gt; output_file</span><br></pre></td></tr></table></figure>

<p>此时程序中标准输入就会从input_file读取, 标准输出就会到output_file中.</p>
<h3 id="不带缓冲的I-O"><a href="#不带缓冲的I-O" class="headerlink" title="不带缓冲的I/O"></a>不带缓冲的I/O</h3><p>函数open, read, write, lseek以及close提供了不带缓冲的I/O. 均使用文件描述符.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(文件描述符, char [], BUFFSIZE); //从文件描述符连接的文件读字符串</span><br><span class="line">write(文件描述符, char [], BUFFSIZE); //向文件描述符连接的文件写字符串</span><br></pre></td></tr></table></figure>

<h2 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序:"></a>程序:</h3><p>存储在磁盘的可执行文件, 内核使用exec()(7个), 将程序读入内存并执行.</p>
<h3 id="进程与进程ID"><a href="#进程与进程ID" class="headerlink" title="进程与进程ID"></a>进程与进程ID</h3><p>进程: 程序的执行实例. UNIX保证每个进程都有唯一的一个数字标识符. 即进程ID. 通过getpid()函数获取进程ID.</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>三个主要函数: fork, exec和waitpid函数.</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>创建一个新的进程, 返回两个pid_t,  对父进程返回子进程的ID号, 对子进程返回0. 当调用此函数时, 新进程调用父进程的一个副本. 相当于将父进程进行了一份拷贝(?), 在调用该命令之前的信息两个进程完全一致(并不是资源共享, 只是资源的值一致, 对于变量来说, 指向地址不同,而是值相同). 该命令之后的两个进程分别执行. 对于返回的两个不同的值作为用来作为后续执行代码的选择区分.</p>
<h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><p>等待进程执行结束. 参数为进程ID, 返回进程的终止状态.</p>
<p>ex: simple_shell.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> statue;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%%"</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) <span class="comment">//每次读取标准输入的一行, 以空(ctrl+D)作为结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] == <span class="string">'\n'</span>) <span class="comment">//替换换行符为空字符</span></span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>) <span class="comment">// 创建新进程, if后的程序会在父进程与新进程中执行两遍, 按照pid选择执行方式.</span></span><br><span class="line">            err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">//执行子进程</span></span><br><span class="line">            &#123;</span><br><span class="line">                execlp(buf, buf, (<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">                err_sys(<span class="string">"coundn't execute: %s"</span>, buf);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">127</span>); <span class="comment">// 结束子进程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((pid = waitpid(pid, &amp;statue, <span class="number">0</span>))&lt;<span class="number">0</span>) <span class="comment">// 由于子进程在之前已经结束, 子进程无法执行到此, 所以pid只能是子进程ID(父进程返回为0), 该语句为等待子进程结束,statue用来返回子进程终止状态。</span></span><br><span class="line">            err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%%"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><p>线程: 某一时刻执行的一组机器指令. 一个进程内所有线程共享同一地址空间, 文件描述符, 栈以及与进程相关的属性. 线程也有线程标识, 线程ID只能所属进程中有效.</p>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UNIX出错时, 通常会返回一个负值, 部分整型变量erron通常被设置为具有特定含义的值. &lt;errno.h&gt;中定义了erron以及可以赋予它的常量. </p>
<p>c标准库定义了两个函数用于打印出错信息.</p>
<h3 id="strerror"><a href="#strerror" class="headerlink" title="strerror()"></a>strerror()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">char</span>* <span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>; <span class="comment">//根据输入的整数(代表错误类型)获得错误信息.</span></span><br></pre></td></tr></table></figure>

<h3 id="perror"><a href="#perror" class="headerlink" title="perror()"></a>perror()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclide<span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *mag)</span> </span>; <span class="comment">//向标准输出中打印mag信息: 错误信息.错误信息由erron指明.</span></span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#includ<span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(argc, *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"EACCES: %s \n"</span>, strerror(EACCES)); <span class="comment">// EACCES为头文件中包含指明错误的常量.</span></span><br><span class="line">    erron = ENOENT; <span class="comment">// erron同样是被定义在头文件中.用来指明perror打印的错误类型.</span></span><br><span class="line">    perror(argv[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h2><h3 id="用户ID-1"><a href="#用户ID-1" class="headerlink" title="用户ID"></a>用户ID</h3><p>口令文件登录项中用户ID是一个数值, 标识不同用户. ID= 0 为超级用户. 如果进程具有超级用户权限则大多数权限检测都不用进行.</p>
<h3 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h3><p>/etc/group文件中.</p>
<h3 id="附属ID"><a href="#附属ID" class="headerlink" title="附属ID"></a>附属ID</h3><h2 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号(signal)"></a>信号(signal)</h2><p>信号用于通知进程发生了某种情况. 进程有三种处理信号的方式:</p>
<ol>
<li>忽略信号</li>
<li>按默认方式处理.</li>
<li>通过一个函数, 当信号发生时调用该函数, 称为捕获信号.</li>
</ol>
<h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><h3 id="日历时间"><a href="#日历时间" class="headerlink" title="日历时间"></a>日历时间</h3><p>从1970年1月1日00:00:00到指定时间进过多少秒.系统基本数据类型time_t存储这种时间值.</p>
<h3 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h3><p>用于度量进程使用CPU资源. 进程时间以时钟滴答计算. 每秒可以有不同时间滴答数取值.</p>
<p>度量一个进程执行的时间时 UNIX系统为一个进程维护3个进程时间值.</p>
<ol>
<li>时钟时间(CPU时间): 进程运行总时间.</li>
<li>用户CPU时间: 执行用户指令所用的时间量.</li>
<li>系统CPU时间: 进程中调用内核程序时所使用的时间.</li>
</ol>
<p>用户CPU时间和系统CPU时间之和被称为CPU时间.</p>
<p>获得进程时间方式:  在执行程序的指令前加上time即可.</p>
<p>ex: time ls -a;</p>
<h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><p>操作系统提供的服务的入口点被称为系统调用. </p>
<p>UNIX使用技术为为每个系统调用都在标准C库中设置一个具有同样名字的函数. 用户进程用标准C调用序列来调用这些函数, 这些函数又用系统所需要的技术调用相应的内核服务.</p>
<h1 id="第三章-文件I-O"><a href="#第三章-文件I-O" class="headerlink" title="第三章 文件I/O"></a>第三章 文件I/O</h1><h2 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言, 所有打开的文件都是通过文件描述符引用. 文件描述符为非负整数, 打开文件或者创建一个新文件时将返回一个文件描述符. UNIX系统shell将文件描述符0与标准输入关联(STDIN_FILENO). 1与标准输出关联(STDOUT_FILENO), 2与标准错误关联(STDERR_FILENO).</p>
<h2 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h2><p>open和openat用于打开或者创建一个文件. 原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...<span class="comment">/*mode_t mode */</span>)</span></span>;</span><br><span class="line">...表示最后一个参数, 表明余下的参数数量和类型均不定. 对与open只有在创建文件时才会使用到最后的参数;</span><br><span class="line">path表示要打开或者创建的文件名. oflag表示此函数的多个选项, 使用下列一个或对个常量进行或运算构成oflag参数, 均被定义在&lt;fcntl.h&gt;头文件中:</span><br><span class="line">oflag参数:</span><br><span class="line"><span class="comment">// 下面五个只能选一个</span></span><br><span class="line">O_RDONLY  read only;</span><br><span class="line">O_WRONLY  write only;</span><br><span class="line">O_RDWR    write <span class="keyword">and</span> read;</span><br><span class="line">O_EXEC    only execute;</span><br><span class="line">O_SEARCH  only search; <span class="comment">// linux don't exist.</span></span><br><span class="line"><span class="comment">// 下面的可以任性选择</span></span><br><span class="line">O_APPEND     每次写时追加到末尾</span><br><span class="line">O_CLOEXEC    把FD_CLOEXEC常量设置为文件描述标识符</span><br><span class="line">O_CREAT      若此文件不存在则创建, 创建时将使用最后的参数指明新文件的访问权限</span><br><span class="line">O_DIRECTORY  如果path引用得到不是目录就会出错</span><br><span class="line">O_EXCL       如果同时指定了O_CREAT而文件已经存在则会报错, 用于测试文件是否已经存在. 使得测试和创建成为一个原子操作</span><br><span class="line">O_NOCTTY     如果path引用的是终端设备, 则不将该设备分配作为此进程的控制终端</span><br><span class="line">O_NOFOLLOW   如果path引用的是一个符号连接将会出错</span><br><span class="line">O_NONBLOCK   如果path引用的是一个FIFO, 一个块特殊文件或者一个字符特殊文件, 则此选项为文本的本次打开和后续I/O为非阻塞式.</span><br><span class="line">O_SYNC       使每次write等待物理I/O操作完成, 包括由该write引起的文件属性更新.</span><br><span class="line">O_TRUNC      如果此文件存在, 且为写或读写方式打开,则将长度截断为<span class="number">0</span></span><br><span class="line">O_TTY_INIT   如果打开一个未打开的终端设备, 设置非标准termios参数值, 使其符合Single UNIX Specificatation</span><br><span class="line">O_DSYNC      使每次write要等待物理I/O操作完成, 但是如果改写操作并不影响读刚写入的数据,则不需要等待文件属性被更改.</span><br><span class="line">O_RSYNC      使每一个以文件描述符作为参数进行的read操作等待, 直到所有对文件同一部分挂起的写操作完成.</span><br></pre></td></tr></table></figure>

<p>fd参数将open与openat函数区分开, 主要有三种情况:</p>
<ol>
<li>path为绝对路径, fd被忽略, open与openat一致.</li>
<li>path指定相对路径, fd指出相对路径名在文件系统中的开始地址. fd参数通过打开相对路径名所在的目录名来获取.</li>
<li>path参数指定了相对路径名, fd参数具有特殊值AT_FDCWD, 在这种情况下, 路径名在当前工作目录中获取, openat函数在操作上与open类似.</li>
</ol>
<h2 id="函数creat"><a href="#函数creat" class="headerlink" title="函数creat"></a>函数creat</h2><p>creat创建一个新文件, 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回只写打开的文件描述符, 错误返回-1;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h2><p>close关闭一个打开的文件. 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关闭文件还会释放加在该文件上的记录锁.</p>
<h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>每一个打开的文件都有一个与其相关联的”当前字节偏移量”. 通常是一个非负整数, 用以度量从文件开始处计算的字节数. 读写操作都是从当前文件偏移量处开始. 当打开一个文件时, 除显示使用O_APPEND选项, 否则偏移量为零. 可以通过lseek设置偏移量. 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="comment">// 成功返回新的文件偏移量, 否则返回-1;</span></span><br><span class="line">参数offset与whence有关:</span><br><span class="line"><span class="number">1</span> 当whence是SEEK_SET, 则偏移量设置为从文件开始到offset个字节处.</span><br><span class="line"><span class="number">2</span> 当whence是SEEK_CUR, 偏移量为当前值加上offset当前位置.</span><br><span class="line"><span class="number">3</span> 当whence是SEEK_END, 则偏移量设置为文件长度加上offset.</span><br></pre></td></tr></table></figure>

<p>文件偏移量可以大于文件的当前长度, 此时对该文件的下一次写操作将加长该文件, 并在该文件中构成一个空洞, 位于文件中但没有写过的字节都被度为0, 空洞并不占用磁盘空间.</p>
<h2 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h2><p>read从打开文件读取数据, 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="comment">//返回类型, 读到的字节数, 若已经达到文件末尾则返回0; 若出错返回-1;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h2><p>write函数向一个打开的文件写数据, 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>

<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX系统支持不同进程共享打开的文件. 内核使用三种结构表示打开的文件, 他们的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响.</p>
<p>(1) 每个进程在进程表中都有一个记录项, 记录项中包含一张打开文件描述符表, 与文件表项向关联的是:</p>
<ol>
<li>文件描述符标志</li>
<li>指向一个文件表项的指针.</li>
</ol>
<p>(2) 内核为所有打开文件维持一张文件表. 每个文件表包含:</p>
<ol>
<li>文件状态标志(读, 写, 添加, 同步, 阻塞等)</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ol>
<p>(3) 每个打开文件(或设备)都有一个v节点结构. v节点包含了文件类型和对此文件进行各种操作函数的指针. 大多数文件, v节点还包含该文件i节点的指针.</p>
<p>下图展示了三者之间的关系:</p>
<p><img src="https://s2.ax1x.com/2019/06/24/ZA0K9s.png" alt="结构"></p>
<p>如果两个独立进程各自打开同一文件, 则有下图关系:</p>
<p><img src="https://s2.ax1x.com/2019/06/24/ZA0M3n.png" alt="打开同一文件"></p>
<p><font color="red">可能有多个文件描述符项指向同一文件表项.</font>这会在dup或fork函数后产生. 注意: 文件描述符标志与文件状态标志在作用范围上的区别: 前者只用于一个进程的一个描述符, 而后者则应用与指向该文件表项的任意进程中的所有描述符.(有点类型指针和底层存储的区别).</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作指的是由多步组成的一个操作. 如果该操作原子的执行, 则要么执行完所有的步骤, 要么一步也不执行, 不可能只执行所以步骤中的一个子集. 任何要求多于一个函数调用的操作都不是原子操作, 因为在两个函数调用之间, 内核有可能会临时挂起进程.</p>
<h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>dup和dup2都用来赋值一个现有的文件描述符. 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="comment">//函数返回值, 若成功返回新的文件描述符, 否则返回-1</span></span><br></pre></td></tr></table></figure>

<p>由dup返回的新文件描述符一定是当前可用文件描述符中最小数值. dup2可以通过fd2指定新的文件描述符的值. 如果fd2已经打开则先关闭. 如果fd2与fd一致,则不关闭直接返回fd2.  执行dup函数后可能的结果如图:</p>
<p><img src="https://s2.ax1x.com/2019/06/24/ZAOi2d.png" alt="dup"></p>
<h2 id="函数sync-fsync-fdatasync"><a href="#函数sync-fsync-fdatasync" class="headerlink" title="函数sync, fsync, fdatasync"></a>函数sync, fsync, fdatasync</h2><p>传统的UNIX系统实现内核中设有缓冲区高速缓存或页高速缓存. 向文件写入数据时, 内核首先将数据复制到缓冲区, 然后排入队列. 当内核需要重用缓冲区来存放其他磁盘块数据时, 它会把延迟写数据块写入磁盘, 为了保证磁盘上实际文件与缓冲区内容一致, 可以使用sync, fsync, fdatasync函数. 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sync将所有修改过的缓冲区排入写队列, 然后返回, 并不等待实际写磁盘结束.</p>
<p>fsync函数只对指定文件描述符起作用, 并且等待写磁盘结束才返回.</p>
<p>fdatasync与fsync类似, 不过只影响文件的数据部分, 而fsync除了数据部分还会同步更新文件属性.</p>
<h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性. 原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/* int arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fcntl函数有以下5中功能:</p>
<ol>
<li>赋值一个已有的文件描述符(cmd = F_DUPFD或F_DUPFD_CLOEXEC).</li>
<li>获取/设置文件描述符标志(cmd = F_GETFD或F_SETFD).</li>
<li>获取/设置文件状态标志(cmd = F_GETFL或F_SETFL).</li>
<li>获取/设置异步I/O所有权(cmd = F_GETOWN或F_SETOWN).</li>
<li>获取/设置记录锁(cmd = F_GETLK, F_SETLK或F_SETLKW).</li>
</ol>
<p>下面对上述参数进行解释:</p>
<table>
    <tr>
        <td>F_DUPFD</td>
        <td>复制文件描述符fd. 新文件描述符作为返回值. 新描述符与fd共享同一文件表, 但新文件描述符有自己的一套文件描述符标志,其中FD_CLOEXEC文件描述标志被清除(表示该描述符在exec时任有效)</td>
    </tr>
    <tr>
        <td>F_DUPFD_CLOEXEC</td>
        <td>复制文件描述符, 设置与新描述符关联的FD_CLOEXEC文件描述符标志的值</td>
    </tr>
    <tr>
        <td>F_GETFD</td>
        <td>对应于fd的文件描述符标志作为函数返回值. 当前只定义了一个文件描述符标志FD_CLOEXEC. 由于五个基本的访问方式标志不是各占一位, 因此我们需要使用屏蔽字O_ACCMODE取得访问标志位, 然后将结果与五个值对比.</td>
    </tr>
    <tr>
        <td>F_SETFD</td>
        <td>对于fd设置文件描述符标志, 新标志值按第三个参数设置</td>
    </tr>
    <tr>
        <td>F_GETFL</td>
        <td>对应fd的文件状态标志作为函数返回值</td>
    </tr>
    <tr>
        <td>F_SETFL</td>
        <td>将文件状态标志设为第三个参数的值</td>
    </tr>
    <tr>
        <td>F_GETOWN</td>
        <td>获取当前接收SIGIO和SIGURG信号进程ID或进程组ID</td>
    </tr>
    <tr>
        <td>F_SETOWN</td>
        <td>设置接收SIGIO和SIGURG信号的进程ID或进程组ID</td>
    </tr>
</table>

<p>fcntl返回值与命令有关, 如果出错则都返回-1, 否则返回某个其它值.</p>
<p>例: 查看文件状态标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage: a.out&lt;descriptor#&gt;"</span>);</span><br><span class="line">    <span class="keyword">if</span>((val = fcntl(atoi(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>))&lt;<span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"fcntl error for fd %d"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">switch</span>(val &amp; O_ACCMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read only"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"write only"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_RDWR:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read write"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err_dump(<span class="string">"unknow access mode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_APPEND)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", append"</span>);</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_NONBLOCK)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", nonblock"</span>);</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_SYNC)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", sunchronous write"</span>);</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span></span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_FSYNC)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", synchronous write"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ./getfl.o <span class="number">0</span> &lt; /dev/tty</span><br><span class="line">read only</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ./getfl.o <span class="number">1</span> &gt; temp.foo</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ cat temp.foo</span><br><span class="line">write only</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ./getfl.o <span class="number">2</span> <span class="number">2</span>&gt;&gt;temp.foo</span><br><span class="line">write only, append</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ./getfl.o <span class="number">5</span> <span class="number">5</span>&lt;&gt;temp.foo</span><br><span class="line">read write</span><br></pre></td></tr></table></figure>

<p>子句<code>5&lt;&gt;temp.foo</code>表示在文件描述符5上打开文件temp.foo以供读写。</p>
<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统提供/dev/fd目录, 其目录项是名0, 1, 2等的文件. 打开文件/dev/fd/n等效于复制描述符n. </p>
<p>例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/o"</span>, mode);</span><br><span class="line">==</span><br><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>/dev/fd文件主要用于shell, 它允许使用路径名作为调用参数的程序. 例如cat将’-‘解释为标准输入.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 - file3 | lpr</span><br><span class="line">==</span><br><span class="line">filer file2 | cat file1 /dev/fd/0 file3 | lpr</span><br><span class="line">// |表示通道, 即前一个命令的输出作为下一个命令的输入</span><br></pre></td></tr></table></figure>

<p>这里’-‘别替换为filter file2的输出。</p>
<h1 id="第四章-文件和目录"><a href="#第四章-文件和目录" class="headerlink" title="第四章 文件和目录"></a>第四章 文件和目录</h1><h2 id="函数stat-fstat-fstatat和lstat"><a href="#函数stat-fstat-fstatat和lstat" class="headerlink" title="函数stat, fstat, fstatat和lstat"></a>函数stat, fstat, fstatat和lstat</h2><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>

<p>　　一旦给出pathname，stat函数返回与此命名文件有关的信息结构。fstat获得已在描述符fd中打开的文件有关信息。lstat与stat类似，但当命名文件是一个符号链接时，lstat返回该链接对应的有关信息而不是链接指向的文件。</p>
<p>　　fstatat返回相对于当前打开目录（由fd参数指向）的路径名的文件统计信息。flag参数控制是否跟随着一个符号链接。当AT_SYLINK_NOFOLLOW被置位时，不跟随符号链接，只返回符号链接本身的文件信息。否则，在默认情况下，返回的是符号链接指向的文件对于的信息。如果fd参数是AT_FDCWD，并且pathname是一个相对路径，则会计算相对于当前目录的pathname参数，返回对应文件信息。如果pathname是绝对路径，fd会被忽略。</p>
<p>　　buf是一个指针，指向我们必须提供的结构。函数来填充内容。结构的基本形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line">    <span class="keyword">mode_t</span> st_mode; <span class="comment">//文件类型和mode(权限)</span></span><br><span class="line">    <span class="keyword">ino_t</span>  st_ino; <span class="comment">//i节点数量</span></span><br><span class="line">    <span class="keyword">dev_t</span>  st_dev;<span class="comment">//设备数量</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev;<span class="comment">//对于特殊文件来说设备数量</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink;<span class="comment">//链接数量</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid;<span class="comment">//拥有者用户ｉｄ</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid;<span class="comment">//拥有者组ｉｄ</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;<span class="comment">//大小(bytes)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atime</span>;</span><span class="comment">//最后一次访问时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtime</span>;</span><span class="comment">//最后一次更改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_time</span>;</span><span class="comment">//最后一次文件stat更改时间。</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;<span class="comment">//best I/O block size</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span> st_blocks;<span class="comment">//number of disk bocks allocated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timespec结构类型按照秒和纳秒定义了时间，至少包含以下两个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time_t tv_sec;</span><br><span class="line">long tv_nsec;</span><br></pre></td></tr></table></figure>

<p>stat中使用到的类型大都属于基本统计类型。使用前<code>include&lt;sys/types.h&gt;</code>。</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><table>
<thead>
<tr>
<th align="center">文件类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通文件</td>
<td align="center">最常见的文件，包含某种形式数据。</td>
</tr>
<tr>
<td align="center">目录文件</td>
<td align="center">包含了其他文件的名字以及指向这些文件有关信息的指针。对于一个目录文件具有度权限的任一进程都能读取目录内容，但只有内核能够写目录文件。</td>
</tr>
<tr>
<td align="center">块特殊文件</td>
<td align="center">提供对设备带缓冲的访问，每次访问以以固定长队为单位进行。</td>
</tr>
<tr>
<td align="center">字符特殊文件</td>
<td align="center">提供对设备不带缓冲的访问，每次访问长度可变。系统中的所以设备要么是字符特殊文件，要么是块特殊文件。</td>
</tr>
<tr>
<td align="center">FIFO(管道)</td>
<td align="center">用于进程间通讯。</td>
</tr>
<tr>
<td align="center">套接字(socket)</td>
<td align="center">用于进程间网路通信。</td>
</tr>
<tr>
<td align="center">符号连接。</td>
<td align="center">指向另一个文件。</td>
</tr>
</tbody></table>
<p>文件类型信息包含在stat结构中的st_mode中。使用如下宏来确定文件类型：参数均为stat结果中的st_mode。</p>
<table>
<thead>
<tr>
<th align="center">S_ISREG()</th>
<th align="center">普通文件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S_ISDIR()</td>
<td align="center">目录文件</td>
</tr>
<tr>
<td align="center">S_ISCHR()</td>
<td align="center">字符特殊文件</td>
</tr>
<tr>
<td align="center">S_ISBLK()</td>
<td align="center">块特殊文件</td>
</tr>
<tr>
<td align="center">S_ISFIFO()</td>
<td align="center">管道</td>
</tr>
<tr>
<td align="center">S_ISLNK()</td>
<td align="center">符号连接</td>
</tr>
<tr>
<td align="center">S_ISSOCK()</td>
<td align="center">套接字</td>
</tr>
</tbody></table>
<h2 id="设置用户ID和组ID"><a href="#设置用户ID和组ID" class="headerlink" title="设置用户ID和组ID"></a>设置用户ID和组ID</h2><p>一个进程关联的ID有六个或更多。</p>
<table>
<thead>
<tr>
<th>实际用户ID/实际组ID</th>
<th>我们实际上是谁</th>
</tr>
</thead>
<tbody><tr>
<td>有效用户ID/有效组ID/附属组ID</td>
<td>用于文件访问权限检查</td>
</tr>
<tr>
<td>保存的设置用户ID/保存的设置组ID</td>
<td>由exec函数保存</td>
</tr>
</tbody></table>
<p>通常有效用户ID等于实际用户ID，有效组ID等于实际组ID。所以者和所有者组由stat中st_uid和st_gid指定。</p>
<p>实际用户ID和实际组ID表示我们究竟是谁.这两个字段在登录时取自口令文件的登录项(应该是由执行该文件的用户决定).</p>
<p>当执行一个程序文件时,通常进程的有效用户ID就是实际用户ID,有效组ID通常是实际组ID. 但我们可以在文件模式字(st_mode)中设置一个标志,其含义是”当执行次文件时,将进程有有效用户ID设置为文件所有者的用户ID”,与次类似,在文件模式字中,可以设置另一位,它将执行文件的进程的有效组ID设置为文件所有者组ID.这两个位分别为设置用户ID位(set-user-id)和设置组ID位(set-group-ID).</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a><a id="文件访问权限 ">文件访问权限</a></h2><p>st_mode值也包含了对文件的访问权限.这里的文件是指上述所有七种文件.</p>
<p>每个文件有几个访问位权限,可以分为三类:</p>
<table>
<thead>
<tr>
<th align="center">st_mode屏蔽</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S_IRUSER/S_IWUSER/S_IXUSE</td>
<td align="center">用户读/写/执行</td>
</tr>
<tr>
<td align="center">S_IRGRP/S_IWGRP/S_IXGRP</td>
<td align="center">组读/写/执行</td>
</tr>
<tr>
<td align="center">S_IROTH/S_IWORT/S_IXOTH</td>
<td align="center">其他读/写/执行</td>
</tr>
</tbody></table>
<p>用户指的是所有者.chomd命令用来修改这九个权限.该命令允许我们用u表示用户,用g表示组,用o表示其他.</p>
<p>使用规则:</p>
<h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>当我们使用名字打开一个文件时,我们对该名字中包含的每一个目录,包括它可能隐藏的当前的工作目录都应该具有指向权限.这也是为何对目录执行权限位通常被称为搜索位.</p>
<p>注意:对于目录的读权限和执行权限的意义是不同的.读权限允许我们读目录,获得在该目录下所以文件名的列表.当一个目录是我们要访问文件路径名的一部分时,对该目录的执行权限使得我们可以通过该目录.</p>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>对于一个文件的读权限决定了我们能否打开文件进行读操作.</p>
<h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>对于一个文件的写权限决定了我们能否打开文件进行写操作.</p>
<h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><p>为了在open函数中对一个文件指定O_TRUNC标志,必须对该文件具有写权限.</p>
<h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><p>为了在一个目录下创建一个新文件,需要对该目录具有写和执行权限.</p>
<h3 id="六"><a href="#六" class="headerlink" title="六"></a>六</h3><p>为了删除一个文件,需要对该文件所在目录具有写和执行权限而不必对文件本身具有相应权限.</p>
<h3 id="七"><a href="#七" class="headerlink" title="七"></a>七</h3><p>如果使用七个exec函数执行某个文件,需要对该文件具有执行权限.</p>
<p>进程每次<font color="red">打开,创建,删除</font>一个文件时,内核就会进行文件访问权限测试,而这种测试可能涉及文件所有者(st_uid和st_gid),进程的有效ID(有效用户ID和有效组ID)已经进程的附属组ID.<font color="red">两个所有者ID是文件的性质,而两个有效ID和附属ID则是进程的性质</font>. 内核测试具体如下:</p>
<ol>
<li>若进程有效ID是0(超级用户),则允许访问.</li>
<li>若进程的有效用户ID等于文件所有者ID(即进程拥有此文件),则判断所有者是否具有进程将要操作的权限,如果没有则拒绝.</li>
<li>若进程的有效组ID或进程的附属组ID之一等于文件的组ID,那么组适当的权限被置位则允许访问.</li>
<li>若其他用户适当的访问权限被置位,则允许访问.</li>
</ol>
<p>按顺序执行这四步.需要注意,这四步是截断的,即一个条件被满足就不会继续向下进行.</p>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置为进程的有效用户ID,新文件的组ID可以是进程的有效组ID,也可以是它所在目录的组ID.</p>
<h2 id="函数access和faccess"><a href="#函数access和faccess" class="headerlink" title="函数access和faccess"></a>函数access和faccess</h2><p>access和faccess是按照进程实际用户ID和实际组ID进行权限测试的.</p>
<p>函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.d&gt;</span><br><span class="line">int access(const char *pathname, int mode);</span><br><span class="line">int faccessat(int fd, const char *pathname, int mode, int flag);</span><br></pre></td></tr></table></figure>

<p>当要测试文件是否存在时,mode是F_OK,否则mode是下面常量按位或.</p>
<table>
<thead>
<tr>
<th align="center">mode</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">R_OK</td>
<td align="center">测试读权限</td>
</tr>
<tr>
<td align="center">W_OK</td>
<td align="center">测试写权限</td>
</tr>
<tr>
<td align="center">X_OK</td>
<td align="center">测试执行权限</td>
</tr>
</tbody></table>
<p>当pathname是绝对路径和当fd是AT_FDCWD而pathname是相对路径时,faccessat与acess是相同的.</p>
<p>flag参数可以用于改变faccessat行为,如果flag设置为AT_ACCESS访问检测用的是有效用户ID和有效进程ID.</p>
<h2 id="例-acess-cpp"><a href="#例-acess-cpp" class="headerlink" title="例:acess.cpp"></a>例:acess.cpp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;apue.h&quot;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc!=2)</span><br><span class="line">    &#123;</span><br><span class="line">        err_quit(&quot;usage: a.out&lt;pathname&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(access(argv[1], R_OK)&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        err_ret(&quot;access error for%s&quot;,argv[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;read access ok\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(open(argv[1], O_RDONLY)&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        err_ret(&quot;open error for %s&quot;,argv[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;open for reading ok\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$g++ access.cpp -o access.o -lapue</span><br><span class="line">$ls -l access.o</span><br><span class="line">-rwxrwxr-x 1 chst chst 13328 Sep  8 15:40 access.o</span><br><span class="line">$./access.o access.cpp</span><br><span class="line">read access ok</span><br><span class="line">open for reading ok</span><br><span class="line">$ls -l /etc/shadow</span><br><span class="line">-rw-r----- 1 root shadow 1395 May  6 19:00 /etc/shadow</span><br><span class="line">$ ./access.o /etc/shadow</span><br><span class="line">access error for/etc/shadow: Permission denied</span><br><span class="line">open error for /etc/shadow: Permission denied</span><br><span class="line">$ sudo chown root access.o   //更改文件用户为超级用户</span><br><span class="line">[sudo] password for chst: </span><br><span class="line">$ sudo chmod u+s access.o //打开设置用户位,即使得进程的有效ID等于文件的用户ID,即超级用户.</span><br><span class="line">$ ls -l access.o</span><br><span class="line">-rwsrwxr-x 1 root chst 13328 Sep  8 15:40 access.o //这里s表示设置用户位被置位</span><br><span class="line">$exit //退出超级用户</span><br><span class="line">$ ./access.o /etc/shadow</span><br><span class="line">access error for/etc/shadow: Permission denied</span><br><span class="line">open for reading ok</span><br></pre></td></tr></table></figure>

<p>这里解释一下最后的输出,在执行access.o时,我们是以普通用户进行的,此时进程的实际ID即为普通用户ID,但由于设置用户位被置位,此时进程的有效用户ID为超级用户ID,因为在打开文件时,是使用有效用户来进行判断的,因此此时可以打开文件,但是我们实际用户ID是普通用户,因此使用access进行检查时,会显示权限错误,因此尽管我们可以打开文件,但可以确定实际用户不能正常读指定文件.但该程序现在是可以正常读取指定文件的.</p>
<h2 id="函数umask-文件模式创建屏蔽字"><a href="#函数umask-文件模式创建屏蔽字" class="headerlink" title="函数umask(文件模式创建屏蔽字)"></a>函数umask(文件模式创建屏蔽字)</h2><p>umask函数为进程设置文件模式创建屏蔽字,并返回之前的值.</p>
<p>函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">mode_t umask(mode_t cmask);</span><br></pre></td></tr></table></figure>

<p>其中cmask为之前<a href="#文件访问权限 ">表格</a>里面的9个常量或的结果.在进程创建一个新文件和新目录时,就一定会使用文件模式创建屏蔽字.(open和creat函数都有参数mode,其就是用来指定新文件的访问权限).</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;apue.h&quot;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#define RWRWRW (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    umask(0);</span><br><span class="line">    if(creat(&quot;foo&quot;, RWRWRW)&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(&quot;creat foo error!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    if((creat(&quot;bar&quot;, RWRWRW)&lt;0))</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(&quot;creat bar error!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chst@wyk-GL63:~/study_file/unix编程$ umask //查看当前屏蔽字, 0002表示只有其他写被屏蔽</span><br><span class="line">0002</span><br><span class="line">$ ./umask.o</span><br><span class="line">$ ls -l foo bar</span><br><span class="line">-rw------- 1 chst chst 0 Sep  8 17:34 bar</span><br><span class="line">-rw-rw-rw- 1 chst chst 0 Sep  8 17:34 foo</span><br></pre></td></tr></table></figure>

<p>更改环境文件创建屏蔽字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$umask -S //打印符号格式</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br><span class="line">$umask 0027 //更改屏蔽字,屏蔽用户组读和其他的所以权限</span><br><span class="line">$umask -S</span><br><span class="line">u=rwx,g=rx,o=</span><br></pre></td></tr></table></figure>

<h2 id="函数chmod-fchmod和fchmodat"><a href="#函数chmod-fchmod和fchmodat" class="headerlink" title="函数chmod,fchmod和fchmodat"></a>函数chmod,fchmod和fchmodat</h2><p>这三个函数使得我们可以更改现有文件的访问权限.</p>
<p>函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">int chmod(const char *pathname, mode_t mode);</span><br><span class="line">int fchmod(int fd, mode_t mode);</span><br><span class="line">int fchmodat(int fd, const char *pathname, mode_t mode, int flag)</span><br></pre></td></tr></table></figure>

<p>chmod操作指定文件,fchmod操作打开的文件, 当pathname为绝对路径或fd参数为AT_FDCWD而pathname为相对路径时,fchmodat与chmod一样. flag参数用来改变fchmodat行为,当设置了AT_SYMLIN_NOFOLLOW标志时,fchmodat不会跟随符号链接.</p>
<p>为了改变一个文件的权限位,进程的有效用户ID必须等于文件所有者ID,或者进程拥有超级用户权限.参数mode是如下常量取与或:</p>
<table>
<thead>
<tr>
<th align="center">mode</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S_ISUID</td>
<td align="center">执行时设置用户ID</td>
</tr>
<tr>
<td align="center">S_ISGID</td>
<td align="center">执行时设置用户组ID</td>
</tr>
<tr>
<td align="center">S_ISVTX</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">S_IRWXU</th>
<th align="center">用户(所有者)读写和执行</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S_IRUSR</td>
<td align="center">用户读</td>
</tr>
<tr>
<td align="center">S_IWUSR</td>
<td align="center">用户写</td>
</tr>
<tr>
<td align="center">S_IXUSR</td>
<td align="center">用户执行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">S_IRWXG</th>
<th align="center">用户组读写和执行</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S_IRGRP</td>
<td align="center">用户组读</td>
</tr>
<tr>
<td align="center">S_IWGRP</td>
<td align="center">用户组写</td>
</tr>
<tr>
<td align="center">S_IXGRP</td>
<td align="center">用户组执行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">S_IRWXO</th>
<th align="center">其他读写和执行</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S_IROTH</td>
<td align="center">其他读</td>
</tr>
<tr>
<td align="center">S_IWOTH</td>
<td align="center">其他写</td>
</tr>
<tr>
<td align="center">S_IXOTH</td>
<td align="center">其他执行</td>
</tr>
</tbody></table>
<p>命令行添加设置用户ID和设置组ID方式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$chmod u+s filename</span><br><span class="line">$chmod g+s filename</span><br><span class="line">-rwSrwSrw- //这里S表示设置ID开启.</span><br></pre></td></tr></table></figure>

<h2 id="函数chown-fchown-fchownat和lchown"><a href="#函数chown-fchown-fchownat和lchown" class="headerlink" title="函数chown,fchown,fchownat和lchown"></a>函数chown,fchown,fchownat和lchown</h2><p>这几个函数是用来更改文件用户ID和组ID的.函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int chown(const char *pathname, uid_t owner, gid_t group);</span><br><span class="line">int fchown(int fd, uid_t owner, gid_t group);</span><br><span class="line">int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);</span><br><span class="line">int lchown(const char *pathname, uid_t owner, gid_t group);</span><br></pre></td></tr></table></figure>

<p>当owner或group任意一个是-1,则对应的ID不变.</p>
<p>除了所引用的文件是符号链接以外,这4个函数操作类似.在符号连接下,lchown与fchownat(设置了AT_SYMLINK_NOFOLLOW)更改符号链接本身而不是连接指向的文件.</p>
<p>当pathname为绝对路径或fd参数为AT_FDCWD而pathname为相对路径时,fchownat与chmod一样. flag参数用来改变fchmodat行为,当设置了AT_SYMLIN_NOFOLLOW标志时,fchmodat不会跟随符号链接.</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在说明文件链接前先介绍一下文件系统,这里主要介绍的是UFS系统.</p>
<p>我们把一个磁盘分成一个或多个分区,每个分区都包含一个文件系统.细节见下图:</p>
<p><img src="https://s2.ax1x.com/2019/09/09/ntqGge.png" alt="文件系统"></p>
<p>仔细观察柱面<code>i</code>节点和数据块的部分,会存在下图的关系:</p>
<p><img src="https://s2.ax1x.com/2019/09/09/ntqJjH.png" alt="i节点"></p>
<p>注意细节:</p>
<ol>
<li>图中有两个目录项指向同一个<code>i</code>节点.每个<code>i</code>节点都有一个连接计数,其值是指向该<code>i</code>节点的<font color="red">目录项数</font>.只有当链接计数等于0的时候才可以删除文件(释放该文件所占用的数据块).在stat中,链接计数包含在st_nlink中,基本数据类型是nlink_t.这种链接为硬链接.</li>
<li>还有一种链接为符号链接.符号链接链接文件的实际内容(在数据块中)包含了该符号链接所执向的文件的名字.</li>
<li>i节点包含了文件的所以信息:文件类型,访问权限,文件长度和指向文件数据块的指针等. stat中大多数内容取自i节点,只有文件名和i节点编号放在目录项中.</li>
<li>当在不更换文件系统的情况下为一个文件重命名时,该文件实际内容并未移动,只需要构造一个指向当前i节点的新目录项,并删除老目录项即可,连接计数不会改变.</li>
</ol>
<p>目录文件的计数说明:</p>
<p>使用<code>mkdir testdir</code>创建一个新目录时,结果如下:</p>
<p><img src="https://s2.ax1x.com/2019/09/09/ntLpxe.png" alt="创建目录"></p>
<p>该图显示的展现出了<code>.</code>和<code>..</code>.</p>
<p>任何一个叶目录(不包含目录的目录)连接计数均为2.数值2来自于命名该目录的目录项和在该目录中的<code>.</code>.编号为1267的i节点,链接计数大于等于3.这是由于,一个是命名它的目录项,一个是自己目录下的<code>.</code>,还有则是新建的目录testdir中的<code>..</code>(目录下的目录中的<code>..</code>都是对父目录的硬链接,会增加i节点计数).</p>
<h2 id="函数link-linkat-unlink和remove"><a href="#函数link-linkat-unlink和remove" class="headerlink" title="函数link, linkat, unlink和remove"></a>函数link, linkat, unlink和remove</h2><p>使用link和linkat函数创建一个指向当前文件的链接.函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int link(const char *existingpath, const char *newpath);</span><br><span class="line">int linkat(int efd, const char *existingpath, int nfg, const char *newpath, int flag);</span><br><span class="line">// 函数返回值0正常,-1出错.</span><br></pre></td></tr></table></figure>

<p>两个函数创建一个新目录项newpath,它引用现有文件existingpath. 创建新目录项和增加链接计数应该是原子操作.</p>
<p>为了删除一个现在的目录项, 可以使用unlink和unlinkat函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unstd.h&gt;</span><br><span class="line">int unlink(const char *pathname);</span><br><span class="line">int unlink(int fd, const char *pathname, int flag);</span><br></pre></td></tr></table></figure>

<p>两个函数删除目录项,并将有pathname所引用文件的链接计数减一.为了解除对文件的链接,我们必须对该目录具有写和执行权限.只有当链接计数达到0的时候该文件内容才会被删除.</p>
<p><font color="red," size="8">注意:</font> 只要有进程打开了该文件,其内容也不会被删除.关闭一个文件时,内核首先检测打开该文件的进程数目,如果这个数值等于0,再去查看链接计数,如果链接计数也达到0,才删除文件.利用该特性,unlink常常被用来确保在程序崩溃的情况下删除临时创建的文件.进程使用open或creat创建一个文件,然后立即调用unlink,由于该文件仍旧是打开的,因此不会被立即删除,只有当进程终止时,文件才会被删除.</p>
<p>fd和pathname用来确定路径的.flag给出一种方式,当AT_REMOVEDIR被设置时,unlinkat函数类似与rmdir一样删除目录.</p>
<p>如果pathname给出的是符号链接,则只能删除符号链接本身,当是符号链接时,没有能够直接删除符号链接所引用的文件的函数.</p>
<p>可以使用remove解除对一个文件或目录的链接. 对于目录,remove与rmdir类型,对于文件,remove与unlink类型.</p>
<p>函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int remove(const char *pathname);</span><br></pre></td></tr></table></figure>

<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;apue.h&quot;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if(open(&quot;temp.foo&quot;, O_RDWR)&lt;0)</span><br><span class="line">        err_sys(&quot;open eror&quot;);</span><br><span class="line">    if(unlink(&quot;temp.foo&quot;)&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(&quot;unlink error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;file unlinked\n&quot;);</span><br><span class="line">    sleep(15);</span><br><span class="line">    printf(&quot;done\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ls -l temp.foo</span><br><span class="line">-rw-rw-r-- 1 chst chst 8 Sep 10 23:59 temp.foo</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ./unlink.o &amp; //后台运行程序</span><br><span class="line">[1] 9597</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ file unlinked</span><br><span class="line">done</span><br><span class="line"> ls -l temp.foo</span><br><span class="line">ls: cannot access &apos;temp.foo&apos;: No such file or directory //目录项已被删除(数据块未被删除)</span><br><span class="line">[1]+  Done                    ./unlink.o</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$</span><br></pre></td></tr></table></figure>

<h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以使用rename和renameat来命名,函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int rename(const char *oldname, const char *newname);</span><br><span class="line">int renameat(int oldfd, const char *oldname, int newfd, const char *newname);</span><br></pre></td></tr></table></figure>

<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针,它与上一节的硬链接(直接指向<code>i</code>节点)不同,符号链接指向的是目录项.这是为了规避硬链接的一些限制:</p>
<ol>
<li>硬链接通常要求链接和文件位于同一文件系统下.</li>
<li>只有超级用户才能创建指向目录的硬链接.</li>
</ol>
<p>对符号链接以及它指向何种对象并无任何限制,任何用户都可以创建指向目录的符号链接.符号链接是为了将一个文件或整个目录移到系统的另一个位置.</p>
<p>使用符号链接可能造成循环:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chst@wyk-GL63:~/study_file/unix编程$ mkdir loop</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ touch loop/a  //创建一个空文件a</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ln -s ../loop loop/testdif //在目录下创建一个符号链接指向目录本身</span><br><span class="line">chst@wyk-GL63:~/study_file/unix编程$ ls -l loop</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r-- 1 chst chst 0 Sep 11 00:37 a</span><br><span class="line">lrwxrwxrwx 1 chst chst 7 Sep 11 00:37 testdif -&gt; ../loop</span><br></pre></td></tr></table></figure>

<p>此时就会造成循环,因为目录下的符号链接指向目录本身.</p>
<p>![Screenshot from 2019-09-11 00-40-23](/home/chst/Pictures/Screenshot from 2019-09-11 00-40-23.png)</p>
<p>此时使用Solares中的ftw以降序遍历文件结构,打印每一个遇到的路径名,结果为:</p>
<p>![Screenshot from 2019-09-11 00-40-42](/home/chst/Pictures/Screenshot from 2019-09-11 00-40-42.png)</p>
<p>这个循环是十分容易消除的,因为unlink不跟随符号链接,可以使用unlink文件foo/testdir.但如果创建一个构成这样的硬链接,就很难消除(难吗?直接删除testdir不就好了?).因此link不允许一般用户(linux下超级用户也不行)构造指向目录的链接.</p>
<h2 id="创建和读取符号连接"><a href="#创建和读取符号连接" class="headerlink" title="创建和读取符号连接"></a>创建和读取符号连接</h2><p>可以使用symlink或symlinkat函数创建一个符号链接.函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath,<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="comment">//两个函数成功返回0,出错返回-1</span></span><br><span class="line"><span class="comment">// // 创建符号链接$ln -s actualpath sympath</span></span><br></pre></td></tr></table></figure>

<p>函数创建一个指向actualpath的新目录项sympath.并不要求actualpath已经存在,且两个不必在同一个文件系统中.</p>
<p>open函数会打开链接指向内容,因此需要一种方式打开链接本身,并读该链接中的名字.函数readlink和readlinkat提供这一功能.函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span> *restatrict pathname,<span class="keyword">char</span> *<span class="keyword">restrict</span> buf,<span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize);</span><br><span class="line"><span class="comment">//成功返回buf中读取字节数,否则返回-1</span></span><br></pre></td></tr></table></figure>

<p>两个函数组合了open,read,和close的所有操作.buf返回的符号链接不以null为结尾.</p>
<h2 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h2><p>每个文件维护三个时间字段:</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">说明</th>
<th align="center">例子</th>
<th align="center">ls选项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">st_atim</td>
<td align="center">文件数据最后访问时间</td>
<td align="center">read</td>
<td align="center">-u</td>
</tr>
<tr>
<td align="center">st_mtim</td>
<td align="center">文件数据的最后修改时间</td>
<td align="center">write</td>
<td align="center">默认</td>
</tr>
<tr>
<td align="center">st_ctim</td>
<td align="center">i节点最后的更该时间</td>
<td align="center">chmod,chown</td>
<td align="center">-c</td>
</tr>
</tbody></table>
<p>注意: 修改时间(st_mtim)与状态更改时间(st_ctim)的区别.修改时间是指文件内容修改时间(数据块),状态更改时间是该文件i节点最后被修改时间.状态更改时间包括更改访问权限,用户ID,连接计数.</p>
<h2 id="函数futimens-utimensat-utimes函数"><a href="#函数futimens-utimensat-utimes函数" class="headerlink" title="函数futimens,utimensat,utimes函数"></a>函数futimens,utimensat,utimes函数</h2><p>函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimenstat</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数用于更改文件访问和修改时间.times数组参数第一个元素包含访问时间,第二个元素包含修改时间,均是时间戳.</p>
<p>时间戳按照下列四种方式之一进行指定:</p>
<ol>
<li>如果times参数是空指针,则访问时间和修改时间都设置为当前时间.</li>
<li>如果times指向两个timespec结构的数组,任一数组元素的tv_nesc字段值为UTIME_NOW,相应的时间戳就设置为当前时间,忽略相应的tv_sec字段.</li>
<li>如果times指向两个timespec结构的数组,任一数组元素的tv_nesc字段值为UTIME_OMIT,相应的时间戳保持不变,忽略相应的tv_sec字段.</li>
<li>如果times指向两个timespec结构的数组,任一数组元素的tv_nesc字段值即不为UTIME_OMIT也不是UTIME_NOW,相应的时间戳设置为对应的两个字段值.</li>
</ol>
<p>utims对目录名时间进行操作,函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;</span><br><span class="line"><span class="keyword">long</span> tv_usec;<span class="comment">//毫秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不能更改状态更改时间st_ctim指定一个值,因为调用这三个函数时,此字段会被自动更新.</p>
<h2 id="函数mkdir-mkdirat和rmdir"><a href="#函数mkdir-mkdirat和rmdir" class="headerlink" title="函数mkdir,mkdirat和rmdir"></a>函数mkdir,mkdirat和rmdir</h2><p>用mkdir,mkdirat,用rmdir函数删除目录.函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>两个函数创建一个新的空目录.其中<code>.</code>和<code>..</code>被自动创建.所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改.常见错误是指定与文件一样的mode(只指定读写).对于目录来说,者少应该添加执行权限来允许访问目录中的文件名.</p>
<p>使用rmdir函数删除一个空目录:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unsid.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果调用该命令使得目录的链接计数达到0,并且也没有进程打开该目录,则释放次目录占用的空间.如果此时有进程打开该目录,则在进程结束前删除最后一个链接及<code>.</code>和<code>..</code>,在此目录下不能创建文件,但在最后一个打开该目录的进程结束前不会释放次目录.</p>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有访问权限的任意用户都可以读目录,但只有内核可以写目录.一个目录的写权限决定了在该目录下能否创建新文件以及删除文件,它们不代表能否写目录本身.</p>
<p>相关函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">//成功返回指针,出错返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR, *dp)</span></span>;</span><br><span class="line"><span class="comment">//成功返回指针,出错返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0,错误返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="comment">//返回与dp关联的目录中的当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp,<span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个静态函数,传参为函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myftw</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span> (*Myfunc)(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct stat *, <span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dopath</span><span class="params">(<span class="keyword">int</span> (*Myfunc)(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct stat *, <span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Myfunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct stat *statprt, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_quit(<span class="string">"usage: ftw &lt;starting-pathname&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = myftw(argv[<span class="number">1</span>], Myfunc);</span><br><span class="line">    ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock;</span><br><span class="line">    <span class="comment">// 避免除以0</span></span><br><span class="line">    <span class="keyword">if</span>(ntot == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ntot = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"regular file   = %7ld, %5.2f%%\n"</span>, nreg, nreg*<span class="number">100.0</span>/ntot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"directories    = %7ld, %5.2f%%\n"</span>, ndir, ndir*<span class="number">100.0</span>/ntot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"block special  = %7ld, %5.2f%%\n"</span>, nblk, nblk*<span class="number">100.0</span>/ntot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char special   = %7ld, %5.2f%%\n"</span>, nchr, nchr*<span class="number">100.0</span>/ntot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FIFOs          = %7ld, %5.2f%%\n"</span>, nfifo, nfifo*<span class="number">100.0</span>/ntot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"symbolic link  = %7ld, %5.2f%%\n"</span>, nslink, nslink*<span class="number">100.0</span>/ntot);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sockets        = %7ld, %5.2f%%\n"</span>, nsock, nsock*<span class="number">100.0</span>/ntot);</span><br><span class="line">    <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTW_F 1 <span class="comment">//普通文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTW_D 2 <span class="comment">//目录</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTW_DNR 3 <span class="comment">//无法读取的目录</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTW_NS 4 <span class="comment">//没有stat的文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *fullpath; <span class="comment">//文件绝对路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> pathlen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myftw</span><span class="params">(<span class="keyword">char</span> *pathname, <span class="keyword">int</span> (*Myfunc)(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct stat *, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fullpath = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(PATH_MAX+<span class="number">1</span>); <span class="comment">//分配PATH_MAX+1字节</span></span><br><span class="line">    <span class="keyword">if</span>(pathlen&lt;=<span class="built_in">strlen</span>(pathname))</span><br><span class="line">    &#123;</span><br><span class="line">        pathlen = <span class="built_in">strlen</span>(pathname) * <span class="number">2</span>;</span><br><span class="line">        fullpath = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(pathlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(fullpath, pathname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fullpath1 = %s\n"</span>, fullpath);</span><br><span class="line">    <span class="keyword">return</span> dopath(Myfunc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索DFS,遍历每个文件和目录</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dopath</span><span class="params">(<span class="keyword">int</span> (*Myfunc)(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct stat *, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="keyword">int</span> ret, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归终止的2个条件,1:文件相关信息无法获取, 2:传递的绝对路径不是目录而是文件</span></span><br><span class="line">    <span class="keyword">if</span>(lstat(fullpath, &amp;statbuf)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Myfunc(fullpath, &amp;statbuf, FTW_NS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(statbuf.st_mode)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Myfunc(fullpath, &amp;statbuf,FTW_F);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果fullpath是目录</span></span><br><span class="line">    <span class="comment">//如果返回表示0表示出错</span></span><br><span class="line">    <span class="keyword">if</span>((ret=Myfunc(fullpath, &amp;statbuf, FTW_D)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="built_in">strlen</span>(fullpath);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fullname long = %d\n"</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(n+NAME_MAX+<span class="number">2</span>&gt;pathlen)</span><br><span class="line">    &#123;</span><br><span class="line">        pathlen *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span> *save = fullpath;</span><br><span class="line">        fullpath = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(pathlen);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            fullpath[j] = save[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fullpath[n++]=<span class="string">'/'</span>;</span><br><span class="line">    fullpath[n] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fullpath2=%s\n"</span>, fullpath);</span><br><span class="line">    <span class="keyword">if</span>((dp = opendir(fullpath)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fullpath3=%s\n"</span>, fullpath);</span><br><span class="line">        <span class="keyword">return</span> Myfunc(fullpath, &amp;statbuf, FTW_DNR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逐个获取目录下文件名,直到空表示终止</span></span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dp))!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dirp-&gt;d_name, <span class="string">"."</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dirp-&gt;d_name, <span class="string">".."</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(&amp;fullpath[n], dirp-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span>((ret=dopath(Myfunc))!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fullpath[n<span class="number">-1</span>] = <span class="number">0</span>; <span class="comment">//恢复初始路径,深度优先搜索回溯</span></span><br><span class="line">    <span class="keyword">if</span>(closedir(dp)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_ret(<span class="string">"can't close directory %s"</span>, fullpath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Myfunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct stat *statprt, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FTW_F:</span><br><span class="line">        <span class="keyword">switch</span> (statprt-&gt;st_mode &amp; S_IFMT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> S_IFREG: nreg++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S_IFBLK: nblk++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S_IFCHR: nchr++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S_IFIFO: nfifo++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S_IFLNK: nslink++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S_IFSOCK: nsock++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S_IFDIR: err_dump(<span class="string">"for S_IFDIR for %s"</span>, fullpath); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FTW_D:</span><br><span class="line">        ndir++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FTW_DNR:</span><br><span class="line">        err_ret(<span class="string">"can't read1 directory %s"</span>, fullpath);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FTW_NS:</span><br><span class="line">        err_ret(<span class="string">"stat error for %s"</span>, fullpath);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        err_dump(<span class="string">"unknown type %d for pathname %s"</span>, type, fullpath);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./readdir.o /home</span><br><span class="line">regular file   =  321788, 91.13%</span><br><span class="line">directories    =   25916,  7.34%</span><br><span class="line">block special  =       0,  0.00%</span><br><span class="line">char special   =       0,  0.00%</span><br><span class="line">FIFOs          =       1,  0.00%</span><br><span class="line">symbolic link  =    5390,  1.53%</span><br><span class="line">sockets        =       0,  0.00%</span><br></pre></td></tr></table></figure>

<h2 id="函数chdir-fchdir和getcwd"><a href="#函数chdir-fchdir和getcwd" class="headerlink" title="函数chdir,fchdir和getcwd"></a>函数chdir,fchdir和getcwd</h2><p>每个进程都有一个当前工作目录,此目录是搜索所有相对路径的起点.当用户登录到UNIX时,器当前工作目录通常是口令文件(/etc/passwd)中该用户登录项的第六个字段–用户起始目录.当前工作目录是进程的一个属性,起始目录则是登录名的一个属性.进程调用chdir或fchdir函数更改当前工作目录:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">//返回0表示成功,返回-1表示错误.</span></span><br></pre></td></tr></table></figure>

<p>获取当前工作目录的绝对路径:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getpwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//成功返回buf,失败返回NULL</span></span><br></pre></td></tr></table></figure>

<p>参数buf是缓冲区地址,size是缓冲区长度,缓冲区必须有足够长度以容纳绝对路径名再加上一个null字节.</p>
<h1 id="第五章-标准I-O库"><a href="#第五章-标准I-O库" class="headerlink" title="第五章 标准I/O库"></a>第五章 标准I/O库</h1><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>对于标准I/O库,操作都是围绕流进行的.当用标准库打开或创建一个文件时,我们已近使用一个流与其关联.</p>
<p>流的定向决定了所读写的是单字节还是多字节.如若在未定向的流上使用多字节I/O函数,则将该流的定向设置为宽定向的,若在未定向的流上使用一个单字节I/O函数,则将该该流设置为字节定向的.</p>
<p>fwide函数用于设置流的定向:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//宽定向返回正值,字节定向返回负值,为定向返回0</span></span><br></pre></td></tr></table></figure>

<p>mode为负值,试图将流指定为字节定向,mode为正值,试图将流指定为宽定向,mode为0,不指定定向.</p>
<p>fwide不改变已定向的流的定向.</p>
<p>当打开一个流时,标准I/O函数fopen返回一个指向FILE对象的指针.该对象通常是一个结构,它包含了标准I/O库为管理该流需要的所有信息,包括用于实际I/O的文件描述符,指向用于该缓冲区的指针,缓冲区的长度,当前在缓冲区的长度以及出错标志等.</p>
<h2 id="标准输入-标准输出与标准错误"><a href="#标准输入-标准输出与标准错误" class="headerlink" title="标准输入,标准输出与标准错误"></a>标准输入,标准输出与标准错误</h2><p>对一个进程预定义了三个流,标准输入,标准输出与标准错误.这三个流进程可以自动使用.</p>
<p>这三个标准I/O通过预定义文件指针stdin,stdout.stderr加以引用,这三个文件指针被定义在头文件&lt;stdio.h&gt;中.</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是为了尽可能的减少使用read和write次数.标准库提供了三种缓冲类型.</p>
<p>(1)全缓冲.在这种情况下,在填满标准I/O缓冲区后才进行实际I/O操作.在一个流上第一次执行I/O操作时,相关标准I/O函数通常调用malloc获得需要的缓冲区.</p>
<p>　　术语冲洗说明标准I/O写操作.缓冲区可向标准I/O自动冲洗,或者可以调用fflush冲洗一个流.flush存在两种意思,在I/O方面,flush表示将缓冲区写入磁盘,在终端驱动程序方面,flash表示丢弃已存储在缓冲区的数据.</p>
<p>(2)行缓冲. 在输入和输出遇到换行符时,标准I/O库执行I/O操作.这允许我们一次输出一个字符,但只在写了一行后才进行实际I/O操作.终端中(涉及标准输入输出),通常使用行缓冲.</p>
<p>　　对于行缓冲通常有两个限制.第一:I/O库的缓冲区是有限制的,如果一行太长,填满了缓冲区,即使没有到达换行符,也进行I/O操作.第二:任何时候,通过标准I/O库要求从(a)一个不带缓冲的流,或者(b)一个行缓冲流得到数据,那么就会冲洗所以行输出流.</p>
<p>(3)不带缓冲.标准I/O不对字符进行缓冲存储.标准错误流stderr通常是不带缓冲的,这就是使得错误信息可以立即显式出来.</p>
<p>ISO C要求缓冲特征:</p>
<ol>
<li>当且仅当标准输入和标准输出并不指向交互设备时,他们才是全缓冲的.</li>
<li>标准错误绝不是全缓冲的.</li>
</ol>
<p>一般系统默认缓冲类型:</p>
<ol>
<li>标准错误是不带缓冲的.</li>
<li>若是指向终端设备的流,则是行缓冲的,否则是全缓冲.</li>
</ol>
<p>可以使用下列两个函数更改缓冲类型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf,<span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//返回0成功,否则失败</span></span><br></pre></td></tr></table></figure>

<p>参数解释:</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">mode</th>
<th align="center">buf</th>
<th align="center">缓冲区及长度</th>
<th align="center">缓冲类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setbuf</td>
<td align="center"></td>
<td align="center">非空</td>
<td align="center">长度为BUFSIZ的用户缓冲区buf</td>
<td align="center">全缓冲或行缓冲</td>
</tr>
<tr>
<td align="center">setbuf</td>
<td align="center"></td>
<td align="center">NULL</td>
<td align="center">无缓冲区</td>
<td align="center">不带缓冲</td>
</tr>
<tr>
<td align="center">setvbuf</td>
<td align="center">_IOFBF</td>
<td align="center">非空</td>
<td align="center">长度为size的缓冲区buf</td>
<td align="center">全缓冲</td>
</tr>
<tr>
<td align="center">setvbuf</td>
<td align="center">_IOFBF</td>
<td align="center">NULL</td>
<td align="center">合适长度的系统缓冲区buf</td>
<td align="center">全缓冲</td>
</tr>
<tr>
<td align="center">setvbuf</td>
<td align="center">_IOLBF</td>
<td align="center">非空</td>
<td align="center">长度为size的缓冲区buf</td>
<td align="center">行缓冲</td>
</tr>
<tr>
<td align="center">setvbuf</td>
<td align="center">_IOLBF</td>
<td align="center">NULL</td>
<td align="center">合适长度的系统缓冲区buf</td>
<td align="center">行缓冲</td>
</tr>
<tr>
<td align="center">setvbuf</td>
<td align="center">_IONBF</td>
<td align="center">忽略</td>
<td align="center">无缓冲</td>
<td align="center">不带缓冲</td>
</tr>
</tbody></table>
<p>任何时候,我们可以强制刷新一个流:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0,否则返回EOF</span></span><br></pre></td></tr></table></figure>

<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathnem, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathnem, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type,FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fopen打开路径名为pathname的文件.</p>
<p>freopen在一个指定流上打开文件,如果流已经被打开,则先关闭该流.如果流已经定向,则清除定向,此函数通常将一个指定的文件绑定到一个指定的流上:标准输入输出错误.</p>
<p>fdopen取一个文件描述符,并使一个标准I/O流与该描述符结合.此函数通常用于创建管道和网路通信通道函数返回的描述符.</p>
<p>type有15种取值:</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">说明</th>
<th align="center">open标准</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>r</code>/<code>rb</code></td>
<td align="center">为读而打开</td>
<td align="center">O_RDONLY</td>
</tr>
<tr>
<td align="center"><code>w</code>/<code>wb</code></td>
<td align="center">把文件截断为0长,或为写而创建</td>
<td align="center">O_WRONLY|O_CREAT|O_TRUNC</td>
</tr>
<tr>
<td align="center"><code>a</code>/<code>ab</code></td>
<td align="center">追加:为在文件尾写而打开,或为写而创建</td>
<td align="center">O_WRONLY|O_CREAT|O_APPEND</td>
</tr>
<tr>
<td align="center"><code>r+</code>/<code>r+b</code>/<code>rb+</code></td>
<td align="center">为读和写创建</td>
<td align="center">O_RDONLY</td>
</tr>
<tr>
<td align="center"><code>w+</code>/<code>w+b</code>/<code>wb+</code></td>
<td align="center">把文件截断为0长,或为写而创建</td>
<td align="center">O_WRONLY|O_CREAT|O_TRUNC</td>
</tr>
<tr>
<td align="center"><code>a+</code>/<code>a+b</code>/<code>ab+</code></td>
<td align="center">追加:为在文件尾写而打开,或为写而创建</td>
<td align="center">O_WRONLY|O_CREAT|O_APPEND</td>
</tr>
</tbody></table>
<p>调用fclose关闭一个流:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0,否则返回EOF</span></span><br></pre></td></tr></table></figure>

<h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>打开流后,可以使用三种不同类型的非格式化I/O对其进行读写操作.</p>
<p>(1)每次一个字符的I/O</p>
<p>(2)每次一行的I/O</p>
<p>(3)直接I/O.fread和fwrite函数支持这种类型I/O.常用于从二进制文件中每次读写一个结构.</p>
<h3 id="输入函数-一次一个字符"><a href="#输入函数-一次一个字符" class="headerlink" title="输入函数(一次一个字符)"></a>输入函数(一次一个字符)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//若成功返回下一个字符,若已到达文件末尾或出错,返回EOF</span></span><br></pre></td></tr></table></figure>

<p>函数getchar等于getc(stdin)(标准输入).前两个函数的区别是,getc可被实现为宏,而fgetc不能.</p>
<p>这三个函数在返回下一个字符时,将其<code>unsigned char</code>转换为<code>int</code>.要求返回整型的原因是,这样就可以返回所以可能的字符再加上一个出错或者到达文件末尾的指示值. EOF通常是一个负值,一般是-1.</p>
<p>不管出错还是到达文件末尾,三个函数都是返回相同的值,这时候想要区分就需要调用下面的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">//函数返回非0,表示为真,否则为假</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleareer</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每个流在FILE对象中维护了两个标志:</p>
<ol>
<li>出错标志</li>
<li>文件结束标志</li>
</ol>
<p>调用cleareer可以清除这两个标志.</p>
<h3 id="输出函数-一次一个字符"><a href="#输出函数-一次一个字符" class="headerlink" title="输出函数(一次一个字符)"></a>输出函数(一次一个字符)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">//成功返回c,否则返回EOF</span></span><br></pre></td></tr></table></figure>

<p>puchar(c)等于putc(c,stdout).</p>
<h2 id="每次一行I-O"><a href="#每次一行I-O" class="headerlink" title="每次一行I/O"></a>每次一行I/O</h2><h3 id="输入一行"><a href="#输入一行" class="headerlink" title="输入一行"></a>输入一行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="comment">//成功返回buf,出错返回NULL</span></span><br></pre></td></tr></table></figure>

<p>gets从标准输入中读取,fgets从指定流中读取.fgets需要指定缓冲的长度n.此函数一直到下一个换行符为止,但不超过n-1个字符,读入的字符被送入缓冲区.缓冲区总是以null字节结尾.对于超过n-1个字符的行,fgets只返回一个不完整的行,下次调用会继续处理这一行.</p>
<p>gets不能指定缓冲区长度,不推荐使用.gets和fgets的一个区别是,gets并不将换行符存入缓冲区中.</p>
<h3 id="输出一行"><a href="#输出一行" class="headerlink" title="输出一行"></a>输出一行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">//成功返回非负值,否则返回EOF</span></span><br></pre></td></tr></table></figure>

<p>函数fputs将一个以null字节作为结尾的字符串写到指定的流,尾端的null不写出.fputs不一定是一次输出一行,因为字符串不必最后一个非null字符为换行符.</p>
<h2 id="输入输出举例"><a href="#输入输出举例" class="headerlink" title="输入输出举例"></a>输入输出举例</h2><h3 id="按字节输入输出"><a href="#按字节输入输出" class="headerlink" title="按字节输入输出"></a>按字节输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=fgetc(<span class="built_in">stdin</span>))!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(fputc(c,<span class="built_in">stdout</span>)==EOF)</span><br><span class="line">        &#123;</span><br><span class="line">            err_sys(<span class="string">"output error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ferror(<span class="built_in">stdin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"input error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"count=%d\n"</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由count可以看出,标准输入输出行缓冲的时候会根据换行符作为终止,同时会将换行符传入流中.</p>
<h3 id="按行输入输出"><a href="#按行输入输出" class="headerlink" title="按行输入输出"></a>按行输入输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,MAXLINE,<span class="built_in">stdin</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"strlen = %d\n"</span>,num);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fputs</span>(buf,<span class="built_in">stdout</span>)==EOF)</span><br><span class="line">        &#123;</span><br><span class="line">            err_sys(<span class="string">"output error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ferror(<span class="built_in">stdin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"input error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于strlen不计算字符串末尾的空字符,因此通过count我们也能发现按行读取时,换行符会被读到标准输入,这是我们如果将末尾的换行符替换成空字符,输出就不是按行了.</p>
<h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>二进制I/O主要用于一次读写一个结构.下面两个函数提供了二进制I/O操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr,<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *restarict fp);</span><br><span class="line"><span class="comment">//函数返回值为读写对象的数量.</span></span><br></pre></td></tr></table></figure>

<p>这两个函数有以下两种常见用法.</p>
<p>(1)读或写一个二进制数组.如将一个浮点数组的第2-5个元素写到一个文件.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">if</span>(fwrite(&amp;data[<span class="number">1</span>],<span class="keyword">sizeof</span>(<span class="keyword">float</span>),<span class="number">4</span>,fp)!=<span class="number">4</span>)</span><br><span class="line">    err_sys(<span class="string">"fwrite error\n"</span>);</span><br></pre></td></tr></table></figure>

<p>(2)读或写一个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> count;</span><br><span class="line">    <span class="keyword">long</span> total;</span><br><span class="line">    <span class="keyword">char</span> name[NAMESIZE];</span><br><span class="line">&#125; item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fwrite(&amp;item,<span class="keyword">sizeof</span>(item),<span class="number">1</span>,fp)!=<span class="number">1</span>)</span><br><span class="line">    err_sys(<span class="string">"fwrite error\n"</span>);</span><br></pre></td></tr></table></figure>

<p>例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_SIZE 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">char</span> name[NAME_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bio self;</span><br><span class="line">    FILE *fp = fopen(argv[<span class="number">1</span>], <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">"chst"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(name);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        self.name[i] = name[i];</span><br><span class="line">    &#125;</span><br><span class="line">    self.name[<span class="built_in">strlen</span>(name)] = <span class="number">0</span>;</span><br><span class="line">    self.score = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">if</span>(fwrite(&amp;self,<span class="keyword">sizeof</span>(bio),<span class="number">1</span>,fp)!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"fwrite error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    FILE *fd = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    bio self2;</span><br><span class="line">    <span class="keyword">if</span>(fread(&amp;self2,<span class="keyword">sizeof</span>(bio), <span class="number">1</span>, fp)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name:%s,score=%d\n"</span>,self2.name, self2.score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"fread error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="格式化I-O"><a href="#格式化I-O" class="headerlink" title="格式化I/O"></a>格式化I/O</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="comment">//若成功,返回输出字符数,若失败,返回负值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="comment">//若成功,返回存入数组的字符数,若编码错误,返回负值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf,<span class="keyword">size_t</span> n,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="comment">//若缓冲区足够大,返回将要存入数组的字符数,若编码错误,返回负值.</span></span><br></pre></td></tr></table></figure>

<p>sprintf将格式化的字符输出到数组buf中,会在数组的尾端加上一个null.sprintf函数可能导致缓冲区buf溢出.为了解决缓冲区溢出问题,引入了snprintf函数,在该函数中,缓冲区是一个显式参数,超过缓冲区长度的部分会被丢弃,与sprintf相同,返回值不包括结尾的null字节.</p>
<p>格式说明控制其余参数如何编写,以后又该如何显示.每个参数按照转换说明编写,转换说明以百分号%开始,除转换说明外,格式字符串的其他字符将按原样,不经任何修改被复制输出.一个转换说明有4个可选部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][fldwidth][precision][lenmodifier]convtype</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>＇</code></td>
<td align="center">(撇号)将整数按照千位分组字符</td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td align="center">在字段内左对齐输出</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center">总是显示带符号转换的正负号</td>
</tr>
<tr>
<td align="center">(空格)</td>
<td align="center">如果第一个字符不是正负号，则在其前面加一个空格</td>
</tr>
<tr>
<td align="center"><code>#</code></td>
<td align="center">指定另一中转换形式（例如，对于十六进制格式，加０ｘ前缀）</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">添加前导０进行填充</td>
</tr>
</tbody></table>
<p>fldwidth说明最小字段宽度.转换后参数若小于宽度,则多余字符使用空格填充.宽度是一个非负十进制数或<code>*</code>.</p>
<p>precision说明整型转换后最少输出数字位数,浮点数转换后小数点后的最少位数,字符串转换后最大字节数.精度是一个<code>.</code>,其后更随一个可选的非负十进制数或一个<code>*</code>.</p>
<p>lenmodifier说明参数长度:</p>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>hh</code></td>
<td>将相应参数按照signed或者unsigned char类型输出</td>
</tr>
<tr>
<td><code>h</code></td>
<td>将相应参数按照signed或者unsigned short类型输出</td>
</tr>
<tr>
<td><code>l</code></td>
<td>将相应参数按照signed或者unsigned long类型输出</td>
</tr>
<tr>
<td><code>ll</code></td>
<td>将相应参数按照signed或者unsigned long long类型输出</td>
</tr>
<tr>
<td><code>j</code></td>
<td>intmax_t或uintmax_t</td>
</tr>
<tr>
<td><code>z</code></td>
<td>size_t</td>
</tr>
<tr>
<td><code>t</code></td>
<td>ptrdiff_t</td>
</tr>
<tr>
<td><code>L</code></td>
<td>long double</td>
</tr>
</tbody></table>
<p>convtype不是可选的,它控制如何解释参数.</p>
<table>
<thead>
<tr>
<th>转换类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>d</code>/<code>i</code></td>
<td>有符号十进制</td>
</tr>
<tr>
<td><code>o</code></td>
<td>无符号八进制</td>
</tr>
<tr>
<td><code>u</code></td>
<td>无符号十进制</td>
</tr>
<tr>
<td><code>x</code>/<code>X</code></td>
<td>无符号十六进制</td>
</tr>
<tr>
<td><code>f</code>/<code>F</code></td>
<td>双精度浮点数</td>
</tr>
<tr>
<td><code>e</code>/<code>E</code></td>
<td>指数格式双精度浮点数</td>
</tr>
<tr>
<td><code>g</code>/<code>G</code></td>
<td>根据转换后的值解释为<code>f</code>/<code>F</code>/<code>e</code>/<code>E</code></td>
</tr>
<tr>
<td><code>a</code>/<code>A</code></td>
<td>十六进制指数格式双精度浮点数</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符(若带长度修饰符1,为宽字符)</td>
</tr>
<tr>
<td><code>s</code></td>
<td>字符串(若带长度修饰符1,为宽字符)</td>
</tr>
<tr>
<td><code>p</code></td>
<td>指向void的指针</td>
</tr>
<tr>
<td><code>n</code></td>
<td>到目前为止,次printf调用输出的子符的数目将被写到指针说指向的带符号整型中</td>
</tr>
<tr>
<td><code>%</code></td>
<td>一个%字符</td>
</tr>
<tr>
<td><code>C</code></td>
<td>宽字符,等价于1c</td>
</tr>
<tr>
<td><code>S</code></td>
<td>宽字符串,等价于1s</td>
</tr>
</tbody></table>
<h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,...)</span></span>;</span><br><span class="line"><span class="comment">//赋值的输入项数,若错误或者在任一转换前已经到达文件末尾则返回EOF</span></span><br></pre></td></tr></table></figure>

<p>scanf族用于分析输入字符串,并将字符序列转换为指定类型变量.在格式之后包含了变量的地址(因此使用&amp;a),用转换结果对这些变量赋值.</p>
<p>格式说明控制如何转换参数,以便对他们赋值.转换说明以%开始.除转换说明和空格外,格式字符中的其他字符必须与输入一致.若存在一个字符不匹配,则停止后续处理.</p>
<p>一个转换说明有三个可选部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[*][fldwidth][m][lenmodifier]convtype</span><br></pre></td></tr></table></figure>

<p>可选的(*)是抑制转换,按照转换说明的其余部分对输入进行转换,但转换后的结果并不放到结果参数中.</p>
<p>可选项m是赋值分配符.可以用于<code>%C</code>,<code>%S</code>以及<code>%[</code>转换符,迫使内存缓冲区分配空间以接纳字符串.此时,相关参数必须是指针地址,分配的缓冲区地址必须赋值给该指针.如果调用成功,该缓冲区域不再使用时,由用户负责调用free来释放该缓冲区.</p>
<table>
<thead>
<tr>
<th>转换类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>d</code></td>
<td>符号十进制</td>
</tr>
<tr>
<td><code>i</code></td>
<td>有符号十进制</td>
</tr>
<tr>
<td><code>O</code></td>
<td>无符号八进制</td>
</tr>
<tr>
<td><code>u</code></td>
<td>无符号十进制</td>
</tr>
<tr>
<td><code>x</code>/<code>X</code></td>
<td>无符号十六进制</td>
</tr>
<tr>
<td><code>a</code>/<code>A</code>/<code>e</code>/<code>E</code>/<code>f</code>/<code>F</code>/<code>g</code>/<code>G</code></td>
<td>浮点数</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符(若带长度修饰符1,为宽字符)</td>
</tr>
<tr>
<td><code>s</code></td>
<td>字符串(若带长度修饰符1,为宽字符)</td>
</tr>
<tr>
<td><code>[</code></td>
<td>匹配列出的字符序列,以]终止</td>
</tr>
<tr>
<td><code>[^</code></td>
<td>匹配除列出了来的字符以外的所有字符,以]终止</td>
</tr>
<tr>
<td><code>p</code></td>
<td>指向void的指针</td>
</tr>
<tr>
<td><code>n</code></td>
<td>将到目前为止该函数调用读取的字符数写入到指针所指向的无符号整型中</td>
</tr>
<tr>
<td><code>%</code></td>
<td>一个%符号</td>
</tr>
<tr>
<td><code>C</code></td>
<td>宽字符,等效与1c</td>
</tr>
<tr>
<td><code>S</code></td>
<td>宽字符,等效于ls</td>
</tr>
</tbody></table>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>每个标准I/O流都有一个与其相关的文件描述符,可以对一个流调用fileno函数来获得其描述符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int fileno(FILE *fp);</span><br></pre></td></tr></table></figure>

<h1 id="第六章-系统数据文件和信息"><a href="#第六章-系统数据文件和信息" class="headerlink" title="第六章 系统数据文件和信息"></a>第六章 系统数据文件和信息</h1><h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNIX系统口令文件包含了下列的个字段(linux不包含最后三个字段),这些字段包含在&lt;pwd.h&gt;中定义的passwd结构中.</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">struct passwd成员</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用户名</td>
<td align="left">char *pw_name</td>
</tr>
<tr>
<td align="left">加密口令</td>
<td align="left">char *pw_passwd</td>
</tr>
<tr>
<td align="left">数值用户ID</td>
<td align="left">uid_t pw_uid</td>
</tr>
<tr>
<td align="left">数值组ID</td>
<td align="left">gid_t pw_gid</td>
</tr>
<tr>
<td align="left">注释字段</td>
<td align="left">char *pw_gecos</td>
</tr>
<tr>
<td align="left">初始工作目录</td>
<td align="left">char *pw_dir</td>
</tr>
<tr>
<td align="left">初始shell(用户程序)</td>
<td align="left">char *pw_shell</td>
</tr>
<tr>
<td align="left">用户访问类</td>
<td align="left">char *pw_class</td>
</tr>
<tr>
<td align="left">下次更改口令时间</td>
<td align="left">time_t pw_change</td>
</tr>
<tr>
<td align="left">账户有效期时间</td>
<td align="left">time_t pw_expire</td>
</tr>
</tbody></table>
<p>口令文件是<code>/ect/passwd</code>.每一行包含上述各字段,字段之间用冒号分隔.</p>
<p>关于登录项,需要注意:</p>
<ol>
<li>通常有一个用户名为root的登录项,其用户ID是0(超级用户).</li>
<li>加密口令字段包含了一个占位符.</li>
<li>shell字段包含了一个可执行程序名,它被用来作为该用户的登录shell.若为空,使用系统默认值,一般是/bin/shell.</li>
<li>为了阻止一个特定用户登录系统.可以在初始shell中使用/dev/null或者/bin/false或在/bin/true禁止一个账户.</li>
<li>使用nobody用户名的一个目的是,使任何人都能够登录至系统,但其用户ID(65534)和用户组ID(65534)不提供任何权限,只可以访问人人都可以读写的文件.</li>
</ol>
<p>下面的两个函数可以获得口令文件项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;pwd.h&gt;</span><br><span class="line">struct passwd *getpwuid(uid_t uid);</span><br><span class="line">struct passwd *getpwnam(const char *name);</span><br></pre></td></tr></table></figure>

<p>getpwuid函数由ls程序使用,它将<code>i</code>节点中的数字用户ID映射为用户登录名.在键入登录名时,getpwnam函数由login程序调用.passwd结构通常是函数内部的静态变量,只要调用任一相关函数,其内容就会被重写.</p>
<p>当程序想要查看整个口令文件时,可以使用下列3个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//若成功,返回指针,若错误或者到达文件末尾返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>每次调用getpwend时,其返回口令文件的下一个记录项.setpwent用来将getpwent()的读写地址指向口令文件的开头,endpwent则关闭这些文件.在使用getpwent后一定要使用endpwent关闭这些文件.</p>
<p>getpwnam的一个实现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function">passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    passwd *ptr;</span><br><span class="line">    setpwent(); <span class="comment">//确保文件以及被关闭</span></span><br><span class="line">    <span class="keyword">while</span>((ptr=getpwent())!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,ptr-&gt;pw_name)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endpwent();</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    passwd *ptr = getpwnam(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name:%-10s; passwd:%-10s; uid:%5d, gid=%-5d; gecos=%-20s; dir=%-10s; shell=%-10s\n"</span>,ptr-&gt;pw_name</span><br><span class="line">        ,ptr-&gt;pw_passwd,ptr-&gt;pw_uid,ptr-&gt;pw_gid,ptr-&gt;pw_gecos,ptr-&gt;pw_dir,ptr-&gt;pw_shell);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阴影口令"><a href="#阴影口令" class="headerlink" title="阴影口令"></a>阴影口令</h2><p>加密口令是经过单向加密算法处理过的用户副本.因为此算法是单向的,所以不能从加密口令猜测到原来的口令.</p>
<p>为了使一般用户无法获得加密口令,系统将加密口令放在另一个通常称为阴影口令的文件中,该文件至少要包含用户名与加密口令.与该口令有关的信息也可以放在该文件中:</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>struct spwd成员</th>
</tr>
</thead>
<tbody><tr>
<td>用户登录名</td>
<td>char *sp_name</td>
</tr>
<tr>
<td>加密口令</td>
<td>char *sp_pwdp</td>
</tr>
<tr>
<td>上次更改口令以来经过时间</td>
<td>int sp_lstchg</td>
</tr>
<tr>
<td>经多少天后允许更改</td>
<td>int sp_min</td>
</tr>
<tr>
<td>要求更改剩余天数</td>
<td>int sp_max</td>
</tr>
<tr>
<td>超期警告天数</td>
<td>int sp_warn</td>
</tr>
<tr>
<td>账户不活动之前剩余天数</td>
<td>int sp_inact</td>
</tr>
<tr>
<td>账户超期天数</td>
<td>int sp_expire</td>
</tr>
<tr>
<td>保留</td>
<td>unsigned int sp_flag</td>
</tr>
</tbody></table>
<p>阴影口令文件不是一般用户可以读取的.仅少数几个程序需要访问加密口令,如login和passwd,这些用户常常设置用户ID为root.与访问口令文件相似,存在访问阴影口令文件的一组函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="function">struct spwd *<span class="title">getspnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct spwq *<span class="title">getspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//成功返回指针,失败返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endspent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><p>UNIX组文件包含了下面所列字段,这些字段包含在&lt;grp.h&gt;中所定义的group中:</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>struct group成员</th>
</tr>
</thead>
<tbody><tr>
<td>组名</td>
<td>char *gr_name</td>
</tr>
<tr>
<td>加密口令</td>
<td>char *gr_passwd</td>
</tr>
<tr>
<td>数值组ID</td>
<td>int gr_gid</td>
</tr>
<tr>
<td>指向个用户名指针的数值</td>
<td>char **gr_mem</td>
</tr>
</tbody></table>
<p>下列两个函数可以查看组名或组ID:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="function">struct group *<span class="title">getgrnma</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与口令文件类似,这里的group也是静态变量的指针.</p>
<p>如果需要搜索整个组文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;grp.h&gt;</span><br><span class="line">struct group *getgrent(void);</span><br><span class="line">void setgrent(void);</span><br><span class="line">void endgrent(void);</span><br></pre></td></tr></table></figure>

<h2 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h2><p>我们不仅可以属于口令文件记录项中的组ID所对应的组,也可以属于多至16个另外的组.文件访问权限被修改为:不仅将进程有效ID与文件的组ID进行比较,而且也将所以附属组ID与文件的组ID进行比较.使用附属组ID的一个好处是不用经常更改组.</p>
<p>为了获取和设置附属组ID,提供了下面三个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> gidsetsize,<span class="keyword">gid_t</span> grouplist[])</span></span>;</span><br><span class="line"><span class="comment">//成功返回附属组ID数量,出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;grp.h&gt; //on linux</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt; //on freebsd, mac os x, solaris</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">int</span> ngroups,<span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;grp.h&gt; //on linux</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt; //on freebsd, mac os x, solaris</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username,<span class="keyword">gid_t</span> basegid)</span></span>;</span><br><span class="line"><span class="comment">//两个函数成功返回0,失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>getgroup将进程所属用户的各附属组ID填写到数组grouplist中,填入该数组的附属组ID最多gidsetsize个,实际填写的数量由函数返回.</p>
<p>setgroups可由超级用户调用以便为调用进程设置附属组ID表,grouplist是组ID数组,ngroups说明数组中元素个数.</p>
<p>通常只有initgroups函数调用setgroups,initgroups读整个组文件,然后对username确定其组的成员关系,然后调用setgroups,以便为该用户初始化附属组ID表.</p>
<h2 id="其他数据文件"><a href="#其他数据文件" class="headerlink" title="其他数据文件"></a>其他数据文件</h2><p>一般情况下,对每个数据文件至少有三个函数:</p>
<p>(1) get函数:读下一条记录,如果需要还会打开该文件,一般返回静态存储类结构的指针.</p>
<p>(2) set函数:打开对应数据文件,然后反绕该文件.</p>
<p>(3) end函数:关闭相关数据文件.</p>
<p>另外,如果数据文件支持某种形式的键搜索,则也提供搜索具有指定键的记录的例程.</p>
<p>下面列出一些常用的数据文件</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>数据文件</th>
<th>头文件</th>
<th>结构</th>
<th>附加键搜索函数</th>
</tr>
</thead>
<tbody><tr>
<td>口令</td>
<td>/etc/passwd</td>
<td>&lt;pwd.h&gt;</td>
<td>passwd</td>
<td>getpwnam, getpwuid</td>
</tr>
<tr>
<td>组</td>
<td>/etc/group</td>
<td>&lt;grp.h&gt;</td>
<td>group</td>
<td>getgrnam, getgrgid</td>
</tr>
<tr>
<td>阴影</td>
<td>/etc/shadow</td>
<td>&lt;shadow.h&gt;</td>
<td>spwd</td>
<td>getspnam</td>
</tr>
<tr>
<td>主机</td>
<td>/etc/hosts</td>
<td>&lt;netdb.h&gt;</td>
<td>hostent</td>
<td>getnameinfo, getaddrinfo</td>
</tr>
<tr>
<td>网络</td>
<td>/etc/networks</td>
<td>&lt;netdb.h&gt;</td>
<td>netent</td>
<td>getnetbyname, getnetbyaddr</td>
</tr>
<tr>
<td>协议</td>
<td>/etc/protocols</td>
<td>&lt;netdb.h&gt;</td>
<td>protoent</td>
<td>Getprotobyname, getprotobynumber</td>
</tr>
<tr>
<td>服务</td>
<td>/etc/services</td>
<td>&lt;netdb.h&gt;</td>
<td>servent</td>
<td>getservbyname, getservbyport</td>
</tr>
</tbody></table>
<h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>UNIX下提供了两个数据文件:utmp文件记录当前登录到系统的各个用户;wtmp文件跟踪各个登录和注销事件.每次写入的是包含下列结构的一个二进制记录:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmp</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ut_line[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">char</span> ut_name[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">long</span> ut_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>登录时,login程序填写此类型数据结构,然后将其写入到utml文件,同时也添加到wtmp文件.注销时,init进程将utmp文件中相应记录删除,并将一个新记录添加到wtmp文件中.</p>
<h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(struct utsname *name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>uname函数返回与主机和操作系统相关的信息.该函数向其中传递一个utsname地址,该函数会填充结构内容.结构包含如下信息:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> sysname[];</span><br><span class="line">    <span class="keyword">char</span> nodename[];</span><br><span class="line">    <span class="keyword">char</span> release[];</span><br><span class="line">    <span class="keyword">char</span> version[];</span><br><span class="line">    <span class="keyword">char</span> matchine[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>获取主机名:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int gethostname(char *name,int namelen);</span><br></pre></td></tr></table></figure>

<p>该名字通常就是TCP/IP网络上主机的名字.</p>
<h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>UNIX内核提供的基本时间服务是计算自协调世界时(UTC)公元1970年1月1号00:00:00这一特定时间以来经过的秒数.这种秒数是以数据类型time_t表示的(第三章),我们称之为日历时间.日历时间包含时间和日期.UNIX特点是:(1)以协调统一时间而非本地时间计时;(2)可自动进行转换;(3)将时间和日期作为一个量值保存.</p>
<p>time函数返回当前时间和日期:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *calptr);</span><br></pre></td></tr></table></figure>

<p>POSXI.1的实时扩展增加了对多个系统时钟的支持.时钟通过clockid_t类型进行标识.</p>
<table>
<thead>
<tr>
<th>标识符</th>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CLOCK_REALTIME</td>
<td></td>
<td>实时系统时间</td>
</tr>
<tr>
<td>CLOCK_MONTONIC</td>
<td>_POSIX_MONOTONIC_CLOCK</td>
<td>不带负跳数的实时系统时间</td>
</tr>
<tr>
<td>CLOCK_PROCESS_CPUTIME_ID</td>
<td>_POSIX_CPUTIME</td>
<td>调用进程的CPU时间</td>
</tr>
<tr>
<td>CLOCK_THREAD_CPUTIME_ID</td>
<td>_POSIX_THREAD_CPUTIME</td>
<td>调用线程的CPU时间</td>
</tr>
</tbody></table>
<p>clock_gettime函数可用来获取指定时钟时间,返回timespec结构(第四章),其把时间表示为秒和纳秒:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clock_id,struct timespec *tsp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当时钟ID设置为CLOCK_REALTIME时,clock_gettime函数提供了与time函数类似的功能,不过clock_gettime可能比time函数的精度高.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_getres</span><span class="params">(<span class="keyword">clockid_t</span> clock_id,struct timespec *tsp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>clock_getres函数将tsp指向的timespec结构初始化为与clock_id对应的时钟精度.</p>
<p>如果需要对特定的时钟设置时间,可以调用clock_settime函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_settime</span><span class="params">(<span class="keyword">clockid_t</span> clock_id, <span class="keyword">const</span> struct timespec *tsp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下图展示了各种时间函数之间的关系:</p>
<p><img src="https://s2.ax1x.com/2019/09/22/u9LVq1.png" alt="time"></p>
<p>图中虚线表示的三个函数localtime,mktime和strftime都受到环境变量TZ的影响.两个函数localtime和gmtime将日历时间转换成分解的时间,并将这些存放在一个tm结构中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tm_sec; <span class="comment">//秒:[0,60]</span></span><br><span class="line">    <span class="keyword">int</span> tm_min;<span class="comment">//分钟:[0,59]</span></span><br><span class="line">    <span class="keyword">int</span> tm_hour;<span class="comment">//小时:[0,23]</span></span><br><span class="line">    <span class="keyword">int</span> tm_mday;<span class="comment">//一个月的某一天:[1,31]</span></span><br><span class="line">    <span class="keyword">int</span> tm_mon;<span class="comment">//月:[0-11]</span></span><br><span class="line">    <span class="keyword">int</span> tm_year;<span class="comment">//年,从1970年开始到现在</span></span><br><span class="line">    <span class="keyword">int</span> tw_wday;<span class="comment">//一周的某一天[0,6]</span></span><br><span class="line">    <span class="keyword">int</span> tw_yday;<span class="comment">//一年的某一天[0,365]</span></span><br><span class="line">    <span class="keyword">int</span> tm_isdst;<span class="comment">//夏令时标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从日历时间获得分解时间:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude<span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function">struct tm *<span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *calptr)</span></span>;</span><br><span class="line"><span class="function">struct tm *<span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *calptr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回指针,出错返回NULL</span></span><br></pre></td></tr></table></figure>

<p>localtime和gmtime的区别是,localtime将日历转为本地时间,而gmtime将日历时间转换为协调统一时间.</p>
<p>从分解时间转换的日历时间:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">time_t</span> mktime(struct tm *tmptr);</span><br><span class="line"><span class="comment">//成功返回日历时间,出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>打印时间:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf,<span class="keyword">size_t</span> maxsize,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,<span class="keyword">const</span> struct tm *tmptr);</span><br><span class="line"><span class="keyword">size_t</span> strftime_l(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf,<span class="keyword">size_t</span> maxsize,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format,<span class="keyword">const</span> struct tm *<span class="keyword">restrict</span> tmptr,<span class="keyword">locale_t</span> local);</span><br><span class="line"><span class="comment">//若有空间则返回存入数组字符数,否则返回0</span></span><br></pre></td></tr></table></figure>

<p>strftime_l将区域指定为参数,除此之外两个函数完全一致.strftime使用环境变量TZ指定区域.</p>
<p>format参数控制了时间值的格式.形式是在一个百分号后更随一个特定字符,其他字符原样输出,不存在字段宽度修饰符.</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td><code>%a</code></td>
<td>缩写的周日名</td>
<td>Thu</td>
</tr>
<tr>
<td><code>%A</code></td>
<td>周日名</td>
<td>Thursday</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>缩写的月名</td>
<td>Jan</td>
</tr>
<tr>
<td><code>%B</code></td>
<td>月名</td>
<td>January</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>日期和时间</td>
<td>Thu Jan 19 21:24:52 2012</td>
</tr>
<tr>
<td><code>%C</code></td>
<td>年/100(00-99)</td>
<td>20</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>月日(01-31)</td>
<td>19</td>
</tr>
<tr>
<td><code>%D</code></td>
<td>日期(MM/DD/YY)</td>
<td>01/19/12</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>月日(一位数字前加空格)(1-31)</td>
<td>21</td>
</tr>
<tr>
<td><code>%F</code></td>
<td>ISO 8601日期格式(YYYY-MM-DD)</td>
<td>2012-01-09</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>ISO 8601基于周的年的最后两位数(00-99)</td>
<td>12</td>
</tr>
<tr>
<td><code>%G</code></td>
<td>ISO 8601基于周的年</td>
<td>2012</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>与<code>%b</code>相同</td>
<td>Jan</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>小时(24)(00-23)</td>
<td>21</td>
</tr>
<tr>
<td><code>%I</code></td>
<td>小时(12)(00-11)</td>
<td>09</td>
</tr>
<tr>
<td><code>%j</code></td>
<td>年日(001-366)</td>
<td>019</td>
</tr>
<tr>
<td><code>%m</code></td>
<td>月(01-12)</td>
<td>01</td>
</tr>
<tr>
<td><code>%M</code></td>
<td>分(01-59)</td>
<td>23</td>
</tr>
<tr>
<td><code>%n</code></td>
<td>换行符</td>
<td></td>
</tr>
<tr>
<td><code>%p</code></td>
<td>AM/PM</td>
<td>PM</td>
</tr>
<tr>
<td><code>%r</code></td>
<td>本地时间(12)</td>
<td>09:24:52 PM</td>
</tr>
<tr>
<td><code>%R</code></td>
<td>与<code>&quot;%H:%M&quot;</code>相同</td>
<td>21:24</td>
</tr>
<tr>
<td><code>%S</code></td>
<td>秒[00-60]</td>
<td>52</td>
</tr>
<tr>
<td><code>%t</code></td>
<td>水平制表符</td>
<td></td>
</tr>
<tr>
<td><code>%T</code></td>
<td>与<code>&quot;%H:%M:%S&quot;</code>相同`</td>
<td>21:24:52</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>ISO 8601周几(1-7)</td>
<td>4</td>
</tr>
<tr>
<td><code>%U</code></td>
<td>星期日周数(00-53)</td>
<td>03</td>
</tr>
<tr>
<td><code>%V</code></td>
<td>ISO 周数(01-53)</td>
<td>03</td>
</tr>
<tr>
<td><code>%w</code></td>
<td>周几(0-6)</td>
<td>03</td>
</tr>
<tr>
<td><code>%W</code></td>
<td>星期一周数(00-53)</td>
<td>03</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>本地日期</td>
<td>01/19/12</td>
</tr>
<tr>
<td><code>%X</code></td>
<td>本地时间</td>
<td>21:24:52</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>年的最后两位数(00-99)</td>
<td>12</td>
</tr>
<tr>
<td><code>%Y</code></td>
<td>年</td>
<td>2012</td>
</tr>
<tr>
<td><code>%z</code></td>
<td>ISO 8601格式的UTC偏移量</td>
<td>-0500</td>
</tr>
<tr>
<td><code>%Z</code></td>
<td>时区名</td>
<td>EST</td>
</tr>
<tr>
<td><code>%%</code></td>
<td>翻译为一个%</td>
<td>%</td>
</tr>
</tbody></table>
<p>打印时间例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">64</span>];</span><br><span class="line">    time(&amp;t);</span><br><span class="line">    tmp = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span>(strftime(buf1,<span class="number">16</span>,<span class="string">"time and date:%r, %a %b %d, %Y"</span>, tmp)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"buffer length 16 is too small\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(strftime(buf2,<span class="number">64</span>,<span class="string">"time and date:%r, %a %b %d, %Y"</span>, tmp)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"buffer length 64 is too small\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strptime函数是strftime的反过来的版本,把字符串时间转换为分解时间:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, struct tm *<span class="keyword">restrict</span> tmptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>格式说明符与上述类似.</p>
<h1 id="第七章-进程环境"><a href="#第七章-进程环境" class="headerlink" title="第七章 进程环境"></a>第七章 进程环境</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">int</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>内核执行C程序时(使用一个exec函数),在调用main前先调用一个特殊的启动例程.可执行程序文件将此启动例程指定为程序的起始地址.启动例程从内核获取环境变量值和命令行参数.</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>共有八种进程终止方式,其中五种正常终止:</p>
<p>(1)从main函数返回;</p>
<p>(2)调用<code>exit</code>;</p>
<p>(3)调用<code>_exit</code>或<code>_Exit</code></p>
<p>(4)最后一个线程从其启动例程返回;</p>
<p>(5)从最后一个线程调用<code>pthread_exit</code>;</p>
<p>三种异常终止:</p>
<p>(6)调用abort;</p>
<p>(7)接到一个信号;</p>
<p>(8)最后一个线程对取消请求做出响应.</p>
<p>启动例程一般是从main函数返回后立即调用exit函数,大概是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit(main(argc,argv));</span><br></pre></td></tr></table></figure>

<h3 id="1-退出函数"><a href="#1-退出函数" class="headerlink" title="1. 退出函数"></a>1. 退出函数</h3><p>3个函数用于正常终止一个程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br><span class="line">void _Exit(int status);</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>

<p>其中<code>_Exit</code>和<code>_exit</code>立即进入内核,<code>exit</code>则先执行一些清理,在返回内核.<code>exit</code>总是执行I/O库的清理关闭操作.</p>
<p>3个函数都带一个整型参数,称为终止状态.如果(a)调用这些函数时不带终止状态;(b)main执行了一个无返回的<code>return</code>语句;(c)main未申明返回类型为整型,则进程终止状态是未定义的.但若main返回类型为整型,并且main执行到最后一句返回(隐式返回也可以),那么进程终止状态是0.</p>
<p>main函数调用<code>exit(0)</code>与<code>return 0</code>是等价的.</p>
<p>打印终止状态(程序执行之后):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$echo $?</span><br></pre></td></tr></table></figure>

<h3 id="2-函数atexit"><a href="#2-函数atexit" class="headerlink" title="2. 函数atexit"></a>2. 函数atexit</h3><p>一个进程可以登录多至32个程序,这些函数将由<code>exit</code>自动调用,这些函数称为终止处理程序,并调用<code>atexit</code>函数来登记这些函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0,否则非0</span></span><br></pre></td></tr></table></figure>

<p>参数为函数地址,调用函数时无需传递任何参数,也不期待存在返回值.<code>exit</code>调用这些函数的顺序与他们登记的顺序相反,同一个函数如果登录多次也会被执行多次.下图展示了一个C程序如何启动:</p>
<p><img src="https://s2.ax1x.com/2019/09/22/u9Lma6.png" alt="c程序"></p>
<p><font color="red/">注意:内核使程序执行的唯一方法是调用一个<code>exec</code>函数.程序自愿终止的唯一方法是显示或隐式地(通过调用<code>exit</code>)调用<code>_exit</code>或<code>_Exit</code>.进程也可以非自愿的由一个信号使其终止.</font></p>
<p>例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(atexit(myexit2)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"can't register myexit2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(atexit(myexit1)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"can't register myexit1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(atexit(myexit1)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"can't register myexit1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main is done!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"first exit handler\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myexit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"second exit handler\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main is done!</span><br><span class="line">first exit handler</span><br><span class="line">first exit handler</span><br><span class="line">second exit handler</span><br><span class="line"></span><br><span class="line">//myexit1和myexit2均是在函数返回时调用exit时才执行,执行顺序与添加顺序相反,加入多次会执行多次.</span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时,调用<code>exec</code>的进程可以将命令行参数传递给该新进程.</p>
<h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收一张环境表.环境表也是一字符指针数组,其中每个指针包含一个以null为结尾的字符串的地址.全局变量environ包含了该指针数组的地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern char **environ;</span><br></pre></td></tr></table></figure>

<p>environ为环境指针,指针数组为环境表,其中各个指针指向的字符串为环境字符串.环境由<code>name=value</code>这样的字符组成,如下图:</p>
<p><img src="https://s2.ax1x.com/2019/09/22/u9LAM9.png" alt="环境表"></p>
<h2 id="C程序存储空间分布"><a href="#C程序存储空间分布" class="headerlink" title="C程序存储空间分布"></a>C程序存储空间分布</h2><p>C程序由下列几部分组成:</p>
<ol>
<li>正文段.由CPU执行的机器指令.通常正文段是可共享的,在存储器中只需要一个副本,同时正文段是只读的,防止程序由于意外而修改其指令.</li>
<li>初始化数据段.通常称为数据段,包含了程序中明确地赋初值的变量,如C程序任意函数外申明<code>int maxcount = 99;</code>.</li>
<li>未初始化数据段,通常称为bss,在程序开始执行前,内核将此段中的数据初始化为0或空指针.如函数外的申明:<code>long sum[1000]</code>.</li>
<li>栈.自动变量以及每次函数调用时保存的信息都存放在次段中.每次函数调用时,其返回地址以及调用者环境信息都放在栈中.最近被调用的函数在栈上为其自动变量和临时变量分配存储空间.递归函数调用自身时,就会使用一个新的栈帧,因此一次函数调用实例中的变量集不会影响另一次函数调用实例中的变量.</li>
<li>堆.通常在堆中进行动态内存分配.</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/09/22/u9LErR.png" alt="存储空间分配"></p>
<p>未初始化数据段的内容并不会存放在磁盘程序文件(可执行文件).内核在运行程序前将他们置0.需要存放在磁盘文件的只有正文段和初始化数据段.</p>
<p>size目录报告正文段,数据段和bss段的长度(字节),如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ size ./atexit.o</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   4911     688      48    5647    160f ./atexit.o</span><br></pre></td></tr></table></figure>

<p>第4列和第5列分别是以十进制和十六进制表示的三个文件总长度.</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得可执行文件中不在需要包含公用的库函数,而只需在所有进程都可引用的存储区中保存这种库例程的副本.程序第一次执行或者第一次调用某个库函数时,用动态链接方法将程序与共享库函数相连接.这减少了每个可执行文件的长度,但增加了一些运行的开销,这种开销发生在第一次执行程序或第一次调用库函数.共享库的另一个优点是可以用库函数的新版本代替老版本而不用对使用该库的程序重新连接编辑.</p>
<p>例:</p>
<p>使用共享库进行编译:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ atexit.cpp -o atexit.o</span><br><span class="line">$ ls -l atexit.o</span><br><span class="line">-rwxrwxr-x 1 chst chst 13384 Sep 24 00:17 atexit.o</span><br><span class="line">$ size atexit.o</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   4911     688      48    5647    160f atexit.o</span><br></pre></td></tr></table></figure>

<p>无共享库进行编译:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -static atexit.cpp -o atexit.o //阻止使用共享库-static</span><br><span class="line">$ ls -l atexit.o</span><br><span class="line">-rwxrwxr-x 1 chst chst 849744 Sep 24 00:19 atexit.o</span><br><span class="line">$ size atexit.o</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line"> 746297   21068    5984  773349   bcce5 atexit.o</span><br></pre></td></tr></table></figure>

<p>可以明显看出,使用共享减少了大量空间.</p>
<h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了三种用于存储空间分配的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> newsize)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回非空指针,否则返回NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>malloc</code>分配指定字节的存储区域,初始值不定.<code>calloc</code>为指定数量指定长度的对象分配存储空间,该空间的每一位(bit)都是0.<code>realloc</code>增加或减少以前分配器的长度,参数是newsize是改变后的长度而不是改变的长度.如果是增大空间,可能需要将以前分配的内容移到另一个更大的区域,以便在尾部提供增加的区域,新区域的初始值不定.</p>
<p><code>free</code>释放ptr指向的存储空间.</p>
<p>大多数实现所分配的存储空间都比所要求的稍微打一写,额外的开销用来记录管理信息–分配块的长度,指向下一个个块的指针等.这意味着,如果超过一个已分配的尾端或者在已分配区起始位置之前进行写操作,则会改写另一块的管理信息,这种错误是灾难性的,但不会很快暴露出来,所以很难发现.</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境字符串形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value</span><br></pre></td></tr></table></figure>

<p>ISO C提供一个函数getenv来获取环境变量值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">//返回指向name关联的value指针，如果未找到，返回NULL；</span></span><br></pre></td></tr></table></figure>

<p>下面列出了环境变量内容：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>COLUMNS</td>
<td>终端宽度</td>
</tr>
<tr>
<td>DATEMSK</td>
<td>getdate模板文件路径名</td>
</tr>
<tr>
<td>HOME</td>
<td>home起始目录</td>
</tr>
<tr>
<td>LANG</td>
<td>本地名</td>
</tr>
<tr>
<td>LC_ALL</td>
<td>本地名</td>
</tr>
<tr>
<td>LC_COLLATE</td>
<td>本地排序名</td>
</tr>
<tr>
<td>LC_CTYPE</td>
<td>本地字符分类名</td>
</tr>
<tr>
<td>LC_MESSAGES</td>
<td>本地消息名</td>
</tr>
<tr>
<td>LC_MONETART</td>
<td>本地货币编辑名</td>
</tr>
<tr>
<td>LC_NUMERIC</td>
<td>本地数字编辑名</td>
</tr>
<tr>
<td>LC_TIME</td>
<td>本地日期/时间格式名</td>
</tr>
<tr>
<td>LINES</td>
<td>终端高度</td>
</tr>
<tr>
<td>LOGNAME</td>
<td>登录名</td>
</tr>
<tr>
<td>MSGVERB</td>
<td>fmtmsg处理的消息组成部分</td>
</tr>
<tr>
<td>NLSPATH</td>
<td>消息类模板序列</td>
</tr>
<tr>
<td>PATH</td>
<td>搜索可执行文件的路径前缀列表</td>
</tr>
<tr>
<td>PWD</td>
<td>当前工作路径的绝对路径名</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户首选的shell名</td>
</tr>
<tr>
<td>TERM</td>
<td>终端类型</td>
</tr>
<tr>
<td>TMPDIR</td>
<td>在其中创建临时文件的目录路径名</td>
</tr>
<tr>
<td>TZ</td>
<td>时区信息</td>
</tr>
</tbody></table>
<p>有时，我们也需要设置环境变量或者增加新的环境变量（我们能够影响的只是当前进程及其后生成的和调用的任何子进程的环境，但不影响父进程的环境），此时我们可以使用下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int putenv(char *str);</span><br><span class="line">//成功返回0，否则非0</span><br><span class="line"></span><br><span class="line">int setenv(const char *name, const char *value, int rewrite);</span><br><span class="line">int unsetenv(const char *name);</span><br><span class="line">//成功返回0，否则-1</span><br></pre></td></tr></table></figure>

<p><code>putenv</code>取形式为<code>name=value</code>的字符串，将其放到环境表中，如果<code>name</code>已经存在则先删除。</p>
<p><code>setenv</code>将<code>name</code>设置为<code>value</code>，如果环境中<code>name</code>已经存在，那么是否重写取决于<code>rewrite</code>。</p>
<p><code>unsetenv</code>删除<code>name</code>的定义，即使不存在<code>name</code>的定义也不会出错。</p>
<p>修改环境表是如何操作的？</p>
<p>环境表和环境字符串通常占用的是进程地址空间的顶部（见C程序存储空间分布图），此时删除一个是十分简单的，但是增加或者修改一个是相对复杂的。这是因为它不能够再向高地址（向上）扩展，同时也不能移动在它下面的各栈帧，所以也不能向低地址（向下）扩展。</p>
<p>（1）如果修改一个现有的name：</p>
<ol>
<li>如果新的value长度不大于现在value长度，则只将新字符串复制到原字符串所在位置。</li>
<li>如果新的value长度大于原长度，则必须使用malloc为新字符串分配空间，然后将新字符串复制到该空间，接着使用环境表中针对name的指针指向新分配区。</li>
</ol>
<p>（2）新增加一个name，必须调用malloc为name=value字符串分配空间，而后将字符串复制到该空间。</p>
<ol>
<li>如果是第一次添加，则必须调用malloc为新的指针表分配空间。接着将原来的环境表分配到新分配区，并将name=value字符串的指针存放在该指针表的末尾，然后将一个空指针存放在其后。最后使environ指向新的指针表。此时，原来指针表位于栈顶之上，那么必须将次表移到堆中，但此时表中大多数指针仍指向栈顶的各name=value。</li>
<li>如果不是第一次增加，则只要调用realloc以分配比原空间多存放一个指针的空间，然后将指向新的name=value的指针放到末尾，后面接一个空指针。</li>
</ol>
<h2 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数setjmp和longjmp</h2><p>C语言中goto不能跨越函数，而执行此类跳转是函数setjmp和longjmp。这两个函数用于很深层嵌套函数调用中出错是十分有效的。</p>
<p>考察下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOK_ADD 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_line</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_add</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_token</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> line[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,MAXLINE,<span class="built_in">stdin</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        do_line(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *tok_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_line</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    tok_ptr = ptr;</span><br><span class="line">    <span class="keyword">while</span>((cmd=get_token())&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> TOK_ADD:</span><br><span class="line">            cmd_add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_add</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    token = get_token();</span><br><span class="line">    <span class="comment">// 接下来处理相对应的指令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_token</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从tok_ptr*中获取下一条指令;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的基本骨架在读命令，确定命令类型，然后调用响应函数处理每一条指令。下图展示了调用到cmd_add之后栈的大致使用情况：</p>
<p><img src="https://s2.ax1x.com/2019/09/22/u9LeVx.png" alt="栈使用情况"></p>
<p>自动变量存储在每个函数的栈帧中，数组line存储在main的栈帧中，cmd存储在do_line栈帧中，token在cmd_add栈帧中。</p>
<p>当发生一个非致命性错误时，例如，如果cmd_add函数发生一个错误，那么可能会先打印一个错误，然后忽略接下来的输入，返回main函数并读取下一行。如果出现在C函数的深层嵌套中，处理起来是十分麻烦的，我们不得不以检测返回值的形式逐层返回。</p>
<p>解决这种问题的一个方法是使用非局部goto–setjmp和longjmp函数。非局部是指，这不是普通的goto在一个函数中跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某个函数上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;setjmp.h&gt;</span><br><span class="line">int setjmp(jmp_buf env);</span><br><span class="line">//若直接调用返回0，若从longjmp返回，则为非0</span><br><span class="line"></span><br><span class="line">void longjmp(jmp_buf env,int val);</span><br></pre></td></tr></table></figure>

<p>在希望返回到的位置调用setjmp。参数env的类型是一个特殊的jmp_buf。因为需要在另一个函数中引用env变量，通常将其定义为全局变量。</p>
<p>当检测到错误使用两个参数调用longjmp函数，第一个是setjmp的env，第二个是一个非0val，它将成为setjmp的返回值，可以用来判断出错的位置和类型。</p>
<p>利用setjmp和longjmp对之前的程序进行更改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOK_ADD 5</span></span><br><span class="line"></span><br><span class="line">jmp_buf jmpbuff;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_line</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_add</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_token</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> line[MAXLINE];</span><br><span class="line">    <span class="keyword">if</span>(setjmp(jmpbuff)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,MAXLINE,<span class="built_in">stdin</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        do_line(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *tok_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_line</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    tok_ptr = ptr;</span><br><span class="line">    <span class="keyword">while</span>((cmd=get_token())&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> TOK_ADD:</span><br><span class="line">            cmd_add();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmd_add</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> token;</span><br><span class="line">    token = get_token();</span><br><span class="line">    <span class="keyword">if</span>(token&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(jmpbuff,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来处理相对应的指令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_token</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从tok_ptr*中获取下一条指令;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main函数时，调用setjmp，它将所需的信息记入变量jmpbuff中并返回0,。随后调用do_line，它又调用cmd_add，当出现错误时，调用longjmp后会丢弃cmd_add和do_line的栈帧，同时造成main函数中setjmp返回1。调用后的栈帧为：</p>
<p><img src="https://s2.ax1x.com/2019/09/22/u9LnIK.png" alt="longjmp"></p>
<h3 id="自动变量、寄存器变量和易失变量"><a href="#自动变量、寄存器变量和易失变量" class="headerlink" title="自动变量、寄存器变量和易失变量"></a>自动变量、寄存器变量和易失变量</h3><p>调用longjmp后栈帧如上所述，但此时main函数中自动变量、寄存器变量和易失变量的状态又该如何？是否能够恢复到以前调用setjmp时的状态（回滚），或者保持不变。回答是不确定的。大多数都不回滚，但所以实现都声称不确定。当有一个自动变量又不想让其回滚，可以定义为具有volatile属性。申明为全局变量或静态变量的值在执行完longjmp不回滚。</p>
<p>下面通过实例说明自动变量、全局变量、寄存器变量、静态变量和易失变量的不同情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jmp_buf jmpbuffer;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> autoval;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> regival;<span class="comment">//寄存器变量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> volaval;<span class="comment">//易失变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> statval;</span><br><span class="line">    globval =<span class="number">1</span>; autoval = <span class="number">2</span>; regival =<span class="number">3</span>;volaval=<span class="number">4</span>;statval=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(setjmp(jmpbuffer)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"after longjmp:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"global=%d, autoval=%d, regival=%d, volaval=%d, statval=%d\n"</span>, </span><br><span class="line">        globval, autoval,regival,volaval,statval);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    globval =<span class="number">95</span>; autoval = <span class="number">96</span>; regival =<span class="number">97</span>;volaval=<span class="number">98</span>;statval=<span class="number">99</span>;</span><br><span class="line">    f1(autoval,regival,volaval,statval);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"f1():\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global=%d, autoval=%d, regival=%d, volaval=%d, statval=%d\n"</span>, </span><br><span class="line">        globval, i,j,k,l);</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longjmp(jmpbuffer,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ jmpval.cpp -lapue</span><br><span class="line">$ ./a.out</span><br><span class="line">f1():</span><br><span class="line">global=95, autoval=96, regival=97, volaval=98, statval=99</span><br><span class="line">after longjmp:</span><br><span class="line">global=95, autoval=96, regival=3, volaval=98, statval=99</span><br></pre></td></tr></table></figure>

<h3 id="自动变量的潜在问题"><a href="#自动变量的潜在问题" class="headerlink" title="自动变量的潜在问题"></a>自动变量的潜在问题</h3><p>自动变量存在一个潜在出错情况，基本规则是申明自动变量的函数已经返回后，不能再引用这些自动变量。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">open_data</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> databuf[BUFSIZ];</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"datafile"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(setvbuf(fp, databuf,_IOLBF,BUFSIZ)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当open_data返回时，他在栈上使用的空间将由下一个被调用函数的栈帧使用。但标准I/O还将使用这部分存储空间作为缓冲区（databuf）。这就会产生冲突和混乱，为了解决这个问题，应该在全局存储空间静态地（如static或extern）或者动态的（malloc）为数组databuf分配空间。</p>
<h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每一个进程都存在一组资源限制，其中一些可以使用getrlimit和setrlimit函数来查询和更改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlimit</span><span class="params">(<span class="keyword">int</span> resure,struct rlimit *rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resurce,<span class="keyword">const</span> struct rlimit *rlptr)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0，否则返回非0</span></span><br></pre></td></tr></table></figure>

<p>进程的资源环境通常由0进程来建立，然后由后续进程继承。函数调用制定一个资源以及一个指向<code>rlimit</code>结构的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span>&#123;</span></span><br><span class="line">    <span class="keyword">rlimit_t</span> rlim_cur; <span class="comment">// soft limit:current limit</span></span><br><span class="line">    <span class="keyword">rlimit_t</span> rlim_max; <span class="comment">//hard limit:maximun value for rlim_cur </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更改资源限制时需要遵守下列三条限制：</p>
<ol>
<li>任何一个进程都可以将软限制调整到不大于硬限制。</li>
<li>任何一个进程都可以降低硬限制，但必须大于或等于软限制，这种降低对于普通用户而言是不可逆的。</li>
<li>只有超级进程可以提高硬限制值。</li>
</ol>
<p>常量<code>RLIM_INFINITY</code>指定了一个无限量的限制。</p>
<table>
<thead>
<tr>
<th>限制</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>RLIMIT_AS</code></td>
<td>进程可以使用的存储空间最大的长度（字节）。影响到sbrk和mmap函数。</td>
</tr>
<tr>
<td><code>RLIMIT_CORE</code></td>
<td>core文件的最大长度，0表示阻止生成core文件。</td>
</tr>
<tr>
<td><code>RLIMIT_CPU</code></td>
<td>CPU时间的最大秒数，当超过此限制时，向该进程发送SIGXCPU信号。</td>
</tr>
<tr>
<td><code>RLIMIT_DATA</code></td>
<td>数据段的最大字节长度，是初始化数据、非初始以及堆的总和。</td>
</tr>
<tr>
<td><code>RLIMMIT_FSIZE</code></td>
<td>可以创建的文件的最大长度，超过此限制将会向进程发送信号SIGFSZ信号。</td>
</tr>
<tr>
<td><code>RLIMIT_MEMLOCK</code></td>
<td>一个进程可以使用mlock能够锁定在存储空间的最大字节长度。</td>
</tr>
<tr>
<td><code>RLIMIT_MSGQUEUE</code></td>
<td>进程为POSIX消息队列可分配的最大存储字节数。</td>
</tr>
<tr>
<td><code>RLIMIT_NICE</code></td>
<td>为了影响进程的调度优先级，nice值能够设置的最大限制。</td>
</tr>
<tr>
<td><code>RLIMIT_NPTS</code></td>
<td>用户可以同时打开的伪终端的最大限制。</td>
</tr>
<tr>
<td><code>RLIMIT_NOFILE</code></td>
<td>每个进程可以打开的最多的文件数。</td>
</tr>
<tr>
<td><code>RLIMIT_NPROC</code></td>
<td>每个实际用户ID可拥有的最大子进程数量。</td>
</tr>
<tr>
<td><code>RLIMIT_RSS</code></td>
<td>最大驻内存集字节长度，如果可用的物理存储器非常少，则内核将从进程处取回超过RSS的部分。</td>
</tr>
<tr>
<td><code>PLIMIT_SBSIZE</code></td>
<td>在任一给定时刻，一个用户可以占用的套接字的缓冲区的最大长度（字节）（linux上不存在）</td>
</tr>
<tr>
<td><code>RLIMIT_SIGPENDING</code></td>
<td>一个进程可排队的信号的最大数量。</td>
</tr>
<tr>
<td><code>RLIMMIT_STACK</code></td>
<td>栈的最大字节数。</td>
</tr>
<tr>
<td><code>RLIMIT_SWAP</code></td>
<td>用户可消耗的交换空间最大字节数。</td>
</tr>
<tr>
<td><code>RLIMIT_VMEM</code></td>
<td>与<code>RLIMIT_AS</code>相同。</td>
</tr>
</tbody></table>
<p>获取限制代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> doit(name) pr_limits(#name,name)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr_limits</span><span class="params">(<span class="keyword">char</span> *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">    doit(RLIMIT_AS);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    doit(RLIMIT_CORE);</span><br><span class="line">    doit(RLIMIT_CPU);</span><br><span class="line">    doit(RLIMIT_DATA);</span><br><span class="line">    doit(RLIMIT_FSIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_MEMLOCK</span></span><br><span class="line">    doit(RLIMIT_MEMLOCK);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_MSGQUEUE</span></span><br><span class="line">    doit(RLIMIT_MSGQUEUE);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_NICE</span></span><br><span class="line">    doit(RLIMIT_NICE);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_NOFILE</span></span><br><span class="line">    doit(RLIMIT_NOFILE);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_NPROC</span></span><br><span class="line">    doit(RLIMIT_NPROC);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_NPTS</span></span><br><span class="line">    doit(RLIMIT_NPTS);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_RSS</span></span><br><span class="line">    doit(RLIMIT_RSS);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_SBSIZE</span></span><br><span class="line">    doit(RLIMIT_SBSIZE);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_SIGPENDING</span></span><br><span class="line">    doit(RLIMIT_SIGPENDING);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_STACK</span></span><br><span class="line">    doit(RLIMIT_STACK);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_SWAP</span></span><br><span class="line">    doit(RLIMIT_SWAP);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> RLMIT_VMEM</span></span><br><span class="line">    doit(RLMIT_VMEM);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr_limits</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">int</span> resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rlimit limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lim;</span><br><span class="line">    <span class="keyword">if</span>(getrlimit(resource,&amp;limit)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"getrlimit error for %s"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-14s "</span>,name);</span><br><span class="line">    <span class="keyword">if</span>(limit.rlim_cur == RLIM_INFINITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(infinite) "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lim = limit.rlim_cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%10lld "</span>,lim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(limit.rlim_max == RLIM_INFINITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(infinite) "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lim = limit.rlim_max;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%10lld "</span>,lim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>((<span class="keyword">int</span>)<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doit中使用了ISO C的字符串创建算符（#），以便为每个资源名产生字符串值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doit(RLIMIT_CORE);</span><br><span class="line"><span class="comment">//被C预处理为：</span></span><br><span class="line">pr_limits(<span class="string">"RLIMIT_CORE"</span>, RLIMIT_CORE);</span><br></pre></td></tr></table></figure>

<h1 id="第八章-进程控制"><a href="#第八章-进程控制" class="headerlink" title="第八章 进程控制"></a>第八章 进程控制</h1><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程存在一个非负整型表示的唯一进程ID。由于唯一性，常用来作为其他标识符的一部分以保证其唯一性。大多数UNIX实现延迟复用，使得新建进程的ID不同于最近终止进程所有的ID。</p>
<p>ID为0的进程通常是调度进程，常常被称为交换进程，该进程是内核的一部分并不执行磁盘上的任何程序。ID为1的进程通常是init进程，在自举过程结束时由内核调用。此进程负责在自举后启动一个UNIX系统。init进程绝对不会终止。</p>
<p>除了进程ID，进程还有其他标识：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#includ<span class="meta-string">&lt;unsid.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">// 函数调用进程的进程ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//调用进程的父进程ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getuid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//调用进程的实际用ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> geteuid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//调用进程的有效用户ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getgid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//调用进程的实际组ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getegid(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//调用进程的有效组ID</span></span><br></pre></td></tr></table></figure>

<h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有进程调用fork进程创建一个新进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//子进程返回0，父进程返回子进程的ID，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>子进程是父进程的副本，子进程获得父进程数据空间、堆和栈的副本。这是子进程拥有的副本，与父进程并不共享这些存储空间部分。父进程和子进程共享正文段。</p>
<p>由于fork后经常更随着exec，所以现在很多实现并不执行一个父进程的数据段、堆和栈的完全副本，而是采用写时复制的策略。即这些区域子进程与父进程共享，内核将其访问权限更改为只读，当子进程或者父进程要试图修改这些区域时，内核才对要修改的区域那块内存赋值一个副本，通常是虚拟存储系统中的一页。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="keyword">int</span> globvar = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">"a write to stdout\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    var = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">if</span>(write(STDOUT_FILENO,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)!=<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"write error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_sys(<span class="string">"fork error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            globvar++;</span><br><span class="line">            var++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PID = %ld, glob = %d, var = %d\n"</span>, (<span class="keyword">long</span>)getpid(), globvar, var);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用两种不同的运行方式，将会获得两种不同输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>./fork.o</span><br><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">PID = 14487, glob = 7, var = 89</span><br><span class="line">PID = 14486, glob = 6, var = 88</span><br><span class="line"><span class="meta">$</span> ./fork.o &gt; tem.txt</span><br><span class="line"><span class="meta">$</span> cat tem.txt</span><br><span class="line">a write to stdout</span><br><span class="line">before fork</span><br><span class="line">PID = 14491, glob = 7, var = 89</span><br><span class="line">before fork</span><br><span class="line">PID = 14489, glob = 6, var = 88</span><br></pre></td></tr></table></figure>

<p>fork之后是父进程先执行还是子进程先执行是不确定的。sizeof计算字符串包含的终止null，因此需要减一（strlen不包含）。对于strlen来说，每次执行就调用响应函数，而对于sizeof来说，因为缓冲区已用已知字符串进行初始化，其长度是固定的，因此sizeof是编译时计算缓冲区长度。</p>
<p>对于两种不同运行方式输出不同，这是由于：对于连接到终端的标准输出来说，缓冲方式为行缓冲，此时在调用fork之前，缓冲区已近被清空，此时调用fork，子进程缓冲区也是空的，因此只会输出一次（在父进程）。但是在非连接到终端的标准输出来说，采用的是全缓冲，此时在调用fork之前，父进程的缓冲区并未被清空（未输出），调用fork后，子进程获得父进程缓冲区的一份拷贝，最终两个进程输出时都会打印（“before fork”）。</p>
<p>父进程和子进程每个相同的打开的文件描述符共享一个文件表项：</p>
<p><img src="https://s2.ax1x.com/2019/10/01/uUgGX4.png" alt="文件描述符"></p>
<p><font color="red/">父进程和子进程共享同一个文件偏移量。</font></p>
<p>fork之后处理文件描述符有下列两种情况：</p>
<ol>
<li>父进程等待子进程完成。此时父进程无需对其文件描述符进行任何操作。子进程处理完成后，它进行过读写的共享描述符的偏移量以及做了相应更新。</li>
<li>父进程和子进程执行不同的代码段。此时，在fork之后子进程与父进程各自关闭不用的文件描述符，这样就不会干扰对方使用的文件描述符。</li>
</ol>
<p>子进程继承于父进程的内容：</p>
<ol>
<li>实际用户ID，实际组ID，有效用户ID，有效组ID。</li>
<li>附属组ID。</li>
<li>进程组ID。</li>
<li>会话ID。</li>
<li>控制终端。</li>
<li>设置用户ID标志和设置组ID标志。</li>
<li>当前工作目录。</li>
<li>根目录。</li>
<li>文件模式创建屏蔽字。</li>
<li>信号屏蔽和安排。</li>
<li>对任一打开文件描述符的执行时关闭（close-on-exce）。</li>
<li>环境。</li>
<li>连接的共享存储字段。</li>
<li>存储映射。</li>
<li>资源限制。</li>
</ol>
<p>父进程和子进程的区别：</p>
<ol>
<li>fork返回值。</li>
<li>进程ID。</li>
<li>父进程ID不同。</li>
<li>子进程的tms_utime,tms_stime,tms_cutime和tms_ustime被设置为0。</li>
<li>子进程不继承父进程设置的文件锁。</li>
<li>子进程未处理的闹钟被清除。</li>
<li>子进程的未处理信号集设置为空集。</li>
</ol>
<p>fork有以下两种用法：</p>
<ol>
<li>一个进程希望复制自己，使父进程与子进程执行不同的代码段，这在网络服务进程中是最常见的。</li>
<li>一个进程要执行一个不同的程序。这对shell来说是常见的。</li>
</ol>
<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程存在八种终止方式。其中五种正常终止：</p>
<ol>
<li>main函数中执行return语句，这等效于调用exit。</li>
<li>调用exit函数。包括调用终止处理程序（atexit登记）。因为ISO C并不处理文件描述符、多进程以及作业控制，所以这一定义对于UNIX是不完整的。</li>
<li>调用<code>_exit</code>或 <code>_Exit</code>函数。<code>_Exit</code>函数为进程提供了一种不用运行终止处理程序或者信号处理程序而终止的方法。<code>_exit</code>与<code>_Exit</code>是同义的。</li>
<li>进程的最后一个线程在其启动例程中执行return语句。该线程的返回值不作为进程的返回值。</li>
<li>进程的最后一个线程调用<code>pthread_exit</code>函数。</li>
</ol>
<p>三种异常终止：</p>
<ol>
<li>调用abort。它产生SIGABRT信号，其为下一中情况的特例。</li>
<li>当进程收到某些信号时。信号可由进程自身（如调用abort）、其他进程或者内核产生。</li>
<li>最后一个线程对“取消”请求作出相应。</li>
</ol>
<p>不管进程如何终止，最终都会执行内核中的同一段代码为相应进程关闭所打开的文件描述符。</p>
<p>对任一种终止情况，我们都希望进程能够通知父进程其是如何终止的。在任意一张情况下，都可以使用<code>wait</code>或<code>waitpid</code>函数来获得其终止信息。</p>
<p>“退出状态”和“终止状态”的区别：在最后调用<code>_exit</code>时，内核将退出状态转换为终止状态。如果子进程正常终止，则父进程可以获得退出状态，否则只能获得终止状态。</p>
<p><font color="red/">对于父进程终止的所以进程，他们的父进程都转换为<code>init</code>进程</font>。我们称这些进程被<code>init</code>收养。操作方式为：当一个进程终止时，内核检查所有活动进程，以判断其父进程是否为终止的进程，如果是则将其父进程ID更改为1。这样能够保证每个进程都存在父进程。被<code>init</code>收养的进程将会被调用<code>wait</code>函数处理。</p>
<p>内核为每一个终止子进程保存了一定量的信息，所以当终止进程的父进程调用<code>wait</code>或<code>waitpid</code>时，可以获得这些信息。这些信息者少包含进程ID，该进程的终止状态以及该进程使用的CPU时间总量。内核可以关闭其所打开文件和释放终止进程所使用的存储器。一个已近终止、但其父进程未对其进行善后处理（获取终止进程相关信息、释放它（信息）所占用的资源）的进程称为僵死进程。ps命令将僵死进程打印为Z。</p>
<h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程终止时，内核就会向其进程发送SIGCHLD信号。父进程可以选择忽略该信号或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。系统默认忽略。当调用<code>wait</code>或者<code>waitpid</code>时情况：</p>
<ol>
<li>如果其所以子进程都还在运行，则阻塞。</li>
<li>如果一个子进程已经终止，正在等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li>
<li>如果不存在任何子进程，则立即出错返回。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options);</span><br><span class="line"></span><br><span class="line"><span class="comment">//成功返回子进程ID，否则返回0</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-C/" rel="tag"># -C/C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/03/C-操作MySQL/" rel="next" title="C++操作MySQL">
                <i class="fa fa-chevron-left"></i> C++操作MySQL
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chst</p>
              <p class="site-description motion-element" itemprop="description">人生苦酒,自酿自品</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-UNIX基础知识"><span class="nav-number">1.</span> <span class="nav-text">第一章 UNIX基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIX体系结构"><span class="nav-number">1.1.</span> <span class="nav-text">UNIX体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shell"><span class="nav-number">1.1.1.</span> <span class="nav-text">shell</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件和目录"><span class="nav-number">1.2.</span> <span class="nav-text">文件和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工作目录"><span class="nav-number">1.2.1.</span> <span class="nav-text">工作目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入和输出"><span class="nav-number">1.3.</span> <span class="nav-text">输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件描述符"><span class="nav-number">1.3.1.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准输入-标准输出和标准错误"><span class="nav-number">1.3.2.</span> <span class="nav-text">标准输入, 标准输出和标准错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不带缓冲的I-O"><span class="nav-number">1.3.3.</span> <span class="nav-text">不带缓冲的I/O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序与进程"><span class="nav-number">1.4.</span> <span class="nav-text">程序与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序"><span class="nav-number">1.4.1.</span> <span class="nav-text">程序:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与进程ID"><span class="nav-number">1.4.2.</span> <span class="nav-text">进程与进程ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程管理"><span class="nav-number">1.4.3.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fork"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#waitpid"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">waitpid</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程和线程ID"><span class="nav-number">1.4.4.</span> <span class="nav-text">线程和线程ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#出错处理"><span class="nav-number">1.5.</span> <span class="nav-text">出错处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#strerror"><span class="nav-number">1.5.1.</span> <span class="nav-text">strerror()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perror"><span class="nav-number">1.5.2.</span> <span class="nav-text">perror()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户ID"><span class="nav-number">1.6.</span> <span class="nav-text">用户ID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户ID-1"><span class="nav-number">1.6.1.</span> <span class="nav-text">用户ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组ID"><span class="nav-number">1.6.2.</span> <span class="nav-text">组ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附属ID"><span class="nav-number">1.6.3.</span> <span class="nav-text">附属ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号-signal"><span class="nav-number">1.7.</span> <span class="nav-text">信号(signal)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间值"><span class="nav-number">1.8.</span> <span class="nav-text">时间值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#日历时间"><span class="nav-number">1.8.1.</span> <span class="nav-text">日历时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程时间"><span class="nav-number">1.8.2.</span> <span class="nav-text">进程时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用和库函数"><span class="nav-number">1.9.</span> <span class="nav-text">系统调用和库函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-文件I-O"><span class="nav-number">2.</span> <span class="nav-text">第三章 文件I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件描述符-1"><span class="nav-number">2.1.</span> <span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数open和openat"><span class="nav-number">2.2.</span> <span class="nav-text">函数open和openat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数creat"><span class="nav-number">2.3.</span> <span class="nav-text">函数creat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数close"><span class="nav-number">2.4.</span> <span class="nav-text">函数close</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数lseek"><span class="nav-number">2.5.</span> <span class="nav-text">函数lseek</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数read"><span class="nav-number">2.6.</span> <span class="nav-text">函数read</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数write"><span class="nav-number">2.7.</span> <span class="nav-text">函数write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件共享"><span class="nav-number">2.8.</span> <span class="nav-text">文件共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子操作"><span class="nav-number">2.9.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数dup和dup2"><span class="nav-number">2.10.</span> <span class="nav-text">函数dup和dup2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数sync-fsync-fdatasync"><span class="nav-number">2.11.</span> <span class="nav-text">函数sync, fsync, fdatasync</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数fcntl"><span class="nav-number">2.12.</span> <span class="nav-text">函数fcntl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dev-fd"><span class="nav-number">2.13.</span> <span class="nav-text">/dev/fd</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-文件和目录"><span class="nav-number">3.</span> <span class="nav-text">第四章 文件和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数stat-fstat-fstatat和lstat"><span class="nav-number">3.1.</span> <span class="nav-text">函数stat, fstat, fstatat和lstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件类型"><span class="nav-number">3.2.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置用户ID和组ID"><span class="nav-number">3.3.</span> <span class="nav-text">设置用户ID和组ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件访问权限"><span class="nav-number">3.4.</span> <span class="nav-text">文件访问权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一"><span class="nav-number">3.4.1.</span> <span class="nav-text">一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二"><span class="nav-number">3.4.2.</span> <span class="nav-text">二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三"><span class="nav-number">3.4.3.</span> <span class="nav-text">三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四"><span class="nav-number">3.4.4.</span> <span class="nav-text">四</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五"><span class="nav-number">3.4.5.</span> <span class="nav-text">五</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六"><span class="nav-number">3.4.6.</span> <span class="nav-text">六</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七"><span class="nav-number">3.4.7.</span> <span class="nav-text">七</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新文件和目录的所有权"><span class="nav-number">3.5.</span> <span class="nav-text">新文件和目录的所有权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数access和faccess"><span class="nav-number">3.6.</span> <span class="nav-text">函数access和faccess</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例-acess-cpp"><span class="nav-number">3.7.</span> <span class="nav-text">例:acess.cpp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数umask-文件模式创建屏蔽字"><span class="nav-number">3.8.</span> <span class="nav-text">函数umask(文件模式创建屏蔽字)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数chmod-fchmod和fchmodat"><span class="nav-number">3.9.</span> <span class="nav-text">函数chmod,fchmod和fchmodat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数chown-fchown-fchownat和lchown"><span class="nav-number">3.10.</span> <span class="nav-text">函数chown,fchown,fchownat和lchown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-number">3.11.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数link-linkat-unlink和remove"><span class="nav-number">3.12.</span> <span class="nav-text">函数link, linkat, unlink和remove</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数rename和renameat"><span class="nav-number">3.13.</span> <span class="nav-text">函数rename和renameat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号链接"><span class="nav-number">3.14.</span> <span class="nav-text">符号链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建和读取符号连接"><span class="nav-number">3.15.</span> <span class="nav-text">创建和读取符号连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件时间"><span class="nav-number">3.16.</span> <span class="nav-text">文件时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数futimens-utimensat-utimes函数"><span class="nav-number">3.17.</span> <span class="nav-text">函数futimens,utimensat,utimes函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数mkdir-mkdirat和rmdir"><span class="nav-number">3.18.</span> <span class="nav-text">函数mkdir,mkdirat和rmdir</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读目录"><span class="nav-number">3.19.</span> <span class="nav-text">读目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数chdir-fchdir和getcwd"><span class="nav-number">3.20.</span> <span class="nav-text">函数chdir,fchdir和getcwd</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-标准I-O库"><span class="nav-number">4.</span> <span class="nav-text">第五章 标准I/O库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#流和FILE对象"><span class="nav-number">4.1.</span> <span class="nav-text">流和FILE对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准输入-标准输出与标准错误"><span class="nav-number">4.2.</span> <span class="nav-text">标准输入,标准输出与标准错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲"><span class="nav-number">4.3.</span> <span class="nav-text">缓冲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打开流"><span class="nav-number">4.4.</span> <span class="nav-text">打开流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读和写流"><span class="nav-number">4.5.</span> <span class="nav-text">读和写流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入函数-一次一个字符"><span class="nav-number">4.5.1.</span> <span class="nav-text">输入函数(一次一个字符)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出函数-一次一个字符"><span class="nav-number">4.5.2.</span> <span class="nav-text">输出函数(一次一个字符)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每次一行I-O"><span class="nav-number">4.6.</span> <span class="nav-text">每次一行I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入一行"><span class="nav-number">4.6.1.</span> <span class="nav-text">输入一行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出一行"><span class="nav-number">4.6.2.</span> <span class="nav-text">输出一行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出举例"><span class="nav-number">4.7.</span> <span class="nav-text">输入输出举例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按字节输入输出"><span class="nav-number">4.7.1.</span> <span class="nav-text">按字节输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按行输入输出"><span class="nav-number">4.7.2.</span> <span class="nav-text">按行输入输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制I-O"><span class="nav-number">4.8.</span> <span class="nav-text">二进制I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化I-O"><span class="nav-number">4.9.</span> <span class="nav-text">格式化I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化输出"><span class="nav-number">4.9.1.</span> <span class="nav-text">格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化输入"><span class="nav-number">4.9.2.</span> <span class="nav-text">格式化输入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现细节"><span class="nav-number">4.10.</span> <span class="nav-text">实现细节</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-系统数据文件和信息"><span class="nav-number">5.</span> <span class="nav-text">第六章 系统数据文件和信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#口令文件"><span class="nav-number">5.1.</span> <span class="nav-text">口令文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阴影口令"><span class="nav-number">5.2.</span> <span class="nav-text">阴影口令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组文件"><span class="nav-number">5.3.</span> <span class="nav-text">组文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附属组ID"><span class="nav-number">5.4.</span> <span class="nav-text">附属组ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他数据文件"><span class="nav-number">5.5.</span> <span class="nav-text">其他数据文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#登录账户记录"><span class="nav-number">5.6.</span> <span class="nav-text">登录账户记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统标识"><span class="nav-number">5.7.</span> <span class="nav-text">系统标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间和日期例程"><span class="nav-number">5.8.</span> <span class="nav-text">时间和日期例程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-进程环境"><span class="nav-number">6.</span> <span class="nav-text">第七章 进程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#main函数"><span class="nav-number">6.1.</span> <span class="nav-text">main函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程终止"><span class="nav-number">6.2.</span> <span class="nav-text">进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-退出函数"><span class="nav-number">6.2.1.</span> <span class="nav-text">1. 退出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-函数atexit"><span class="nav-number">6.2.2.</span> <span class="nav-text">2. 函数atexit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令行参数"><span class="nav-number">6.3.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境表"><span class="nav-number">6.4.</span> <span class="nav-text">环境表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C程序存储空间分布"><span class="nav-number">6.5.</span> <span class="nav-text">C程序存储空间分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享库"><span class="nav-number">6.6.</span> <span class="nav-text">共享库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储空间分配"><span class="nav-number">6.7.</span> <span class="nav-text">存储空间分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境变量"><span class="nav-number">6.8.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数setjmp和longjmp"><span class="nav-number">6.9.</span> <span class="nav-text">函数setjmp和longjmp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动变量、寄存器变量和易失变量"><span class="nav-number">6.9.1.</span> <span class="nav-text">自动变量、寄存器变量和易失变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动变量的潜在问题"><span class="nav-number">6.9.2.</span> <span class="nav-text">自动变量的潜在问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数getrlimit和setrlimit"><span class="nav-number">6.10.</span> <span class="nav-text">函数getrlimit和setrlimit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章-进程控制"><span class="nav-number">7.</span> <span class="nav-text">第八章 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程标识"><span class="nav-number">7.1.</span> <span class="nav-text">进程标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数fork"><span class="nav-number">7.2.</span> <span class="nav-text">函数fork</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数exit"><span class="nav-number">7.3.</span> <span class="nav-text">函数exit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数wait和waitpid"><span class="nav-number">7.4.</span> <span class="nav-text">函数wait和waitpid</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chst</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
